{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.js","path":"main.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/style.js","path":"style.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1476868238078},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1476868238076},{"_id":"themes/yilia/README.md","hash":"2e4f07cb1f66bb4eb6be9c9b451d143320912216","modified":1476868238076},{"_id":"themes/yilia/_config.yml","hash":"a051b2846d4fe41cb83aa73ecb1a2d5e63aaae30","modified":1476949299725},{"_id":"themes/yilia/package.json","hash":"00617be92734bd435ec21614c445bed23cf7448d","modified":1476868238078},{"_id":"themes/yilia/webpack.config.js","hash":"ccf5929d2727b00e76266f9f5d6edc0bc74539dc","modified":1476868238096},{"_id":"source/_posts/原-Device-Tree-入门.md","hash":"cb9ec3c56dc6886f662828757b81360f65f10148","modified":1476957057570},{"_id":"source/_posts/原-I2C协议.md","hash":"07ac449aa194a3322fd7f94b94c01ba9647a064f","modified":1476957532132},{"_id":"source/_posts/原-Makfile笔记.md","hash":"7f0bc3ac7eaa6a65b9da6dcd78c44d0bb9562f45","modified":1476956928789},{"_id":"source/_posts/原-SSH端口转发与内网穿透.md","hash":"6aaacfaba50b0afb564753bb2a9c27de097149a7","modified":1476957549436},{"_id":"source/_posts/原-android系统重启流程分析.md","hash":"58f12d4be4c06485f06d2b3c308ae2ea59bd0418","modified":1476958874162},{"_id":"source/_posts/原-c-差缺补漏.md","hash":"76a17b78ecff9d45ba754fc07a53a6a5e9831fc2","modified":1476956885612},{"_id":"source/_posts/原-linux字符设备驱动初识.md","hash":"4fafad160af257335dd20387792547fac1b701ab","modified":1476957620883},{"_id":"source/_posts/原-list-for-each-entry深入理解.md","hash":"6ba434fbda62e007f96f11d362cf943948a12b8f","modified":1476956280111},{"_id":"source/_posts/原-shell-初识.md","hash":"bf028f6498bf2097f065497df08965805a8ee6f9","modified":1476957464516},{"_id":"source/_posts/原-ubuntu-定时任务.md","hash":"f0fce4cc8eb4f1160b5bde3316e89c5e94792bea","modified":1476957633940},{"_id":"source/_posts/原-ubuntu下添加用户.md","hash":"0666750169f99d7d33e6e8df0231ec3b904ead54","modified":1476956317282},{"_id":"source/_posts/原-windows下的adb连接调试.md","hash":"1c2a0def46fadd3c5a45c0b5791dd6fd0bff36e8","modified":1476956973267},{"_id":"source/_posts/原-中断处理.md","hash":"ce9c5bdf1f3575a6a8197384dd4beb37bb0a736c","modified":1476957022265},{"_id":"source/_posts/原-并发与竞态.md","hash":"02d6aa08e8c6ba686925cbcecc4494d2d4899d86","modified":1476957488412},{"_id":"source/_posts/原-时间、延迟及延缓操作.md","hash":"9968d0f4196a75d524bed1b233d4026d1c9be433","modified":1476957650283},{"_id":"source/_posts/原-网络驱动接口笔记.md","hash":"30e2a2245648d2d5622af8fd312708d60ef2162d","modified":1476956843297},{"_id":"source/_posts/原-驱动中ioctl的使用.md","hash":"3888de8b109211c64f290014a8accbe9d5252977","modified":1476957584675},{"_id":"source/_posts/转-MIPI-小结.md","hash":"040d6c11a9cee32e82d6554bd9e6affcfc7b3dd0","modified":1476957603276},{"_id":"source/_posts/转-attribute-机制.md","hash":"c0277cf26eae280637673e1eaf79d6cc8aa3b48f","modified":1476957505909},{"_id":"source/_posts/转-搬瓦工网速优化net-speeder.md","hash":"2874e1c90108fd4395a8c4877edd4385f16d1afd","modified":1476958331308},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1476868238094},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1476868238095},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1476868238094},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1476868238095},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1476868238095},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1476868238094},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1476868238095},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1476868238162},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1476868238162},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1476868238162},{"_id":"themes/yilia/layout/layout.ejs","hash":"18bc94a020c6e74b0a7a29bc412670605e0c0873","modified":1476868238162},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1476868238163},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1476868238162},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1476868238162},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"ef0205fa690a388e48ddcb62ed77f05c753a7b9d","modified":1476868238165},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1476868238163},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1476868238163},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"1d30a5373398a9f780a590478d073cb41d96093c","modified":1477031923728},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1476868238167},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1476868238163},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"9d24d167778e7d0da6baa74dcd90c739afb549d9","modified":1476868238164},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"d78993618051392103df1107c0da5abb81e2acac","modified":1476868238164},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"256f83ef8bc7bdc8f69617e606fe1118136b5208","modified":1476868238163},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1476868238164},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"324f809c7d1505cbf1ef3a479782c67ae90dfa81","modified":1476868238164},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c5b92f83828e41a891c6db1d3e63cd2e007034e0","modified":1476868238164},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1476868238164},{"_id":"themes/yilia/source/main.js","hash":"591b5266281ba1840ac4e64b24e371449145d57c","modified":1476868238077},{"_id":"themes/yilia/source/style.js","hash":"1ebf7574e1e27a3c079e5686b82a7e17abc3fb98","modified":1476868238078},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1476868238092},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1476868238092},{"_id":"themes/yilia/source-src/css/archive-inner.scss","hash":"c70d67116dd4a8ff0a10c397059823820f846dbd","modified":1476868238086},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"b750499d5120f963b683d0c96ac3f345c714e448","modified":1476868238092},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"4edb98e196eac9e67f86b76e39a2a03673391842","modified":1476868238088},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"000a5875e1e46116b824c9ac0657178093ce4a17","modified":1476868238088},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"d046414a96adc400b54897fc236b3272e6deeafd","modified":1476868238086},{"_id":"themes/yilia/source-src/css/article.scss","hash":"b1add6b3c05416ac854ec5dd9d4cc20be3fafc1f","modified":1476868238088},{"_id":"themes/yilia/source-src/css/duoshuo.scss","hash":"1a4be8634b8dcf271cebad1feb687e96a038ffbf","modified":1476868238084},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"f5ee21869fcd3e2b257b49b0f680c78763d416dd","modified":1476868238084},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1476868238087},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1476868238086},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"fe592c32cc2e6462358ac907e1e38a0dad01219f","modified":1476868238092},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"819774a2979d0d94eb4e3ebf62afc96f803bac67","modified":1476868238084},{"_id":"themes/yilia/source-src/css/left.scss","hash":"2a261fa2e402909a866c648a5de8eb287da6fba9","modified":1476868238087},{"_id":"themes/yilia/source-src/css/main.scss","hash":"5ffabb8323ff8cd26be466c7e02a6affc0f08da7","modified":1476868238087},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"4277e4b7e8fef5480d8e2b9574cbfdf59f0225c8","modified":1476868238088},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"c170329ef2e7c2dcec58b1134793beac521133d4","modified":1476868238092},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1476868238084},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1476868238087},{"_id":"themes/yilia/source-src/css/social.scss","hash":"5b4a2cfd8a26687dc7bc44a4fa55ebb7d1ffe363","modified":1476868238086},{"_id":"themes/yilia/source-src/css/style.js","hash":"6c4cb072d0d5cbbb5291aa255dee31c7b13cfe66","modified":1476868238094},{"_id":"themes/yilia/source-src/css/switch.scss","hash":"795b0d1ad5ff278933409a1ab7451483fe6ceae5","modified":1476868238087},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1476868238084},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"79d3fad4fcda15210410774089b0ee7fe8d58810","modified":1476868238086},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"c92aa91195696d1f2e5280a8db358593068e5e76","modified":1476868238087},{"_id":"themes/yilia/source-src/js/archive-inner.js","hash":"da4a770ccb23ca1ded23fa6475ce1379f0c10604","modified":1476868238079},{"_id":"themes/yilia/source-src/js/browser.js","hash":"8ca48b006591bbf6d75688637c14fd1b5bdd650f","modified":1476868238081},{"_id":"themes/yilia/source-src/js/fix-page.js","hash":"f18e33e99b1032b95a60b018960bed64235c1a29","modified":1476868238079},{"_id":"themes/yilia/source-src/js/jquery.lazyload.js","hash":"37961302284435b2677b7fd1e0c0f7624e226e4a","modified":1476868238078},{"_id":"themes/yilia/source-src/js/main.js","hash":"a2dc03513509a04003185891c33d47f1de5c49dc","modified":1476868238079},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d79f5f2d789e6cddfd7b502df238107e9c63aac","modified":1476868238079},{"_id":"themes/yilia/source-src/js/tags.js","hash":"f259b3f808df3a8523a42978f922bb9eda76e0ee","modified":1476868238079},{"_id":"themes/yilia/source-src/js/tools.js","hash":"ed69771cd501770c2c303ae6ae695d2a9a187cdd","modified":1476868238081},{"_id":"themes/yilia/source-src/js/util.js","hash":"28c66c54cab81b2a6c8c393226f5bd30f369e1bb","modified":1476868238081},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"8b68f943b259bf6b4a648a10efe6c0160a880017","modified":1476868238081},{"_id":"themes/yilia/source-src/photoSwipe/photoswipe-ui-default.js","hash":"724162c14e5722a2ce1f44cf086dcea7b6855b80","modified":1476868238083},{"_id":"themes/yilia/source-src/photoSwipe/photoswipe-ui-default.min.js","hash":"38557bef17c33e172bc8e1670cd302d91622dfad","modified":1476868238083},{"_id":"themes/yilia/source-src/photoSwipe/photoswipe.min.js","hash":"e3267f5ae23f00c1ae052d019f12787296e34afc","modified":1476868238082},{"_id":"themes/yilia/source-src/photoSwipe/photoswipe.scss","hash":"838d43529282b91a60934bbd39f3f9f5dbefee98","modified":1476868238083},{"_id":"themes/yilia/source-src/photoSwipe/photoswipe.js","hash":"ff9e3cc58b44a61144a9e211503755b170c24e91","modified":1476868238083},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"62cde65a4ab7aef85a4390308bc7608f59463e02","modified":1476868238165},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"2ab4308d013dcb1f0898cf112e3f75573e597e33","modified":1476868238167},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1476868238165},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1476868238166},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","hash":"d9fa04c06319510bd088ca9c286af947da3cfb38","modified":1476868238165},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","hash":"a59c83e46aaccb053b60bb41369dfcd6848cbd69","modified":1476868238166},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"3a44b657ebdeed1764d90f81b43e91e5a8f25c21","modified":1476868238165},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1476868238165},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"6f44ec8ff32515280c0b7ea8ad7e4cb5f4dfcd84","modified":1476868238093},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1476868238093},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"dc89a3b360881584838cdd9b95fe88aae6518e50","modified":1476868238094},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1476868238093},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1476868238093},{"_id":"themes/yilia/source-src/css/fonts/icomoon.eot","hash":"9a661069e1255d10032926a8ef87502f445f4e20","modified":1476868238085},{"_id":"themes/yilia/source-src/css/fonts/icomoon.svg","hash":"56ba63db8bfe20347e0457b4c583dd18e29ca701","modified":1476868238085},{"_id":"themes/yilia/source-src/css/fonts/icomoon.ttf","hash":"9f1e824fc076dbfedf186609a2664558d5e3e986","modified":1476868238085},{"_id":"themes/yilia/source-src/css/fonts/icomoon.woff","hash":"a5c2eb785800a3a0aeaf2284d191d69df1893d6d","modified":1476868238085},{"_id":"themes/yilia/source-src/css/img/black-scales.png","hash":"243ea748d016704922ccfc0b6c18d97472c27bff","modified":1476868238092},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1476868238091},{"_id":"themes/yilia/source-src/css/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1476868238091},{"_id":"themes/yilia/source-src/css/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1476868238092},{"_id":"themes/yilia/source-src/css/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1476868238091},{"_id":"themes/yilia/source-src/css/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1476868238090},{"_id":"themes/yilia/source-src/css/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1476868238088},{"_id":"themes/yilia/source-src/css/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1476868238089},{"_id":"themes/yilia/source-src/css/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1476868238090},{"_id":"themes/yilia/source-src/css/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1476868238090},{"_id":"themes/yilia/source-src/css/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1476868238090},{"_id":"themes/yilia/source-src/css/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1476868238091},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1476868238091},{"_id":"themes/yilia/source-src/css/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1476868238089},{"_id":"themes/yilia/source-src/css/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1476868238090},{"_id":"themes/yilia/source-src/css/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1476868238091},{"_id":"themes/yilia/source-src/css/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1476868238089},{"_id":"themes/yilia/source-src/photoSwipe/default-skin/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1476868238082},{"_id":"themes/yilia/source-src/photoSwipe/default-skin/default-skin.scss","hash":"91f44576a5f5ccff4740ff5020656bd2f00ca13c","modified":1476868238081},{"_id":"themes/yilia/source-src/photoSwipe/default-skin/default-skin.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1476868238082},{"_id":"themes/yilia/source-src/photoSwipe/default-skin/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1476868238082},{"_id":"themes/yilia/source-src/css/img/black-paper.png","hash":"a180d3109a5cb6b9b9aa60d81730446ebe275473","modified":1476868238089},{"_id":"themes/yilia/source-src/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1476868238080},{"_id":"public/2016/09/22/原-驱动中ioctl的使用/index.html","hash":"88d8dfeee7acd5a9da744e2fc9e818387293024b","modified":1477031937354},{"_id":"public/2016/09/18/原-I2C协议/index.html","hash":"be4694e06cc6e6aa8482601bf03dd39ae732c7f0","modified":1477031937354},{"_id":"public/2016/08/25/原-c-差缺补漏/index.html","hash":"f1c97fa16bff6438a92e83ea070370fb529d3c39","modified":1477031937354},{"_id":"public/2016/08/24/原-ubuntu-定时任务/index.html","hash":"71e20a7d7b5d710ba20ccf854497ac70ca19a604","modified":1477031937355},{"_id":"public/2016/08/03/原-list-for-each-entry深入理解/index.html","hash":"1b0420592f1ce423cdc277653528d8d839a6423b","modified":1477031937355},{"_id":"public/2016/08/03/原-SSH端口转发与内网穿透/index.html","hash":"522fc6d9a525c9ac030dca843fc0d44ec6b3d73b","modified":1477031937355},{"_id":"public/2016/07/08/转-搬瓦工网速优化net-speeder/index.html","hash":"20aa8e32deb83ec1e5d8deb01b5032212f7c8794","modified":1477031937355},{"_id":"public/2016/05/16/原-linux字符设备驱动初识/index.html","hash":"a1facb1fdaeafbf5b79f90ceecd37ffcb1760d77","modified":1477031937355},{"_id":"public/2016/04/25/转-MIPI-小结/index.html","hash":"fb9f665a26f37292c39d6aea684b7cbbfbdf8858","modified":1477031937355},{"_id":"public/2016/02/26/原-windows下的adb连接调试/index.html","hash":"db6dee4b588a7237c267941023c729abd690ca9e","modified":1477031937355},{"_id":"public/2016/02/25/原-ubuntu下添加用户/index.html","hash":"d5598fa3879488f9196415919717a52258bd8aa5","modified":1477031937355},{"_id":"public/archives/index.html","hash":"348a362ca094e1f5a460ef4c72d2e3c9f5f08da9","modified":1477030223046},{"_id":"public/archives/page/2/index.html","hash":"0c94be67da54baa679a6d9edf35c78e6b691dc8e","modified":1477030223046},{"_id":"public/archives/2016/index.html","hash":"c5f2184e0e924194c6d1fabeba69514dc292bd8d","modified":1477030223046},{"_id":"public/archives/2016/page/2/index.html","hash":"0804177ef8ec4d14d15553ddef25426977a63af3","modified":1477030223046},{"_id":"public/archives/2016/02/index.html","hash":"8bafa22dba07b56251be0622bf1333ae2a40f3c3","modified":1477030223046},{"_id":"public/archives/2016/04/index.html","hash":"c0025439480a1d1fa770bbda28af362320108594","modified":1477030223046},{"_id":"public/archives/2016/05/index.html","hash":"6a6a15cac5f2e87eff4ba786eab4f145a8866ce8","modified":1477030223047},{"_id":"public/archives/2016/06/index.html","hash":"925add8ca012fda4dc7dc9f90b10e30aa797379e","modified":1477030223047},{"_id":"public/archives/2016/07/index.html","hash":"11bc08e303102d105b195f79cfe738dea3170047","modified":1477030223047},{"_id":"public/archives/2016/08/index.html","hash":"709e74434c15a46dc037ba09ddc8d5d739de2559","modified":1477030223047},{"_id":"public/archives/2016/09/index.html","hash":"b053bbf2b29cecf63f69fcec5d89f954141e6c72","modified":1477030223047},{"_id":"public/2016/09/29/原-中断处理/index.html","hash":"0624de30c412c8bbcab4cdc9f65703cc16a3c353","modified":1477031937355},{"_id":"public/2016/09/21/原-时间、延迟及延缓操作/index.html","hash":"3499d103dd6f97331998d024157799cf7edc2861","modified":1477031937355},{"_id":"public/2016/09/12/转-attribute-机制/index.html","hash":"52caba357f81a16c4ffdc83e245c3d2e646ea47d","modified":1477031937356},{"_id":"public/2016/08/26/原-Device-Tree-入门/index.html","hash":"60b5e696bda0d262f78d588075e2123f95216db9","modified":1477031937356},{"_id":"public/2016/06/30/原-网络驱动接口笔记/index.html","hash":"a3c67c2f9dd3ca3be5131c2f4649476bbb3261b3","modified":1477031937356},{"_id":"public/2016/06/29/原-shell-初识/index.html","hash":"105fb788ae09cc17776393e3d59d3b9ab157e8a3","modified":1477031937356},{"_id":"public/2016/05/31/原-android系统重启流程分析/index.html","hash":"1007929334ec93b7e88ecc5596db37d5a3a9d28c","modified":1477031937356},{"_id":"public/2016/04/27/原-并发与竞态/index.html","hash":"1fcc3871500cff6678723d3de704e7dd1805bf03","modified":1477031937356},{"_id":"public/2016/04/23/原-Makfile笔记/index.html","hash":"de084a5ad9d2c88f16be2146b95f538824e55345","modified":1477031937356},{"_id":"public/index.html","hash":"758df8c987a8476db491edca14ad1168ec3fbb1c","modified":1477030223047},{"_id":"public/page/2/index.html","hash":"b2472db1da55ca1de0b6090c6a2792cdbc317e74","modified":1477030223048},{"_id":"public/main.js","hash":"591b5266281ba1840ac4e64b24e371449145d57c","modified":1477030223065},{"_id":"public/style.js","hash":"1ebf7574e1e27a3c079e5686b82a7e17abc3fb98","modified":1477030223065}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"[原]Device Tree 入门","date":"2016-08-26T18:15:06.000Z","_content":"\n1.写在前面 \n\n本文是本人在阅读了蜗窝科技的Device Tree三篇文章后的笔记，他的这几篇文章是我最近了解到的在Device Tree方面讲的比较深入细致的，非常感谢蜗窝科技为我们提供的学习机会，如果有需要，请你们去[蜗窝科技](http://www.wowotech.net/device_model/why-dt.html)。 \n\n2.Device Tree结构\n\n    kernel/arch/arm/boot/dts/skeleton.dtsi:\n    / {\n        #address-cells = &lt;1&gt;;\n        #size-cells = &lt;1&gt;;\n        cpus { };\n        soc { };\n        chosen { };\n        aliases { };\n        memory { device_type = \"memory\"; reg = &lt;0 0&gt;; };\n    };\n    kernel/arch/arm/boot/dts/qcom/skeleton.dtsi:\n    #include \"skeleton64.dtsi\"\n    #include &lt;dt-bindings/clock/msm-clocks-8953.h&gt;\n    #include &lt;dt-bindings/regulator/qcom,rpm-smd-regulator.h&gt;\n    #include &lt;dt-bindings/gpio/gpio.h&gt;\n    / {\n        model = \"Qualcomm Technologies, Inc. MSM 8953\";\n        compatible = \"qcom,msm8953\";\n        qcom,msm-id = &lt;293 0x0&gt;;\n        interrupt-parent = &lt;&amp;intc&gt;;\n\n        chosen {\n            bootargs = \"sched_enable_hmp=1 sched_enable_power_aware=1\";\n        };\n\n        reserved-memory {\n            #address-cells = &lt;2&gt;;\n            #size-cells = &lt;2&gt;;\n            ranges;\n\n            other_ext_mem: other_ext_region@0 {\n                compatible = \"removed-dma-pool\";\n                no-map;\n                reg = &lt;0x0 0x83300000 0x0 0x3800000&gt;;\n            };\n\n            modem_mem: modem_region@0 {\n                compatible = \"removed-dma-pool\";\n                no-map-fixup;\n                reg = &lt;0x0 0x86c00000 0x0 0x5600000&gt;;\n            };\n\n            reloc_mem: reloc_region@0 {\n                compatible = \"removed-dma-pool\";\n                no-map;\n                reg = &lt;0x0 0x8c200000 0x0 0x1800000&gt;;\n            };\n\n            venus_mem: venus_region@0 {\n                compatible = \"shared-dma-pool\";\n                reusable;\n                alloc-ranges = &lt;0x0 0x80000000 0x0 0x10000000&gt;;\n                alignment = &lt;0 0x400000&gt;;\n                size = &lt;0 0x0800000&gt;;\n            };\n\n            secure_mem: secure_region@0 {\n                compatible = \"shared-dma-pool\";\n                reusable;\n                alignment = &lt;0 0x400000&gt;;\n                size = &lt;0 0x09800000&gt;;\n            };\n\n            qseecom_mem: qseecom_region@0 {\n                compatible = \"shared-dma-pool\";\n                reusable;\n                alignment = &lt;0 0x400000&gt;;\n                size = &lt;0 0x1000000&gt;;\n            };\n\n            adsp_mem: adsp_region@0 {\n                compatible = \"shared-dma-pool\";\n                reusable;\n                size = &lt;0 0x400000&gt;;\n            };\n\n            dfps_data_mem: dfps_data_mem@90000000 {\n                   reg = &lt;0 0x90000000 0 0x1000&gt;;\n                   label = \"dfps_data_mem\";\n            };\n\n            cont_splash_mem: splash_region@0x90001000 {\n                reg = &lt;0x0 0x90001000 0x0 0x13ff000&gt;;\n                label = \"cont_splash_mem\";\n            };\n\n            gpu_mem: gpu_region@0 {\n                compatible = \"shared-dma-pool\";\n                reusable;\n                alloc-ranges = &lt;0x0 0x80000000 0x0 0x10000000&gt;;\n                alignment = &lt;0 0x400000&gt;;\n                size = &lt;0 0x800000&gt;;\n            };\n        };\n\n        aliases {\n            /* smdtty devices */\n            smd1 = &amp;smdtty_apps_fm;\n            smd2 = &amp;smdtty_apps_riva_bt_acl;\n            smd3 = &amp;smdtty_apps_riva_bt_cmd;\n            smd4 = &amp;smdtty_mbalbridge;\n            smd5 = &amp;smdtty_apps_riva_ant_cmd;\n            smd6 = &amp;smdtty_apps_riva_ant_data;\n            smd7 = &amp;smdtty_data1;\n            smd8 = &amp;smdtty_data4;\n            smd11 = &amp;smdtty_data11;\n            smd21 = &amp;smdtty_data21;\n            smd36 = &amp;smdtty_loopback;\n            sdhc1 = &amp;sdhc_1; /* SDC1 eMMC slot */\n            sdhc2 = &amp;sdhc_2; /* SDC2 for SD card */\n            i2c1 = &amp;i2c_1;\n            i2c2 = &amp;i2c_2;\n            i2c3 = &amp;i2c_3;\n            i2c5 = &amp;i2c_5;\n            spi3 = &amp;spi_3;\n        };\n\n        soc: soc { };\n\n    };\n    由上面的例子看出Device Tree有一下特点：\n    1.节点node\n        1.1每个node可以包含sub node和property/value；\n        1.2每个DTS都只有一个ROOT node；\n        1.3一个node可以有多个sub node，但只能有一个parent node；\n        1.4一个node可以包含多个property/value描述该node的具体信息；\n        1.5每个node用节点名字（node name）标识，节点名字的格式是node-name@unit-address。如果该node没有reg属性（后面会描述这个property），那么该节点名字中必须不能包括@和unit-address。\n    2.属性/值property/value\n        2.1一般属性：\n        属性值表示了该设备节点的具体特性，它的值是多样性的：\n        1)可能为空，即没有值的定义；\n        2)可能为32bit或64bit整数值(#size-cells = &lt;2&gt;)或者数组(reg = &lt;0x0 0x86c00000 0x0 0x5600000&gt;)；\n        3）可能为string(label = \"cont_splash_mem\")或string list(compatible = \"qcom,msm8953\")；\n        2.2特殊属性：\n        #address-cells = &lt;1&gt;;\n        #size-cells = &lt;0&gt;;\n        #类似number，#address-cells表示子节点中reg中的地址元素需要用多少个32bit值来表示，#size-cells表示子节点中reg中的大小元素需要用多少个32bit值来表示。`</pre>\n\n    3.Device Tree source file语法\n\n    <pre class=\"prettyprint\">`1.节点定义：\n        [label:] node-name[@unit-address] { \n           [properties definitions];\n           [child nodes];\n        };\n    2.节点引用：\n        1)直接引用：绝对路径，/node-name-1/node-name-2/node-name-N；\n        2)别名引用：所有别名被定义在节点aliases中；\n        3)lable引用：&amp;lable；\n    3.属性定义：\n        property ＝ value;\n        再次注意value的三种方式：\n        1)32bit unsigned integers：#size-cells = &lt;2&gt;;\n        2)binary data：binary-property = [0x01 0x23 0x45 0x67];\n        3)string/string list：device_type = \"memory\";\n\n            <div>\n                作者：WEINILUO 发表于2016/8/26 14:15:06 [原文链接](http://blog.csdn.net/weiniluo/article/details/52326801)\n            </div>\n            <div>\n            阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52326801#comments)\n            </div>\n","source":"_posts/原-Device-Tree-入门.md","raw":"---\ntitle: '[原]Device Tree 入门'\ntags: []\ndate: 2016-08-26 14:15:06\n---\n\n1.写在前面 \n\n本文是本人在阅读了蜗窝科技的Device Tree三篇文章后的笔记，他的这几篇文章是我最近了解到的在Device Tree方面讲的比较深入细致的，非常感谢蜗窝科技为我们提供的学习机会，如果有需要，请你们去[蜗窝科技](http://www.wowotech.net/device_model/why-dt.html)。 \n\n2.Device Tree结构\n\n    kernel/arch/arm/boot/dts/skeleton.dtsi:\n    / {\n        #address-cells = &lt;1&gt;;\n        #size-cells = &lt;1&gt;;\n        cpus { };\n        soc { };\n        chosen { };\n        aliases { };\n        memory { device_type = \"memory\"; reg = &lt;0 0&gt;; };\n    };\n    kernel/arch/arm/boot/dts/qcom/skeleton.dtsi:\n    #include \"skeleton64.dtsi\"\n    #include &lt;dt-bindings/clock/msm-clocks-8953.h&gt;\n    #include &lt;dt-bindings/regulator/qcom,rpm-smd-regulator.h&gt;\n    #include &lt;dt-bindings/gpio/gpio.h&gt;\n    / {\n        model = \"Qualcomm Technologies, Inc. MSM 8953\";\n        compatible = \"qcom,msm8953\";\n        qcom,msm-id = &lt;293 0x0&gt;;\n        interrupt-parent = &lt;&amp;intc&gt;;\n\n        chosen {\n            bootargs = \"sched_enable_hmp=1 sched_enable_power_aware=1\";\n        };\n\n        reserved-memory {\n            #address-cells = &lt;2&gt;;\n            #size-cells = &lt;2&gt;;\n            ranges;\n\n            other_ext_mem: other_ext_region@0 {\n                compatible = \"removed-dma-pool\";\n                no-map;\n                reg = &lt;0x0 0x83300000 0x0 0x3800000&gt;;\n            };\n\n            modem_mem: modem_region@0 {\n                compatible = \"removed-dma-pool\";\n                no-map-fixup;\n                reg = &lt;0x0 0x86c00000 0x0 0x5600000&gt;;\n            };\n\n            reloc_mem: reloc_region@0 {\n                compatible = \"removed-dma-pool\";\n                no-map;\n                reg = &lt;0x0 0x8c200000 0x0 0x1800000&gt;;\n            };\n\n            venus_mem: venus_region@0 {\n                compatible = \"shared-dma-pool\";\n                reusable;\n                alloc-ranges = &lt;0x0 0x80000000 0x0 0x10000000&gt;;\n                alignment = &lt;0 0x400000&gt;;\n                size = &lt;0 0x0800000&gt;;\n            };\n\n            secure_mem: secure_region@0 {\n                compatible = \"shared-dma-pool\";\n                reusable;\n                alignment = &lt;0 0x400000&gt;;\n                size = &lt;0 0x09800000&gt;;\n            };\n\n            qseecom_mem: qseecom_region@0 {\n                compatible = \"shared-dma-pool\";\n                reusable;\n                alignment = &lt;0 0x400000&gt;;\n                size = &lt;0 0x1000000&gt;;\n            };\n\n            adsp_mem: adsp_region@0 {\n                compatible = \"shared-dma-pool\";\n                reusable;\n                size = &lt;0 0x400000&gt;;\n            };\n\n            dfps_data_mem: dfps_data_mem@90000000 {\n                   reg = &lt;0 0x90000000 0 0x1000&gt;;\n                   label = \"dfps_data_mem\";\n            };\n\n            cont_splash_mem: splash_region@0x90001000 {\n                reg = &lt;0x0 0x90001000 0x0 0x13ff000&gt;;\n                label = \"cont_splash_mem\";\n            };\n\n            gpu_mem: gpu_region@0 {\n                compatible = \"shared-dma-pool\";\n                reusable;\n                alloc-ranges = &lt;0x0 0x80000000 0x0 0x10000000&gt;;\n                alignment = &lt;0 0x400000&gt;;\n                size = &lt;0 0x800000&gt;;\n            };\n        };\n\n        aliases {\n            /* smdtty devices */\n            smd1 = &amp;smdtty_apps_fm;\n            smd2 = &amp;smdtty_apps_riva_bt_acl;\n            smd3 = &amp;smdtty_apps_riva_bt_cmd;\n            smd4 = &amp;smdtty_mbalbridge;\n            smd5 = &amp;smdtty_apps_riva_ant_cmd;\n            smd6 = &amp;smdtty_apps_riva_ant_data;\n            smd7 = &amp;smdtty_data1;\n            smd8 = &amp;smdtty_data4;\n            smd11 = &amp;smdtty_data11;\n            smd21 = &amp;smdtty_data21;\n            smd36 = &amp;smdtty_loopback;\n            sdhc1 = &amp;sdhc_1; /* SDC1 eMMC slot */\n            sdhc2 = &amp;sdhc_2; /* SDC2 for SD card */\n            i2c1 = &amp;i2c_1;\n            i2c2 = &amp;i2c_2;\n            i2c3 = &amp;i2c_3;\n            i2c5 = &amp;i2c_5;\n            spi3 = &amp;spi_3;\n        };\n\n        soc: soc { };\n\n    };\n    由上面的例子看出Device Tree有一下特点：\n    1.节点node\n        1.1每个node可以包含sub node和property/value；\n        1.2每个DTS都只有一个ROOT node；\n        1.3一个node可以有多个sub node，但只能有一个parent node；\n        1.4一个node可以包含多个property/value描述该node的具体信息；\n        1.5每个node用节点名字（node name）标识，节点名字的格式是node-name@unit-address。如果该node没有reg属性（后面会描述这个property），那么该节点名字中必须不能包括@和unit-address。\n    2.属性/值property/value\n        2.1一般属性：\n        属性值表示了该设备节点的具体特性，它的值是多样性的：\n        1)可能为空，即没有值的定义；\n        2)可能为32bit或64bit整数值(#size-cells = &lt;2&gt;)或者数组(reg = &lt;0x0 0x86c00000 0x0 0x5600000&gt;)；\n        3）可能为string(label = \"cont_splash_mem\")或string list(compatible = \"qcom,msm8953\")；\n        2.2特殊属性：\n        #address-cells = &lt;1&gt;;\n        #size-cells = &lt;0&gt;;\n        #类似number，#address-cells表示子节点中reg中的地址元素需要用多少个32bit值来表示，#size-cells表示子节点中reg中的大小元素需要用多少个32bit值来表示。`</pre>\n\n    3.Device Tree source file语法\n\n    <pre class=\"prettyprint\">`1.节点定义：\n        [label:] node-name[@unit-address] { \n           [properties definitions];\n           [child nodes];\n        };\n    2.节点引用：\n        1)直接引用：绝对路径，/node-name-1/node-name-2/node-name-N；\n        2)别名引用：所有别名被定义在节点aliases中；\n        3)lable引用：&amp;lable；\n    3.属性定义：\n        property ＝ value;\n        再次注意value的三种方式：\n        1)32bit unsigned integers：#size-cells = &lt;2&gt;;\n        2)binary data：binary-property = [0x01 0x23 0x45 0x67];\n        3)string/string list：device_type = \"memory\";\n\n            <div>\n                作者：WEINILUO 发表于2016/8/26 14:15:06 [原文链接](http://blog.csdn.net/weiniluo/article/details/52326801)\n            </div>\n            <div>\n            阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52326801#comments)\n            </div>\n","slug":"原-Device-Tree-入门","published":1,"updated":"2016-10-20T09:50:57.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnobj0000vzs6ytqmuuc5","content":"<p>1.写在前面 </p>\n<p>本文是本人在阅读了蜗窝科技的Device Tree三篇文章后的笔记，他的这几篇文章是我最近了解到的在Device Tree方面讲的比较深入细致的，非常感谢蜗窝科技为我们提供的学习机会，如果有需要，请你们去<a href=\"http://www.wowotech.net/device_model/why-dt.html\" target=\"_blank\" rel=\"external\">蜗窝科技</a>。 </p>\n<p>2.Device Tree结构</p>\n<pre><code>kernel/arch/arm/boot/dts/skeleton.dtsi:\n/ {\n    #address-cells = &amp;lt;1&amp;gt;;\n    #size-cells = &amp;lt;1&amp;gt;;\n    cpus { };\n    soc { };\n    chosen { };\n    aliases { };\n    memory { device_type = &quot;memory&quot;; reg = &amp;lt;0 0&amp;gt;; };\n};\nkernel/arch/arm/boot/dts/qcom/skeleton.dtsi:\n#include &quot;skeleton64.dtsi&quot;\n#include &amp;lt;dt-bindings/clock/msm-clocks-8953.h&amp;gt;\n#include &amp;lt;dt-bindings/regulator/qcom,rpm-smd-regulator.h&amp;gt;\n#include &amp;lt;dt-bindings/gpio/gpio.h&amp;gt;\n/ {\n    model = &quot;Qualcomm Technologies, Inc. MSM 8953&quot;;\n    compatible = &quot;qcom,msm8953&quot;;\n    qcom,msm-id = &amp;lt;293 0x0&amp;gt;;\n    interrupt-parent = &amp;lt;&amp;amp;intc&amp;gt;;\n\n    chosen {\n        bootargs = &quot;sched_enable_hmp=1 sched_enable_power_aware=1&quot;;\n    };\n\n    reserved-memory {\n        #address-cells = &amp;lt;2&amp;gt;;\n        #size-cells = &amp;lt;2&amp;gt;;\n        ranges;\n\n        other_ext_mem: other_ext_region@0 {\n            compatible = &quot;removed-dma-pool&quot;;\n            no-map;\n            reg = &amp;lt;0x0 0x83300000 0x0 0x3800000&amp;gt;;\n        };\n\n        modem_mem: modem_region@0 {\n            compatible = &quot;removed-dma-pool&quot;;\n            no-map-fixup;\n            reg = &amp;lt;0x0 0x86c00000 0x0 0x5600000&amp;gt;;\n        };\n\n        reloc_mem: reloc_region@0 {\n            compatible = &quot;removed-dma-pool&quot;;\n            no-map;\n            reg = &amp;lt;0x0 0x8c200000 0x0 0x1800000&amp;gt;;\n        };\n\n        venus_mem: venus_region@0 {\n            compatible = &quot;shared-dma-pool&quot;;\n            reusable;\n            alloc-ranges = &amp;lt;0x0 0x80000000 0x0 0x10000000&amp;gt;;\n            alignment = &amp;lt;0 0x400000&amp;gt;;\n            size = &amp;lt;0 0x0800000&amp;gt;;\n        };\n\n        secure_mem: secure_region@0 {\n            compatible = &quot;shared-dma-pool&quot;;\n            reusable;\n            alignment = &amp;lt;0 0x400000&amp;gt;;\n            size = &amp;lt;0 0x09800000&amp;gt;;\n        };\n\n        qseecom_mem: qseecom_region@0 {\n            compatible = &quot;shared-dma-pool&quot;;\n            reusable;\n            alignment = &amp;lt;0 0x400000&amp;gt;;\n            size = &amp;lt;0 0x1000000&amp;gt;;\n        };\n\n        adsp_mem: adsp_region@0 {\n            compatible = &quot;shared-dma-pool&quot;;\n            reusable;\n            size = &amp;lt;0 0x400000&amp;gt;;\n        };\n\n        dfps_data_mem: dfps_data_mem@90000000 {\n               reg = &amp;lt;0 0x90000000 0 0x1000&amp;gt;;\n               label = &quot;dfps_data_mem&quot;;\n        };\n\n        cont_splash_mem: splash_region@0x90001000 {\n            reg = &amp;lt;0x0 0x90001000 0x0 0x13ff000&amp;gt;;\n            label = &quot;cont_splash_mem&quot;;\n        };\n\n        gpu_mem: gpu_region@0 {\n            compatible = &quot;shared-dma-pool&quot;;\n            reusable;\n            alloc-ranges = &amp;lt;0x0 0x80000000 0x0 0x10000000&amp;gt;;\n            alignment = &amp;lt;0 0x400000&amp;gt;;\n            size = &amp;lt;0 0x800000&amp;gt;;\n        };\n    };\n\n    aliases {\n        /* smdtty devices */\n        smd1 = &amp;amp;smdtty_apps_fm;\n        smd2 = &amp;amp;smdtty_apps_riva_bt_acl;\n        smd3 = &amp;amp;smdtty_apps_riva_bt_cmd;\n        smd4 = &amp;amp;smdtty_mbalbridge;\n        smd5 = &amp;amp;smdtty_apps_riva_ant_cmd;\n        smd6 = &amp;amp;smdtty_apps_riva_ant_data;\n        smd7 = &amp;amp;smdtty_data1;\n        smd8 = &amp;amp;smdtty_data4;\n        smd11 = &amp;amp;smdtty_data11;\n        smd21 = &amp;amp;smdtty_data21;\n        smd36 = &amp;amp;smdtty_loopback;\n        sdhc1 = &amp;amp;sdhc_1; /* SDC1 eMMC slot */\n        sdhc2 = &amp;amp;sdhc_2; /* SDC2 for SD card */\n        i2c1 = &amp;amp;i2c_1;\n        i2c2 = &amp;amp;i2c_2;\n        i2c3 = &amp;amp;i2c_3;\n        i2c5 = &amp;amp;i2c_5;\n        spi3 = &amp;amp;spi_3;\n    };\n\n    soc: soc { };\n\n};\n由上面的例子看出Device Tree有一下特点：\n1.节点node\n    1.1每个node可以包含sub node和property/value；\n    1.2每个DTS都只有一个ROOT node；\n    1.3一个node可以有多个sub node，但只能有一个parent node；\n    1.4一个node可以包含多个property/value描述该node的具体信息；\n    1.5每个node用节点名字（node name）标识，节点名字的格式是node-name@unit-address。如果该node没有reg属性（后面会描述这个property），那么该节点名字中必须不能包括@和unit-address。\n2.属性/值property/value\n    2.1一般属性：\n    属性值表示了该设备节点的具体特性，它的值是多样性的：\n    1)可能为空，即没有值的定义；\n    2)可能为32bit或64bit整数值(#size-cells = &amp;lt;2&amp;gt;)或者数组(reg = &amp;lt;0x0 0x86c00000 0x0 0x5600000&amp;gt;)；\n    3）可能为string(label = &quot;cont_splash_mem&quot;)或string list(compatible = &quot;qcom,msm8953&quot;)；\n    2.2特殊属性：\n    #address-cells = &amp;lt;1&amp;gt;;\n    #size-cells = &amp;lt;0&amp;gt;;\n    #类似number，#address-cells表示子节点中reg中的地址元素需要用多少个32bit值来表示，#size-cells表示子节点中reg中的大小元素需要用多少个32bit值来表示。`&lt;/pre&gt;\n\n3.Device Tree source file语法\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.节点定义：\n    [label:] node-name[@unit-address] { \n       [properties definitions];\n       [child nodes];\n    };\n2.节点引用：\n    1)直接引用：绝对路径，/node-name-1/node-name-2/node-name-N；\n    2)别名引用：所有别名被定义在节点aliases中；\n    3)lable引用：&amp;amp;lable；\n3.属性定义：\n    property ＝ value;\n    再次注意value的三种方式：\n    1)32bit unsigned integers：#size-cells = &amp;lt;2&amp;gt;;\n    2)binary data：binary-property = [0x01 0x23 0x45 0x67];\n    3)string/string list：device_type = &quot;memory&quot;;\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/8/26 14:15:06 [原文链接](http://blog.csdn.net/weiniluo/article/details/52326801)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52326801#comments)\n        &lt;/div&gt;\n</code></pre>","excerpt":"","more":"<p>1.写在前面 </p>\n<p>本文是本人在阅读了蜗窝科技的Device Tree三篇文章后的笔记，他的这几篇文章是我最近了解到的在Device Tree方面讲的比较深入细致的，非常感谢蜗窝科技为我们提供的学习机会，如果有需要，请你们去<a href=\"http://www.wowotech.net/device_model/why-dt.html\">蜗窝科技</a>。 </p>\n<p>2.Device Tree结构</p>\n<pre><code>kernel/arch/arm/boot/dts/skeleton.dtsi:\n/ {\n    #address-cells = &amp;lt;1&amp;gt;;\n    #size-cells = &amp;lt;1&amp;gt;;\n    cpus { };\n    soc { };\n    chosen { };\n    aliases { };\n    memory { device_type = &quot;memory&quot;; reg = &amp;lt;0 0&amp;gt;; };\n};\nkernel/arch/arm/boot/dts/qcom/skeleton.dtsi:\n#include &quot;skeleton64.dtsi&quot;\n#include &amp;lt;dt-bindings/clock/msm-clocks-8953.h&amp;gt;\n#include &amp;lt;dt-bindings/regulator/qcom,rpm-smd-regulator.h&amp;gt;\n#include &amp;lt;dt-bindings/gpio/gpio.h&amp;gt;\n/ {\n    model = &quot;Qualcomm Technologies, Inc. MSM 8953&quot;;\n    compatible = &quot;qcom,msm8953&quot;;\n    qcom,msm-id = &amp;lt;293 0x0&amp;gt;;\n    interrupt-parent = &amp;lt;&amp;amp;intc&amp;gt;;\n\n    chosen {\n        bootargs = &quot;sched_enable_hmp=1 sched_enable_power_aware=1&quot;;\n    };\n\n    reserved-memory {\n        #address-cells = &amp;lt;2&amp;gt;;\n        #size-cells = &amp;lt;2&amp;gt;;\n        ranges;\n\n        other_ext_mem: other_ext_region@0 {\n            compatible = &quot;removed-dma-pool&quot;;\n            no-map;\n            reg = &amp;lt;0x0 0x83300000 0x0 0x3800000&amp;gt;;\n        };\n\n        modem_mem: modem_region@0 {\n            compatible = &quot;removed-dma-pool&quot;;\n            no-map-fixup;\n            reg = &amp;lt;0x0 0x86c00000 0x0 0x5600000&amp;gt;;\n        };\n\n        reloc_mem: reloc_region@0 {\n            compatible = &quot;removed-dma-pool&quot;;\n            no-map;\n            reg = &amp;lt;0x0 0x8c200000 0x0 0x1800000&amp;gt;;\n        };\n\n        venus_mem: venus_region@0 {\n            compatible = &quot;shared-dma-pool&quot;;\n            reusable;\n            alloc-ranges = &amp;lt;0x0 0x80000000 0x0 0x10000000&amp;gt;;\n            alignment = &amp;lt;0 0x400000&amp;gt;;\n            size = &amp;lt;0 0x0800000&amp;gt;;\n        };\n\n        secure_mem: secure_region@0 {\n            compatible = &quot;shared-dma-pool&quot;;\n            reusable;\n            alignment = &amp;lt;0 0x400000&amp;gt;;\n            size = &amp;lt;0 0x09800000&amp;gt;;\n        };\n\n        qseecom_mem: qseecom_region@0 {\n            compatible = &quot;shared-dma-pool&quot;;\n            reusable;\n            alignment = &amp;lt;0 0x400000&amp;gt;;\n            size = &amp;lt;0 0x1000000&amp;gt;;\n        };\n\n        adsp_mem: adsp_region@0 {\n            compatible = &quot;shared-dma-pool&quot;;\n            reusable;\n            size = &amp;lt;0 0x400000&amp;gt;;\n        };\n\n        dfps_data_mem: dfps_data_mem@90000000 {\n               reg = &amp;lt;0 0x90000000 0 0x1000&amp;gt;;\n               label = &quot;dfps_data_mem&quot;;\n        };\n\n        cont_splash_mem: splash_region@0x90001000 {\n            reg = &amp;lt;0x0 0x90001000 0x0 0x13ff000&amp;gt;;\n            label = &quot;cont_splash_mem&quot;;\n        };\n\n        gpu_mem: gpu_region@0 {\n            compatible = &quot;shared-dma-pool&quot;;\n            reusable;\n            alloc-ranges = &amp;lt;0x0 0x80000000 0x0 0x10000000&amp;gt;;\n            alignment = &amp;lt;0 0x400000&amp;gt;;\n            size = &amp;lt;0 0x800000&amp;gt;;\n        };\n    };\n\n    aliases {\n        /* smdtty devices */\n        smd1 = &amp;amp;smdtty_apps_fm;\n        smd2 = &amp;amp;smdtty_apps_riva_bt_acl;\n        smd3 = &amp;amp;smdtty_apps_riva_bt_cmd;\n        smd4 = &amp;amp;smdtty_mbalbridge;\n        smd5 = &amp;amp;smdtty_apps_riva_ant_cmd;\n        smd6 = &amp;amp;smdtty_apps_riva_ant_data;\n        smd7 = &amp;amp;smdtty_data1;\n        smd8 = &amp;amp;smdtty_data4;\n        smd11 = &amp;amp;smdtty_data11;\n        smd21 = &amp;amp;smdtty_data21;\n        smd36 = &amp;amp;smdtty_loopback;\n        sdhc1 = &amp;amp;sdhc_1; /* SDC1 eMMC slot */\n        sdhc2 = &amp;amp;sdhc_2; /* SDC2 for SD card */\n        i2c1 = &amp;amp;i2c_1;\n        i2c2 = &amp;amp;i2c_2;\n        i2c3 = &amp;amp;i2c_3;\n        i2c5 = &amp;amp;i2c_5;\n        spi3 = &amp;amp;spi_3;\n    };\n\n    soc: soc { };\n\n};\n由上面的例子看出Device Tree有一下特点：\n1.节点node\n    1.1每个node可以包含sub node和property/value；\n    1.2每个DTS都只有一个ROOT node；\n    1.3一个node可以有多个sub node，但只能有一个parent node；\n    1.4一个node可以包含多个property/value描述该node的具体信息；\n    1.5每个node用节点名字（node name）标识，节点名字的格式是node-name@unit-address。如果该node没有reg属性（后面会描述这个property），那么该节点名字中必须不能包括@和unit-address。\n2.属性/值property/value\n    2.1一般属性：\n    属性值表示了该设备节点的具体特性，它的值是多样性的：\n    1)可能为空，即没有值的定义；\n    2)可能为32bit或64bit整数值(#size-cells = &amp;lt;2&amp;gt;)或者数组(reg = &amp;lt;0x0 0x86c00000 0x0 0x5600000&amp;gt;)；\n    3）可能为string(label = &quot;cont_splash_mem&quot;)或string list(compatible = &quot;qcom,msm8953&quot;)；\n    2.2特殊属性：\n    #address-cells = &amp;lt;1&amp;gt;;\n    #size-cells = &amp;lt;0&amp;gt;;\n    #类似number，#address-cells表示子节点中reg中的地址元素需要用多少个32bit值来表示，#size-cells表示子节点中reg中的大小元素需要用多少个32bit值来表示。`&lt;/pre&gt;\n\n3.Device Tree source file语法\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.节点定义：\n    [label:] node-name[@unit-address] { \n       [properties definitions];\n       [child nodes];\n    };\n2.节点引用：\n    1)直接引用：绝对路径，/node-name-1/node-name-2/node-name-N；\n    2)别名引用：所有别名被定义在节点aliases中；\n    3)lable引用：&amp;amp;lable；\n3.属性定义：\n    property ＝ value;\n    再次注意value的三种方式：\n    1)32bit unsigned integers：#size-cells = &amp;lt;2&amp;gt;;\n    2)binary data：binary-property = [0x01 0x23 0x45 0x67];\n    3)string/string list：device_type = &quot;memory&quot;;\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/8/26 14:15:06 [原文链接](http://blog.csdn.net/weiniluo/article/details/52326801)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52326801#comments)\n        &lt;/div&gt;\n</code></pre>"},{"title":"[原]I2C协议","date":"2016-09-18T13:49:16.000Z","_content":"\n### 1.协议\n\n    1.空闲状态：\n        SCL=H&amp;&amp;SDA=H\n    2.起始位和停止位:\n        start bit:\n            SCL=H&amp;&amp;SDA↓\n        stop bit:\n            SCL=H&amp;&amp;SDA↑\n    3.ACK\n        发送器每发送完一个字节，就在第9个CLK释放数据线，由接收器反馈一个应答信号。 应答信号为低电平时，规定为有效应答位（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。\n\n    4.数据有效性\n        I2C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。 \n\n    5.主从设备\n        系统中的所有外围器件都具有一个7位的\"从器件专用地址码\"，其中高4位为器件类型，由生产厂家制定，低3位为器件引脚定义地址，由使用者定义。所以同一厂家的同一器件最多只能在同一个I2C总线上挂在8片。\n    `</pre>\n\n    ### 2.读写流程\n\n    #### 2.1写流程\n\n    <pre class=\"prettyprint\">`1.start bit\n    2.send slave address+write bit\n    3.check ack\n    4.send reg address\n    5.check ack\n    6.send data\n    7.check ack\n    8.stop bit`</pre>\n\n    #### 2.2读流程\n\n    <pre class=\"prettyprint\">`1.start bit\n    2.send slave address+write bit\n    3.check ack\n    4.send reg address\n    5.check ack\n    6.start bit\n    7.send slave address+read bit\n    8.check ack\n    9.read data\n    10.stop bit\n\n            <div>\n                作者：WEINILUO 发表于2016/9/18 9:49:16 [原文链接](http://blog.csdn.net/weiniluo/article/details/51790017)\n            </div>\n            <div>\n            阅读：86 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51790017#comments)\n            </div>\n","source":"_posts/原-I2C协议.md","raw":"---\ntitle: '[原]I2C协议'\ntags: []\ndate: 2016-09-18 09:49:16\n---\n\n### 1.协议\n\n    1.空闲状态：\n        SCL=H&amp;&amp;SDA=H\n    2.起始位和停止位:\n        start bit:\n            SCL=H&amp;&amp;SDA↓\n        stop bit:\n            SCL=H&amp;&amp;SDA↑\n    3.ACK\n        发送器每发送完一个字节，就在第9个CLK释放数据线，由接收器反馈一个应答信号。 应答信号为低电平时，规定为有效应答位（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。\n\n    4.数据有效性\n        I2C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。 \n\n    5.主从设备\n        系统中的所有外围器件都具有一个7位的\"从器件专用地址码\"，其中高4位为器件类型，由生产厂家制定，低3位为器件引脚定义地址，由使用者定义。所以同一厂家的同一器件最多只能在同一个I2C总线上挂在8片。\n    `</pre>\n\n    ### 2.读写流程\n\n    #### 2.1写流程\n\n    <pre class=\"prettyprint\">`1.start bit\n    2.send slave address+write bit\n    3.check ack\n    4.send reg address\n    5.check ack\n    6.send data\n    7.check ack\n    8.stop bit`</pre>\n\n    #### 2.2读流程\n\n    <pre class=\"prettyprint\">`1.start bit\n    2.send slave address+write bit\n    3.check ack\n    4.send reg address\n    5.check ack\n    6.start bit\n    7.send slave address+read bit\n    8.check ack\n    9.read data\n    10.stop bit\n\n            <div>\n                作者：WEINILUO 发表于2016/9/18 9:49:16 [原文链接](http://blog.csdn.net/weiniluo/article/details/51790017)\n            </div>\n            <div>\n            阅读：86 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51790017#comments)\n            </div>\n","slug":"原-I2C协议","published":1,"updated":"2016-10-20T09:58:52.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnobr0001vzs67a7ozxta","content":"<h3 id=\"1-协议\"><a href=\"#1-协议\" class=\"headerlink\" title=\"1.协议\"></a>1.协议</h3><pre><code>1.空闲状态：\n    SCL=H&amp;amp;&amp;amp;SDA=H\n2.起始位和停止位:\n    start bit:\n        SCL=H&amp;amp;&amp;amp;SDA↓\n    stop bit:\n        SCL=H&amp;amp;&amp;amp;SDA↑\n3.ACK\n    发送器每发送完一个字节，就在第9个CLK释放数据线，由接收器反馈一个应答信号。 应答信号为低电平时，规定为有效应答位（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。\n\n4.数据有效性\n    I2C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。 \n\n5.主从设备\n    系统中的所有外围器件都具有一个7位的&quot;从器件专用地址码&quot;，其中高4位为器件类型，由生产厂家制定，低3位为器件引脚定义地址，由使用者定义。所以同一厂家的同一器件最多只能在同一个I2C总线上挂在8片。\n`&lt;/pre&gt;\n\n### 2.读写流程\n\n#### 2.1写流程\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.start bit\n2.send slave address+write bit\n3.check ack\n4.send reg address\n5.check ack\n6.send data\n7.check ack\n8.stop bit`&lt;/pre&gt;\n\n#### 2.2读流程\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.start bit\n2.send slave address+write bit\n3.check ack\n4.send reg address\n5.check ack\n6.start bit\n7.send slave address+read bit\n8.check ack\n9.read data\n10.stop bit\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/9/18 9:49:16 [原文链接](http://blog.csdn.net/weiniluo/article/details/51790017)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：86 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51790017#comments)\n        &lt;/div&gt;\n</code></pre>","excerpt":"","more":"<h3 id=\"1-协议\"><a href=\"#1-协议\" class=\"headerlink\" title=\"1.协议\"></a>1.协议</h3><pre><code>1.空闲状态：\n    SCL=H&amp;amp;&amp;amp;SDA=H\n2.起始位和停止位:\n    start bit:\n        SCL=H&amp;amp;&amp;amp;SDA↓\n    stop bit:\n        SCL=H&amp;amp;&amp;amp;SDA↑\n3.ACK\n    发送器每发送完一个字节，就在第9个CLK释放数据线，由接收器反馈一个应答信号。 应答信号为低电平时，规定为有效应答位（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。\n\n4.数据有效性\n    I2C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。 \n\n5.主从设备\n    系统中的所有外围器件都具有一个7位的&quot;从器件专用地址码&quot;，其中高4位为器件类型，由生产厂家制定，低3位为器件引脚定义地址，由使用者定义。所以同一厂家的同一器件最多只能在同一个I2C总线上挂在8片。\n`&lt;/pre&gt;\n\n### 2.读写流程\n\n#### 2.1写流程\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.start bit\n2.send slave address+write bit\n3.check ack\n4.send reg address\n5.check ack\n6.send data\n7.check ack\n8.stop bit`&lt;/pre&gt;\n\n#### 2.2读流程\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.start bit\n2.send slave address+write bit\n3.check ack\n4.send reg address\n5.check ack\n6.start bit\n7.send slave address+read bit\n8.check ack\n9.read data\n10.stop bit\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/9/18 9:49:16 [原文链接](http://blog.csdn.net/weiniluo/article/details/51790017)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：86 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51790017#comments)\n        &lt;/div&gt;\n</code></pre>"},{"title":"[原]Makfile笔记","date":"2016-04-23T22:56:25.000Z","_content":"\n# 1.Makfile初识\n\n## 1.1Makefile规则\n\n    target ... : prerequisites ...\n        command\n        ...\n        ...\n    注：  \n    target:目标\n    prerequisites:依赖文件\n    command:makefile 需要执行的命令\n\n    Makfile规则：\n        在执行Makfile时，Makfile会判断target文件是否存在，\n        若不存在，则执行下面的command命令，\n        若存在，则判断prerequisites的时间戳是否比target的时间戳要新，\n        若是，则也执行下面的command命令。`</pre>\n\n    ## 1.2引用其他Makefile文件\n\n    <pre class=\"prettyprint\">`使用方式：\n    include &lt;filename&gt;\n    例：\n    include foo.make $(value) `</pre>\n\n    ## 1.3Makefile变量\n\n    <pre class=\"prettyprint\">`1.\n    使用方式：\n    obj= a.o b.o c.o \\\n        d.o e.o\n    target : prerequisites\n        command $(obj)\n    2.CFLAGS,CXXFLAGS \n        CFLAGS 表示用于 C 编译器的选项，CXXFLAGS表示用于 C++ 编译器的选项。\n        CFLAGS指定头文件（.h文件）的路径、编译条件宏，如：CFLAGS=-I/usr/include -I/path/include -D_YUQIANG。\n        上面两个变量用于gcc的参数中：$(CC) $(CFLAGS)\n    3.LDFLAGS：\n        gcc 等编译器会用到的一些优化参数，也可以在里面指定库文件的位置。用法：\n        LDFLAGS=-L/usr/lib -L/path/to/your/lib。\n    4.LIBS：告诉链接器要链接哪些库文件，如LIBS = -lpthread -liconv\n    `</pre>\n\n    ## 1.4Makefile工作流程\n\n    <pre class=\"prettyprint\">`1.在敲入make之后，make会在当前目录下寻找Makefile类型文件\n    2.读入被include包含的makefile文件\n    3.替换变量\n    4.推到并分析所有规则\n    5.位所有的目标创建依赖关系链\n    6.找到文件中的第一个target作为最终的目标文件\n    7.找到target后按照规则执行，若target的依赖文件也存在依赖文件，则同样按照规则递归执行，直到生成最终的目标文件后make执行完成`</pre>\n\n    # 2.书写规则\n\n    ## 2.1规则语法\n\n    <pre class=\"prettyprint\">`方式1：\n    targets : prereuuisites\n        command\n        ...\n    方式2：\n    targets : prereuuisites ; command\n        command\n        ...\n    注意：\n    1，若command为独立行，则需以&lt;TAB&gt;开头\n    2.换行符：'\\'\n    3.command默认使用/bash/sh来执行`</pre>\n\n    ## 2.2通配符\n\n    <pre class=\"prettyprint\">`'*':代表『 0 个到无穷多个』任意字符\n    '?':代表『一定有一个』任意字符\n    '~':代表用户的主目录，~feison/data代表用户feison主目录下的data目录\n    注：若需要使用这些特定字符，在该字符前加转义字符'\\'`</pre>\n\n    ## 2.3文件搜索路径\n\n    <pre class=\"prettyprint\">`1.VPATH变量\n    VPATH:makefile中设定默认搜索文件路径的变量\n    例：VPATH= src:../headers\n    注：设置多个路径用冒号分隔\n    2.vpath关键字\n    vpath &lt;pattern&gt; &lt;directories&gt; :为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;\n    vpath &lt;pattern&gt; :清除符合模式&lt;pattern&gt;的文件的搜索目录\n    vpath :清除所有已设置好的文件搜索目录\n    例：vpath %h ../headers`</pre>\n\n    ## 2.4伪目标\n\n    <pre class=\"prettyprint\">`伪目标声明方式：\n    隐式声明：\n    phonytargets:\n        commands\n    显式声明：\n    .PHONY:phonytargets\n    phonytargets:\n        commands\n    例：生成多个可执行文件\n    all:prog1 prog2 prog3\n    .PHONY: all\n\n    prog1:prog1.o\n        commands1\n    prog2:prog2.o\n        commands2\n    prog3:prog3.o\n        commands3`</pre>\n\n    ## 2.5静态模式\n\n    <pre class=\"prettyprint\">`规则：\n    &lt;targets&gt;:&lt;target-pattern&gt;:&lt;prereq-pattern&gt;\n        &lt;commands&gt;\n        ...\n    注：\n    targets：目标集，多个目标文件\n    target-pattern：目标集模式\n    prereq-pattern：依赖模式\n    例：\n    foo.o bar.o abc.m : %.o : %.c\n        $(CC) -c $(CFLAGS) $&lt; -o $@\n    上述的.o文件的依赖文件为.c文件，当不满足makefile原则时，执行下面的命令`</pre>\n\n    # 3.书写命令\n\n    ## 3.1显示命令\n\n    <pre class=\"prettyprint\">`1.@command和command比较\n        @command 该命令不会被make显示\n        command 该命令会被make显示\n    例：\n        @echo this is a test\n        make输出：\n        this is a test\n\n        echo this is a test\n        make输出：\n        echo this is a test\n        this is a test\n    2.make -n 只显示命令，但不执行命令\n    3.make -s 全面禁止命令的显示`</pre>\n\n    ## 3.2嵌套执行make\n\n    <pre class=\"prettyprint\">`make嵌套，亦是make包含，以利于模块编译和分段编译\n    例：\n    ./Makefile:(总控Makefile)\n    subsystem:\n        cd subdir &amp;&amp; $(MAKE)\n    &lt;==&gt;\n    sybsystem:\n        $(MAKE) -C subdir\n    1.makefile中的变量传递\n    默认情况下，上级的Makefile中的变量可以传递到下级makefile中，但不会覆盖下级makefile中的变量，除非制定了-e参数。\n    export &lt;variable ...&gt; 声明要传递到下级makefile的变量\n    unport &lt;variable ...&gt; 声明不能传递到下级makefile的变量\n    注：\n    SHELL和MAKEFLAGS两个变量始终会被传递到下级makefile中\n    2.make -w\n    当make进入和离开下级目录时，输出相应的目录变化信息`</pre>\n\n    ## 3.3定义命令块\n\n    <pre class=\"prettyprint\">`规则：\n    define cmdblocks-name\n    cmd1\n    cmd2\n    ...\n    endef\n    例：\n    target : prereqs\n        $(cmdblocks-name)`</pre>\n\n    # 4.变量\n\n    ## 4.1变量声明\n\n    <pre class=\"prettyprint\">`1.常规变量\n    variable = value\n    $(variable)==&gt;value\n    ${variable}==&gt;value\n    2.变量中的变量\n    variable ：=value\n    1中的声明方式会出现无限的变量展开中，如下\n    A=$(B)\n    B=$(A)\n    :=的声明方式规定前面的变量不能使用后面的变量,若使用的变量前面未被定义，则其值为空\n    例：\n    x:=foo\n    y:=$(x) bar $(m)\n    x:=later\n    ==&gt;\n    y:=foo bar\n    x:=later\n    3.定义一个其值为空格的变量\n    nullstring:=\n    space:=$(nullstring) #end of the line\n    注：nullstring为Empty变量，space表示一个空格，Empty变量表示一个变量的值开始了，#表示变量的定义终止\n    4.操作符?=\n    variable ?=value\n    表示若variable之前被定义过，则该语句无效，若没有被定义过，其值为value`</pre>\n\n    ## 4.2变量使用\n\n    <pre class=\"prettyprint\">`1.多重变量\n    x=y\n    y=z\n    a:=$($(x))\n    ==&gt;\n    a:=z\n\n    2.变量值的替换\n    $(var:a=b)\n    ${var:a=b}\n    表示把变量var中所有以a字符串结尾的a替换为b字符串\n    例：\n    foo := a.o b.o c.o\n    bar :=$(foo:.o=.c)\n\n    foo := a.o b.o c.o\n    bar :=$(foo:%.o=%.c)\n\n    3.追加变量\n    variable +=value\n    例：\n    a := b\n    a +=c\n    ==&gt;\n    a := b\n    a :=$(a) b\n\n    4.其他\n    例：\n    first_second = Hello\n    a = first\n    b = second\n    c =$($(a)_$(b))\n    ==&gt;\n    c = Hello`</pre>\n\n    ## 4.3override标识符\n\n    <pre class=\"prettyprint\">`通过make的命令行参数设置的变量，通常在makefile中对这些变量赋值是无效的，但可以通过override标识符重新设置这些变量的值。\n    1.\n    override &lt;variable&gt;; =&lt;value&gt;\n    2.\n    override &lt;variable&gt;; :=&lt;value&gt;\n    3.\n    override &lt;variable&gt;; +=&lt;value&gt;\n    4.\n    override define foo\n    bar\n    endef\n    `</pre>\n\n    ## 4.4多行变量\n\n    <pre class=\"prettyprint\">`声明方式：\n    define two-lines\n    echo foo\n    echo $(bar)\n    endef\n    注：参见3.3定义命令块`</pre>\n\n    ## 4.5环境变量\n\n    <pre class=\"prettyprint\">`参见3.2嵌套执行make`</pre>\n\n    ## 4.6目标变量\n\n    <pre class=\"prettyprint\">`目标变量表示为某个特定的目标设定的变量，该变量的值只适用于特殊目标\n    声明：\n    &lt;target ...&gt;:&lt;variable-assignment&gt;\n    &lt;target ...&gt;:override &lt;variable-assignment&gt;\n    注：\n    &lt;variable-assignment&gt;表示常规赋值表达式\n    第二个声明适用于make命令带入的变量或环境变量\n    例：\n    m = flag\n    target：m= flag_target\n    target:\n        @echo $(m)\n    则$(m)的值为flage_target`</pre>\n\n    ## 4.7模式变量\n\n    <pre class=\"prettyprint\">`声明：\n    &lt;pattern ...&gt;:&lt;variable-assignment&gt;\n    &lt;pattern ...&gt;:override &lt;variable-assignment&gt;\n    使用方式同目标变量\n    例：\n    %.o : CFLAGS = -g\n    prog: prog1.o prog2.o\n        $(CC) $(CFLAGS ) prog1.o prog2.o\n    prog1.o:prog1.c\n        $(CC) $(CFLAGS ) prog1.c\n    prog2.o:prog2.c\n        $(CC) $(CFLAGS ) prog2.c\n    以上只有prog1.o和prog2.o下的命令中的CFLAGS的值为-O，其余为系统变量的值`</pre>\n\n    ## 4.8自动化变量\n\n    <pre class=\"prettyprint\">`在模式规则中（将在&lt;隐含规则&gt;一节中讲解），规则的目标和依赖文件名代表了一类文件名。命令是对所有这一类文件重建过程的描述，显然，在命令中不能指定特定的文件名，否则模式规则将没有了意义。那么在模式规则的命令行中该如何表示文件，将成我们这一小节的讨论重点。make中使用了“自动环变量”来实现这个目的，自动化变量的取值是根据具体的规则决定的，就是说对不同的规则其所代表的文件名不同。\n    前边我们也看到了很多例子中使用到了自动化变量。下面对所有的自动化变量进行说明：\n    $@\n    代表规则中的目标文件名。如果目标是一个文档（Linux中，一般称.a文件为文档），那么它代表这个文档的文件名。在多目标的模式规则中，它代表的是哪个触发规则被执行的目标文件名。\n    $%\n    规则的目标文件是一个静态库文件时，代表静态库的一个成员名。例如，规则的目标是“foo.a(bar.o)”，那么，“$%”的值就为“bar.o”，“$@”的值为“foo.a”。如果目标不是函数库文件，其值为空。\n    $&lt;\n    规则的第一个依赖文件名。如果是隐含规则，则它代表通过目标指定的第一个依赖文件。\n    $?\n    所有比目标文件更新的依赖文件列表，空格分割。如果目标是静态库文件名，代表的是库成员（.o文件）的更新情况。\n    $^\n    规则的所有依赖文件列表，使用空格分隔。如果目标是静态库文件名，它所代表的只能是所有库成员（.o文件）名。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的一次引用情况。就是说变量“$^”会去掉重复的依赖文件。\n    $+\n    类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时，库的交叉引用场合。\n    $*\n    在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时，“茎”也包含目录（斜杠之前）部分）。例如：文件“dir/a.foo.b”，当目标的模式为“a.%.b”时，“$*”的值为“dir/a.foo”。“茎”对于构造相关文件名非常有用。\n    自动化变量“$*”需要两点说明：\n    Ø        对于一个明确指定的规则来说不存在“茎”，这种情况下“$*”所代表的值发生变化。此时，如果目标文件名带有一个可识别的后缀，那么“$*”表示文件中除后缀以外的部分。例如：“foo.c”则“$*”的值为：“foo”，因为.c是一个可识别的文件后缀名。GUN make对明确规则的这种奇怪的处理行为是为了和其它版本的make兼容。通常，在除静态规则和模式规则以外，明确指定目标文件的规则中避免使用这个变量。\n    Ø        当明确指定文件名的规则中目标文件名包含不可识别的后缀时，此变量为空。\n    自动化变量“$?”在显式规则中也是非常有用的，规则中可以使用它来指定只对更新的依赖文件进行操作。例如，函数库文件“libN.a”，它由一些.o文件组成。如下的规则实现了根据变化的.o文件更新库文件：\n\n    lib: foo.o bar.o lose.o win.o\n        ar r lib $?\n\n    上述列出的自动量变量中。其中有四个在规则中代表一个文件名（$@、$&lt;、$%、$*）。而其它三个的在规则中代表一个文件名的列表。GUN make中，还可以通过这七个自动化变量来获取一个完整文件名中的目录部分或者具体文件名，需要在这些变量中加入“D”或者“F”字符。这样就形成了一系列变种的自动环变量。这些变量在以前版本的make中使用，在当前版本的make中，可以使用“dir”或者“notdir”函数来实现同样的功能。\n    $(@D)\n    代表目标文件的目录部分（去掉目录部分的最后一个斜杠）。如果“$@”是“dir/foo.o”，那么“$(@D)”的值为“dir”。如果“$@”不存在斜杠，其值就是“.”（当前目录）。注意它和函数“dir”的区别！\n    $(@F)\n    目标文件的完整文件名中除目录以外的部分（实际文件名）。如果“$@”为“dir/foo.o”，那么“$(@F)”只就是“foo.o”。“$(@F)”等价于函数“$(notdir $@)”。\n    $(*D)\n    $(*F)\n    分别代表目标“茎”中的目录部分和文件名部分。\n    $(%D)\n    $(%F)\n    当以如“archive(member)”形式静态库为目标时，分别表示库文件成员“member”名中的目录部分和文件名部分。它仅对这种形式的规则目标有效。\n    $(&lt;D)\n    $(&lt;F)\n    分别表示规则中第一个依赖文件的目录部分和文件名部分。\n    $(^D)\n    $(^F)\n    分别表示所有依赖文件的目录部分和文件部分（不存在同一文件）。\n    $(+D)\n    $(+F)\n    分别表示所有依赖文件的目录部分和文件部分（可存在重复文件）。\n    $(?D)\n    $(?F)\n    分别表示被更新的依赖文件的目录部分和文件部分。`</pre>\n\n    # 5.逻辑判断语句\n\n    ## 5.1使用语法\n\n    <pre class=\"prettyprint\">`1.ifeq/else/endif\n        &lt;1&gt;\n        ifeq (&lt;arg1&gt;,&lt;arg2&gt;)\n        &lt;text-ifeq&gt;\n        else\n        &lt;text-else&gt;\n        endif\n\n        &lt;2&gt;\n        ifeq (&lt;arg1&gt;,&lt;arg2&gt;)\n        &lt;text-ifeq&gt;\n        endif\n\n    2.ifneq/else/endif\n        &lt;1&gt;\n        ifneq (&lt;arg1&gt;,&lt;arg2&gt;)\n        &lt;text-ifneq&gt;\n        else\n        &lt;text-else&gt;\n        endif\n\n        &lt;2&gt;\n        ifneq (&lt;arg1&gt;,&lt;arg2&gt;)\n            &lt;text-ifneq&gt;\n        endif\n\n    3.ifdef/else/endif\n        &lt;1&gt;\n        ifdef &lt;variable-name&gt;\n        &lt;text-ifdef&gt;\n        else\n        &lt;text-else&gt;\n        endif\n\n        &lt;2&gt;\n        ifdef &lt;variable-name&gt;\n        &lt;text-ifdef&gt;\n        endif\n\n    4.if &lt;condition&gt;, &lt;then-part&gt;, &lt;else-part&gt;\n        相当于C语言中:\n        if(condition)\n            then-part;\n        else\n            else-part;`</pre>\n\n    # 6.常用函数\n\n    ## 6.1函数调用语法\n\n    <pre class=\"prettyprint\">`语法：\n    $(&lt;function&gt; &lt;arguments&gt;)\n    ${&lt;function&gt; &lt;arguments&gt;}`</pre>\n\n    ## 6.2字符串处理函数\n\n    <pre class=\"prettyprint\">`1.subst\n    字符串替换函数\n    $(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)\n    例：\n    $(subst ee,EE,feet on the street)\n    ==&gt;fEEt on the strEEt\n\n    2.patsubst\n    模式字符串替换函数\n    $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)\n\n    3.strip\n    去空格函数，去掉字符串开头和结尾的空格\n    $(strip &lt;string&gt;)\n\n    4.findstring\n    查找字符串函数\n    $(findstring &lt;findstr&gt;,&lt;string&gt;)\n\n    5.filter\n    过滤函数\n    $(filter &lt;pattern...&gt;,&lt;text&gt;)\n\n    6.filter-out\n    反过滤函数\n    $(filter-out &lt;pattern...&gt;,&lt;text&gt;)\n\n    7.sort\n    排序函数\n    $(sort &lt;list&gt;)\n\n    8.word\n    取单词函数\n    $(word &lt;n&gt;,&lt;text&gt;)\n\n    9.wordlist\n    取单词串函数，得到从&lt;s_num&gt;到&lt;e_num&gt;的单词串\n    $(wordlist &lt;s_num&gt;,&lt;e_num&gt;,&lt;text&gt;)\n\n    10.words\n    单词数统计函数\n    $(words &lt;string&gt;)\n\n    11.firstword\n    取首单词函数\n    $(firstword &lt;string&gt;)\n    `</pre>\n\n    ## 6.3文件名操作函数\n\n    <pre class=\"prettyprint\">`1.dir\n    取目录函数\n    $(dir &lt;path_files_name&gt;)\n\n    2.notdir\n    取文件名函数\n    $(nodir &lt;path_files_name&gt;)\n\n    3.suffix\n    取后缀函数\n    $(suffix &lt;names&gt;)\n\n    4.basename\n    取前缀函数\n    $(basename &lt;names&gt;)\n\n    5.addsuffix\n    添加后缀函数\n    $(addsuffix &lt;suffix&gt;,&lt;names&gt;)\n\n    6.addprefix\n    添加前缀函数\n    $(addprefix  &lt;prefix&gt;,&lt;names&gt;)\n\n    7.join\n    连接函数\n    $(join &lt;list1&gt;,&lt;list2&gt;)\n    `</pre>\n\n    ## 6.4makefile调试函数\n\n    <pre class=\"prettyprint\">`1.error\n    产生一个致命错误\n    $(error &lt;text&gt;)\n\n    2.warning\n    生成一个警告信息\n    $(warning &lt;text&gt;)\n\n    3.info\n    生成一个普通信息\n    $(info &lt;text&gt;)`</pre>\n\n    ## 6.5其他函数\n\n    <pre class=\"prettyprint\">`1.foreach\n    循环函数\n    $(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)\n\n    2.if\n    条件判断函数\n    $(if &lt;condition&gt;,&lt;then-part&gt;)\n    $(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)\n\n    3.call\n    调用函数的函数\n    $(call &lt;func&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;,...)\n    注：\n    func：自定义函数\n    parm1：func中的参数1（$(1)）\n    parm2: func中的参数2（$(2)）\n    func中的所有参数变量均用,$(1),$(2)...表示\n    例：\n    reverse = $(2) $(1)\n    foo=$(call reverse ,a,b)\n    ==&gt;\n    foo=b a\n\n    4.origin\n    变量源函数，输出变量来源\n    源列表：\n    &lt;1&gt;undefined:未定义变量\n    &lt;2&gt;default:默认定义\n    &lt;3&gt;environment:环境变量\n    &lt;4&gt;file:makefile中定义的变量\n    &lt;5&gt;command line:命令行定义的变量\n    &lt;6&gt;override:override重新定义的变量\n    &lt;7&gt;automatic:自动化变量\n    $(origin &lt;variable&gt;)\n\n    5.shell\n    调用外部shell命令函数\n    $(shell commands)\n    例：\n    fileslist：=$(shell echo *.c)\n    `</pre>\n\n    # 7.Makefile调试功能\n\n    ## 7.1makefile调试\n\n    <pre class=\"prettyprint\"></pre>\n\n    ## 7.2makefile 源码调试\n\n    <pre class=\"prettyprint\">`一般方式是通过makefile向源码增加宏定义\n    main.c:\n    #ifdef DEBUG\n    .....\n    Makefile:\n    .PHONY: all clean\n\n    LINUX_ROOT=$(LINUX_SRC)\n\n    obj-m := sil9024.o\n\n    all:\n        @make -C $(LINUX_ROOT) M=$(PWD) modules \"CFLAGS += -DDEBUG\"\n        @cp sil9024.ko ../ko/  -vfr\n\n    clean:\n        @make -C $(LINUX_ROOT) M=$(PWD) clean`</pre>\n\n    # 8.隐含规则\n\n    <pre class=\"prettyprint\">`这里写代码片\n\n# 9.写在后面\n\n非常感谢皓哥的《跟我一起写Makefile》，之前看过一点，不过没有机会全部了解，这次基本全部了解过，这是我的一点读书笔记，主要参考的就是皓哥的这本书（姑且算书吧^-^），目的为分析安卓源码中的makefile打基础，所以研究不是很深入，以后有时间再深入了解。\n\n            <div>\n                作者：WEINILUO 发表于2016/4/23 18:56:25 [原文链接](http://blog.csdn.net/weiniluo/article/details/51136429)\n            </div>\n            <div>\n            阅读：55 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51136429#comments)\n            </div>\n","source":"_posts/原-Makfile笔记.md","raw":"---\ntitle: '[原]Makfile笔记'\ntags: []\ndate: 2016-04-23 18:56:25\n---\n\n# 1.Makfile初识\n\n## 1.1Makefile规则\n\n    target ... : prerequisites ...\n        command\n        ...\n        ...\n    注：  \n    target:目标\n    prerequisites:依赖文件\n    command:makefile 需要执行的命令\n\n    Makfile规则：\n        在执行Makfile时，Makfile会判断target文件是否存在，\n        若不存在，则执行下面的command命令，\n        若存在，则判断prerequisites的时间戳是否比target的时间戳要新，\n        若是，则也执行下面的command命令。`</pre>\n\n    ## 1.2引用其他Makefile文件\n\n    <pre class=\"prettyprint\">`使用方式：\n    include &lt;filename&gt;\n    例：\n    include foo.make $(value) `</pre>\n\n    ## 1.3Makefile变量\n\n    <pre class=\"prettyprint\">`1.\n    使用方式：\n    obj= a.o b.o c.o \\\n        d.o e.o\n    target : prerequisites\n        command $(obj)\n    2.CFLAGS,CXXFLAGS \n        CFLAGS 表示用于 C 编译器的选项，CXXFLAGS表示用于 C++ 编译器的选项。\n        CFLAGS指定头文件（.h文件）的路径、编译条件宏，如：CFLAGS=-I/usr/include -I/path/include -D_YUQIANG。\n        上面两个变量用于gcc的参数中：$(CC) $(CFLAGS)\n    3.LDFLAGS：\n        gcc 等编译器会用到的一些优化参数，也可以在里面指定库文件的位置。用法：\n        LDFLAGS=-L/usr/lib -L/path/to/your/lib。\n    4.LIBS：告诉链接器要链接哪些库文件，如LIBS = -lpthread -liconv\n    `</pre>\n\n    ## 1.4Makefile工作流程\n\n    <pre class=\"prettyprint\">`1.在敲入make之后，make会在当前目录下寻找Makefile类型文件\n    2.读入被include包含的makefile文件\n    3.替换变量\n    4.推到并分析所有规则\n    5.位所有的目标创建依赖关系链\n    6.找到文件中的第一个target作为最终的目标文件\n    7.找到target后按照规则执行，若target的依赖文件也存在依赖文件，则同样按照规则递归执行，直到生成最终的目标文件后make执行完成`</pre>\n\n    # 2.书写规则\n\n    ## 2.1规则语法\n\n    <pre class=\"prettyprint\">`方式1：\n    targets : prereuuisites\n        command\n        ...\n    方式2：\n    targets : prereuuisites ; command\n        command\n        ...\n    注意：\n    1，若command为独立行，则需以&lt;TAB&gt;开头\n    2.换行符：'\\'\n    3.command默认使用/bash/sh来执行`</pre>\n\n    ## 2.2通配符\n\n    <pre class=\"prettyprint\">`'*':代表『 0 个到无穷多个』任意字符\n    '?':代表『一定有一个』任意字符\n    '~':代表用户的主目录，~feison/data代表用户feison主目录下的data目录\n    注：若需要使用这些特定字符，在该字符前加转义字符'\\'`</pre>\n\n    ## 2.3文件搜索路径\n\n    <pre class=\"prettyprint\">`1.VPATH变量\n    VPATH:makefile中设定默认搜索文件路径的变量\n    例：VPATH= src:../headers\n    注：设置多个路径用冒号分隔\n    2.vpath关键字\n    vpath &lt;pattern&gt; &lt;directories&gt; :为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;\n    vpath &lt;pattern&gt; :清除符合模式&lt;pattern&gt;的文件的搜索目录\n    vpath :清除所有已设置好的文件搜索目录\n    例：vpath %h ../headers`</pre>\n\n    ## 2.4伪目标\n\n    <pre class=\"prettyprint\">`伪目标声明方式：\n    隐式声明：\n    phonytargets:\n        commands\n    显式声明：\n    .PHONY:phonytargets\n    phonytargets:\n        commands\n    例：生成多个可执行文件\n    all:prog1 prog2 prog3\n    .PHONY: all\n\n    prog1:prog1.o\n        commands1\n    prog2:prog2.o\n        commands2\n    prog3:prog3.o\n        commands3`</pre>\n\n    ## 2.5静态模式\n\n    <pre class=\"prettyprint\">`规则：\n    &lt;targets&gt;:&lt;target-pattern&gt;:&lt;prereq-pattern&gt;\n        &lt;commands&gt;\n        ...\n    注：\n    targets：目标集，多个目标文件\n    target-pattern：目标集模式\n    prereq-pattern：依赖模式\n    例：\n    foo.o bar.o abc.m : %.o : %.c\n        $(CC) -c $(CFLAGS) $&lt; -o $@\n    上述的.o文件的依赖文件为.c文件，当不满足makefile原则时，执行下面的命令`</pre>\n\n    # 3.书写命令\n\n    ## 3.1显示命令\n\n    <pre class=\"prettyprint\">`1.@command和command比较\n        @command 该命令不会被make显示\n        command 该命令会被make显示\n    例：\n        @echo this is a test\n        make输出：\n        this is a test\n\n        echo this is a test\n        make输出：\n        echo this is a test\n        this is a test\n    2.make -n 只显示命令，但不执行命令\n    3.make -s 全面禁止命令的显示`</pre>\n\n    ## 3.2嵌套执行make\n\n    <pre class=\"prettyprint\">`make嵌套，亦是make包含，以利于模块编译和分段编译\n    例：\n    ./Makefile:(总控Makefile)\n    subsystem:\n        cd subdir &amp;&amp; $(MAKE)\n    &lt;==&gt;\n    sybsystem:\n        $(MAKE) -C subdir\n    1.makefile中的变量传递\n    默认情况下，上级的Makefile中的变量可以传递到下级makefile中，但不会覆盖下级makefile中的变量，除非制定了-e参数。\n    export &lt;variable ...&gt; 声明要传递到下级makefile的变量\n    unport &lt;variable ...&gt; 声明不能传递到下级makefile的变量\n    注：\n    SHELL和MAKEFLAGS两个变量始终会被传递到下级makefile中\n    2.make -w\n    当make进入和离开下级目录时，输出相应的目录变化信息`</pre>\n\n    ## 3.3定义命令块\n\n    <pre class=\"prettyprint\">`规则：\n    define cmdblocks-name\n    cmd1\n    cmd2\n    ...\n    endef\n    例：\n    target : prereqs\n        $(cmdblocks-name)`</pre>\n\n    # 4.变量\n\n    ## 4.1变量声明\n\n    <pre class=\"prettyprint\">`1.常规变量\n    variable = value\n    $(variable)==&gt;value\n    ${variable}==&gt;value\n    2.变量中的变量\n    variable ：=value\n    1中的声明方式会出现无限的变量展开中，如下\n    A=$(B)\n    B=$(A)\n    :=的声明方式规定前面的变量不能使用后面的变量,若使用的变量前面未被定义，则其值为空\n    例：\n    x:=foo\n    y:=$(x) bar $(m)\n    x:=later\n    ==&gt;\n    y:=foo bar\n    x:=later\n    3.定义一个其值为空格的变量\n    nullstring:=\n    space:=$(nullstring) #end of the line\n    注：nullstring为Empty变量，space表示一个空格，Empty变量表示一个变量的值开始了，#表示变量的定义终止\n    4.操作符?=\n    variable ?=value\n    表示若variable之前被定义过，则该语句无效，若没有被定义过，其值为value`</pre>\n\n    ## 4.2变量使用\n\n    <pre class=\"prettyprint\">`1.多重变量\n    x=y\n    y=z\n    a:=$($(x))\n    ==&gt;\n    a:=z\n\n    2.变量值的替换\n    $(var:a=b)\n    ${var:a=b}\n    表示把变量var中所有以a字符串结尾的a替换为b字符串\n    例：\n    foo := a.o b.o c.o\n    bar :=$(foo:.o=.c)\n\n    foo := a.o b.o c.o\n    bar :=$(foo:%.o=%.c)\n\n    3.追加变量\n    variable +=value\n    例：\n    a := b\n    a +=c\n    ==&gt;\n    a := b\n    a :=$(a) b\n\n    4.其他\n    例：\n    first_second = Hello\n    a = first\n    b = second\n    c =$($(a)_$(b))\n    ==&gt;\n    c = Hello`</pre>\n\n    ## 4.3override标识符\n\n    <pre class=\"prettyprint\">`通过make的命令行参数设置的变量，通常在makefile中对这些变量赋值是无效的，但可以通过override标识符重新设置这些变量的值。\n    1.\n    override &lt;variable&gt;; =&lt;value&gt;\n    2.\n    override &lt;variable&gt;; :=&lt;value&gt;\n    3.\n    override &lt;variable&gt;; +=&lt;value&gt;\n    4.\n    override define foo\n    bar\n    endef\n    `</pre>\n\n    ## 4.4多行变量\n\n    <pre class=\"prettyprint\">`声明方式：\n    define two-lines\n    echo foo\n    echo $(bar)\n    endef\n    注：参见3.3定义命令块`</pre>\n\n    ## 4.5环境变量\n\n    <pre class=\"prettyprint\">`参见3.2嵌套执行make`</pre>\n\n    ## 4.6目标变量\n\n    <pre class=\"prettyprint\">`目标变量表示为某个特定的目标设定的变量，该变量的值只适用于特殊目标\n    声明：\n    &lt;target ...&gt;:&lt;variable-assignment&gt;\n    &lt;target ...&gt;:override &lt;variable-assignment&gt;\n    注：\n    &lt;variable-assignment&gt;表示常规赋值表达式\n    第二个声明适用于make命令带入的变量或环境变量\n    例：\n    m = flag\n    target：m= flag_target\n    target:\n        @echo $(m)\n    则$(m)的值为flage_target`</pre>\n\n    ## 4.7模式变量\n\n    <pre class=\"prettyprint\">`声明：\n    &lt;pattern ...&gt;:&lt;variable-assignment&gt;\n    &lt;pattern ...&gt;:override &lt;variable-assignment&gt;\n    使用方式同目标变量\n    例：\n    %.o : CFLAGS = -g\n    prog: prog1.o prog2.o\n        $(CC) $(CFLAGS ) prog1.o prog2.o\n    prog1.o:prog1.c\n        $(CC) $(CFLAGS ) prog1.c\n    prog2.o:prog2.c\n        $(CC) $(CFLAGS ) prog2.c\n    以上只有prog1.o和prog2.o下的命令中的CFLAGS的值为-O，其余为系统变量的值`</pre>\n\n    ## 4.8自动化变量\n\n    <pre class=\"prettyprint\">`在模式规则中（将在&lt;隐含规则&gt;一节中讲解），规则的目标和依赖文件名代表了一类文件名。命令是对所有这一类文件重建过程的描述，显然，在命令中不能指定特定的文件名，否则模式规则将没有了意义。那么在模式规则的命令行中该如何表示文件，将成我们这一小节的讨论重点。make中使用了“自动环变量”来实现这个目的，自动化变量的取值是根据具体的规则决定的，就是说对不同的规则其所代表的文件名不同。\n    前边我们也看到了很多例子中使用到了自动化变量。下面对所有的自动化变量进行说明：\n    $@\n    代表规则中的目标文件名。如果目标是一个文档（Linux中，一般称.a文件为文档），那么它代表这个文档的文件名。在多目标的模式规则中，它代表的是哪个触发规则被执行的目标文件名。\n    $%\n    规则的目标文件是一个静态库文件时，代表静态库的一个成员名。例如，规则的目标是“foo.a(bar.o)”，那么，“$%”的值就为“bar.o”，“$@”的值为“foo.a”。如果目标不是函数库文件，其值为空。\n    $&lt;\n    规则的第一个依赖文件名。如果是隐含规则，则它代表通过目标指定的第一个依赖文件。\n    $?\n    所有比目标文件更新的依赖文件列表，空格分割。如果目标是静态库文件名，代表的是库成员（.o文件）的更新情况。\n    $^\n    规则的所有依赖文件列表，使用空格分隔。如果目标是静态库文件名，它所代表的只能是所有库成员（.o文件）名。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的一次引用情况。就是说变量“$^”会去掉重复的依赖文件。\n    $+\n    类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时，库的交叉引用场合。\n    $*\n    在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时，“茎”也包含目录（斜杠之前）部分）。例如：文件“dir/a.foo.b”，当目标的模式为“a.%.b”时，“$*”的值为“dir/a.foo”。“茎”对于构造相关文件名非常有用。\n    自动化变量“$*”需要两点说明：\n    Ø        对于一个明确指定的规则来说不存在“茎”，这种情况下“$*”所代表的值发生变化。此时，如果目标文件名带有一个可识别的后缀，那么“$*”表示文件中除后缀以外的部分。例如：“foo.c”则“$*”的值为：“foo”，因为.c是一个可识别的文件后缀名。GUN make对明确规则的这种奇怪的处理行为是为了和其它版本的make兼容。通常，在除静态规则和模式规则以外，明确指定目标文件的规则中避免使用这个变量。\n    Ø        当明确指定文件名的规则中目标文件名包含不可识别的后缀时，此变量为空。\n    自动化变量“$?”在显式规则中也是非常有用的，规则中可以使用它来指定只对更新的依赖文件进行操作。例如，函数库文件“libN.a”，它由一些.o文件组成。如下的规则实现了根据变化的.o文件更新库文件：\n\n    lib: foo.o bar.o lose.o win.o\n        ar r lib $?\n\n    上述列出的自动量变量中。其中有四个在规则中代表一个文件名（$@、$&lt;、$%、$*）。而其它三个的在规则中代表一个文件名的列表。GUN make中，还可以通过这七个自动化变量来获取一个完整文件名中的目录部分或者具体文件名，需要在这些变量中加入“D”或者“F”字符。这样就形成了一系列变种的自动环变量。这些变量在以前版本的make中使用，在当前版本的make中，可以使用“dir”或者“notdir”函数来实现同样的功能。\n    $(@D)\n    代表目标文件的目录部分（去掉目录部分的最后一个斜杠）。如果“$@”是“dir/foo.o”，那么“$(@D)”的值为“dir”。如果“$@”不存在斜杠，其值就是“.”（当前目录）。注意它和函数“dir”的区别！\n    $(@F)\n    目标文件的完整文件名中除目录以外的部分（实际文件名）。如果“$@”为“dir/foo.o”，那么“$(@F)”只就是“foo.o”。“$(@F)”等价于函数“$(notdir $@)”。\n    $(*D)\n    $(*F)\n    分别代表目标“茎”中的目录部分和文件名部分。\n    $(%D)\n    $(%F)\n    当以如“archive(member)”形式静态库为目标时，分别表示库文件成员“member”名中的目录部分和文件名部分。它仅对这种形式的规则目标有效。\n    $(&lt;D)\n    $(&lt;F)\n    分别表示规则中第一个依赖文件的目录部分和文件名部分。\n    $(^D)\n    $(^F)\n    分别表示所有依赖文件的目录部分和文件部分（不存在同一文件）。\n    $(+D)\n    $(+F)\n    分别表示所有依赖文件的目录部分和文件部分（可存在重复文件）。\n    $(?D)\n    $(?F)\n    分别表示被更新的依赖文件的目录部分和文件部分。`</pre>\n\n    # 5.逻辑判断语句\n\n    ## 5.1使用语法\n\n    <pre class=\"prettyprint\">`1.ifeq/else/endif\n        &lt;1&gt;\n        ifeq (&lt;arg1&gt;,&lt;arg2&gt;)\n        &lt;text-ifeq&gt;\n        else\n        &lt;text-else&gt;\n        endif\n\n        &lt;2&gt;\n        ifeq (&lt;arg1&gt;,&lt;arg2&gt;)\n        &lt;text-ifeq&gt;\n        endif\n\n    2.ifneq/else/endif\n        &lt;1&gt;\n        ifneq (&lt;arg1&gt;,&lt;arg2&gt;)\n        &lt;text-ifneq&gt;\n        else\n        &lt;text-else&gt;\n        endif\n\n        &lt;2&gt;\n        ifneq (&lt;arg1&gt;,&lt;arg2&gt;)\n            &lt;text-ifneq&gt;\n        endif\n\n    3.ifdef/else/endif\n        &lt;1&gt;\n        ifdef &lt;variable-name&gt;\n        &lt;text-ifdef&gt;\n        else\n        &lt;text-else&gt;\n        endif\n\n        &lt;2&gt;\n        ifdef &lt;variable-name&gt;\n        &lt;text-ifdef&gt;\n        endif\n\n    4.if &lt;condition&gt;, &lt;then-part&gt;, &lt;else-part&gt;\n        相当于C语言中:\n        if(condition)\n            then-part;\n        else\n            else-part;`</pre>\n\n    # 6.常用函数\n\n    ## 6.1函数调用语法\n\n    <pre class=\"prettyprint\">`语法：\n    $(&lt;function&gt; &lt;arguments&gt;)\n    ${&lt;function&gt; &lt;arguments&gt;}`</pre>\n\n    ## 6.2字符串处理函数\n\n    <pre class=\"prettyprint\">`1.subst\n    字符串替换函数\n    $(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)\n    例：\n    $(subst ee,EE,feet on the street)\n    ==&gt;fEEt on the strEEt\n\n    2.patsubst\n    模式字符串替换函数\n    $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)\n\n    3.strip\n    去空格函数，去掉字符串开头和结尾的空格\n    $(strip &lt;string&gt;)\n\n    4.findstring\n    查找字符串函数\n    $(findstring &lt;findstr&gt;,&lt;string&gt;)\n\n    5.filter\n    过滤函数\n    $(filter &lt;pattern...&gt;,&lt;text&gt;)\n\n    6.filter-out\n    反过滤函数\n    $(filter-out &lt;pattern...&gt;,&lt;text&gt;)\n\n    7.sort\n    排序函数\n    $(sort &lt;list&gt;)\n\n    8.word\n    取单词函数\n    $(word &lt;n&gt;,&lt;text&gt;)\n\n    9.wordlist\n    取单词串函数，得到从&lt;s_num&gt;到&lt;e_num&gt;的单词串\n    $(wordlist &lt;s_num&gt;,&lt;e_num&gt;,&lt;text&gt;)\n\n    10.words\n    单词数统计函数\n    $(words &lt;string&gt;)\n\n    11.firstword\n    取首单词函数\n    $(firstword &lt;string&gt;)\n    `</pre>\n\n    ## 6.3文件名操作函数\n\n    <pre class=\"prettyprint\">`1.dir\n    取目录函数\n    $(dir &lt;path_files_name&gt;)\n\n    2.notdir\n    取文件名函数\n    $(nodir &lt;path_files_name&gt;)\n\n    3.suffix\n    取后缀函数\n    $(suffix &lt;names&gt;)\n\n    4.basename\n    取前缀函数\n    $(basename &lt;names&gt;)\n\n    5.addsuffix\n    添加后缀函数\n    $(addsuffix &lt;suffix&gt;,&lt;names&gt;)\n\n    6.addprefix\n    添加前缀函数\n    $(addprefix  &lt;prefix&gt;,&lt;names&gt;)\n\n    7.join\n    连接函数\n    $(join &lt;list1&gt;,&lt;list2&gt;)\n    `</pre>\n\n    ## 6.4makefile调试函数\n\n    <pre class=\"prettyprint\">`1.error\n    产生一个致命错误\n    $(error &lt;text&gt;)\n\n    2.warning\n    生成一个警告信息\n    $(warning &lt;text&gt;)\n\n    3.info\n    生成一个普通信息\n    $(info &lt;text&gt;)`</pre>\n\n    ## 6.5其他函数\n\n    <pre class=\"prettyprint\">`1.foreach\n    循环函数\n    $(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)\n\n    2.if\n    条件判断函数\n    $(if &lt;condition&gt;,&lt;then-part&gt;)\n    $(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)\n\n    3.call\n    调用函数的函数\n    $(call &lt;func&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;,...)\n    注：\n    func：自定义函数\n    parm1：func中的参数1（$(1)）\n    parm2: func中的参数2（$(2)）\n    func中的所有参数变量均用,$(1),$(2)...表示\n    例：\n    reverse = $(2) $(1)\n    foo=$(call reverse ,a,b)\n    ==&gt;\n    foo=b a\n\n    4.origin\n    变量源函数，输出变量来源\n    源列表：\n    &lt;1&gt;undefined:未定义变量\n    &lt;2&gt;default:默认定义\n    &lt;3&gt;environment:环境变量\n    &lt;4&gt;file:makefile中定义的变量\n    &lt;5&gt;command line:命令行定义的变量\n    &lt;6&gt;override:override重新定义的变量\n    &lt;7&gt;automatic:自动化变量\n    $(origin &lt;variable&gt;)\n\n    5.shell\n    调用外部shell命令函数\n    $(shell commands)\n    例：\n    fileslist：=$(shell echo *.c)\n    `</pre>\n\n    # 7.Makefile调试功能\n\n    ## 7.1makefile调试\n\n    <pre class=\"prettyprint\"></pre>\n\n    ## 7.2makefile 源码调试\n\n    <pre class=\"prettyprint\">`一般方式是通过makefile向源码增加宏定义\n    main.c:\n    #ifdef DEBUG\n    .....\n    Makefile:\n    .PHONY: all clean\n\n    LINUX_ROOT=$(LINUX_SRC)\n\n    obj-m := sil9024.o\n\n    all:\n        @make -C $(LINUX_ROOT) M=$(PWD) modules \"CFLAGS += -DDEBUG\"\n        @cp sil9024.ko ../ko/  -vfr\n\n    clean:\n        @make -C $(LINUX_ROOT) M=$(PWD) clean`</pre>\n\n    # 8.隐含规则\n\n    <pre class=\"prettyprint\">`这里写代码片\n\n# 9.写在后面\n\n非常感谢皓哥的《跟我一起写Makefile》，之前看过一点，不过没有机会全部了解，这次基本全部了解过，这是我的一点读书笔记，主要参考的就是皓哥的这本书（姑且算书吧^-^），目的为分析安卓源码中的makefile打基础，所以研究不是很深入，以后有时间再深入了解。\n\n            <div>\n                作者：WEINILUO 发表于2016/4/23 18:56:25 [原文链接](http://blog.csdn.net/weiniluo/article/details/51136429)\n            </div>\n            <div>\n            阅读：55 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51136429#comments)\n            </div>\n","slug":"原-Makfile笔记","published":1,"updated":"2016-10-20T09:48:48.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnobw0002vzs6in1rs91c","content":"<h1 id=\"1-Makfile初识\"><a href=\"#1-Makfile初识\" class=\"headerlink\" title=\"1.Makfile初识\"></a>1.Makfile初识</h1><h2 id=\"1-1Makefile规则\"><a href=\"#1-1Makefile规则\" class=\"headerlink\" title=\"1.1Makefile规则\"></a>1.1Makefile规则</h2><pre><code>target ... : prerequisites ...\n    command\n    ...\n    ...\n注：  \ntarget:目标\nprerequisites:依赖文件\ncommand:makefile 需要执行的命令\n\nMakfile规则：\n    在执行Makfile时，Makfile会判断target文件是否存在，\n    若不存在，则执行下面的command命令，\n    若存在，则判断prerequisites的时间戳是否比target的时间戳要新，\n    若是，则也执行下面的command命令。`&lt;/pre&gt;\n\n## 1.2引用其他Makefile文件\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`使用方式：\ninclude &amp;lt;filename&amp;gt;\n例：\ninclude foo.make $(value) `&lt;/pre&gt;\n\n## 1.3Makefile变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n使用方式：\nobj= a.o b.o c.o \\\n    d.o e.o\ntarget : prerequisites\n    command $(obj)\n2.CFLAGS,CXXFLAGS \n    CFLAGS 表示用于 C 编译器的选项，CXXFLAGS表示用于 C++ 编译器的选项。\n    CFLAGS指定头文件（.h文件）的路径、编译条件宏，如：CFLAGS=-I/usr/include -I/path/include -D_YUQIANG。\n    上面两个变量用于gcc的参数中：$(CC) $(CFLAGS)\n3.LDFLAGS：\n    gcc 等编译器会用到的一些优化参数，也可以在里面指定库文件的位置。用法：\n    LDFLAGS=-L/usr/lib -L/path/to/your/lib。\n4.LIBS：告诉链接器要链接哪些库文件，如LIBS = -lpthread -liconv\n`&lt;/pre&gt;\n\n## 1.4Makefile工作流程\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.在敲入make之后，make会在当前目录下寻找Makefile类型文件\n2.读入被include包含的makefile文件\n3.替换变量\n4.推到并分析所有规则\n5.位所有的目标创建依赖关系链\n6.找到文件中的第一个target作为最终的目标文件\n7.找到target后按照规则执行，若target的依赖文件也存在依赖文件，则同样按照规则递归执行，直到生成最终的目标文件后make执行完成`&lt;/pre&gt;\n\n# 2.书写规则\n\n## 2.1规则语法\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`方式1：\ntargets : prereuuisites\n    command\n    ...\n方式2：\ntargets : prereuuisites ; command\n    command\n    ...\n注意：\n1，若command为独立行，则需以&amp;lt;TAB&amp;gt;开头\n2.换行符：&apos;\\&apos;\n3.command默认使用/bash/sh来执行`&lt;/pre&gt;\n\n## 2.2通配符\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`&apos;*&apos;:代表『 0 个到无穷多个』任意字符\n&apos;?&apos;:代表『一定有一个』任意字符\n&apos;~&apos;:代表用户的主目录，~feison/data代表用户feison主目录下的data目录\n注：若需要使用这些特定字符，在该字符前加转义字符&apos;\\&apos;`&lt;/pre&gt;\n\n## 2.3文件搜索路径\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.VPATH变量\nVPATH:makefile中设定默认搜索文件路径的变量\n例：VPATH= src:../headers\n注：设置多个路径用冒号分隔\n2.vpath关键字\nvpath &amp;lt;pattern&amp;gt; &amp;lt;directories&amp;gt; :为符合模式&amp;lt;pattern&amp;gt;的文件指定搜索目录&amp;lt;directories&amp;gt;\nvpath &amp;lt;pattern&amp;gt; :清除符合模式&amp;lt;pattern&amp;gt;的文件的搜索目录\nvpath :清除所有已设置好的文件搜索目录\n例：vpath %h ../headers`&lt;/pre&gt;\n\n## 2.4伪目标\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`伪目标声明方式：\n隐式声明：\nphonytargets:\n    commands\n显式声明：\n.PHONY:phonytargets\nphonytargets:\n    commands\n例：生成多个可执行文件\nall:prog1 prog2 prog3\n.PHONY: all\n\nprog1:prog1.o\n    commands1\nprog2:prog2.o\n    commands2\nprog3:prog3.o\n    commands3`&lt;/pre&gt;\n\n## 2.5静态模式\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`规则：\n&amp;lt;targets&amp;gt;:&amp;lt;target-pattern&amp;gt;:&amp;lt;prereq-pattern&amp;gt;\n    &amp;lt;commands&amp;gt;\n    ...\n注：\ntargets：目标集，多个目标文件\ntarget-pattern：目标集模式\nprereq-pattern：依赖模式\n例：\nfoo.o bar.o abc.m : %.o : %.c\n    $(CC) -c $(CFLAGS) $&amp;lt; -o $@\n上述的.o文件的依赖文件为.c文件，当不满足makefile原则时，执行下面的命令`&lt;/pre&gt;\n\n# 3.书写命令\n\n## 3.1显示命令\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.@command和command比较\n    @command 该命令不会被make显示\n    command 该命令会被make显示\n例：\n    @echo this is a test\n    make输出：\n    this is a test\n\n    echo this is a test\n    make输出：\n    echo this is a test\n    this is a test\n2.make -n 只显示命令，但不执行命令\n3.make -s 全面禁止命令的显示`&lt;/pre&gt;\n\n## 3.2嵌套执行make\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`make嵌套，亦是make包含，以利于模块编译和分段编译\n例：\n./Makefile:(总控Makefile)\nsubsystem:\n    cd subdir &amp;amp;&amp;amp; $(MAKE)\n&amp;lt;==&amp;gt;\nsybsystem:\n    $(MAKE) -C subdir\n1.makefile中的变量传递\n默认情况下，上级的Makefile中的变量可以传递到下级makefile中，但不会覆盖下级makefile中的变量，除非制定了-e参数。\nexport &amp;lt;variable ...&amp;gt; 声明要传递到下级makefile的变量\nunport &amp;lt;variable ...&amp;gt; 声明不能传递到下级makefile的变量\n注：\nSHELL和MAKEFLAGS两个变量始终会被传递到下级makefile中\n2.make -w\n当make进入和离开下级目录时，输出相应的目录变化信息`&lt;/pre&gt;\n\n## 3.3定义命令块\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`规则：\ndefine cmdblocks-name\ncmd1\ncmd2\n...\nendef\n例：\ntarget : prereqs\n    $(cmdblocks-name)`&lt;/pre&gt;\n\n# 4.变量\n\n## 4.1变量声明\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.常规变量\nvariable = value\n$(variable)==&amp;gt;value\n${variable}==&amp;gt;value\n2.变量中的变量\nvariable ：=value\n1中的声明方式会出现无限的变量展开中，如下\nA=$(B)\nB=$(A)\n:=的声明方式规定前面的变量不能使用后面的变量,若使用的变量前面未被定义，则其值为空\n例：\nx:=foo\ny:=$(x) bar $(m)\nx:=later\n==&amp;gt;\ny:=foo bar\nx:=later\n3.定义一个其值为空格的变量\nnullstring:=\nspace:=$(nullstring) #end of the line\n注：nullstring为Empty变量，space表示一个空格，Empty变量表示一个变量的值开始了，#表示变量的定义终止\n4.操作符?=\nvariable ?=value\n表示若variable之前被定义过，则该语句无效，若没有被定义过，其值为value`&lt;/pre&gt;\n\n## 4.2变量使用\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.多重变量\nx=y\ny=z\na:=$($(x))\n==&amp;gt;\na:=z\n\n2.变量值的替换\n$(var:a=b)\n${var:a=b}\n表示把变量var中所有以a字符串结尾的a替换为b字符串\n例：\nfoo := a.o b.o c.o\nbar :=$(foo:.o=.c)\n\nfoo := a.o b.o c.o\nbar :=$(foo:%.o=%.c)\n\n3.追加变量\nvariable +=value\n例：\na := b\na +=c\n==&amp;gt;\na := b\na :=$(a) b\n\n4.其他\n例：\nfirst_second = Hello\na = first\nb = second\nc =$($(a)_$(b))\n==&amp;gt;\nc = Hello`&lt;/pre&gt;\n\n## 4.3override标识符\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`通过make的命令行参数设置的变量，通常在makefile中对这些变量赋值是无效的，但可以通过override标识符重新设置这些变量的值。\n1.\noverride &amp;lt;variable&amp;gt;; =&amp;lt;value&amp;gt;\n2.\noverride &amp;lt;variable&amp;gt;; :=&amp;lt;value&amp;gt;\n3.\noverride &amp;lt;variable&amp;gt;; +=&amp;lt;value&amp;gt;\n4.\noverride define foo\nbar\nendef\n`&lt;/pre&gt;\n\n## 4.4多行变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`声明方式：\ndefine two-lines\necho foo\necho $(bar)\nendef\n注：参见3.3定义命令块`&lt;/pre&gt;\n\n## 4.5环境变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`参见3.2嵌套执行make`&lt;/pre&gt;\n\n## 4.6目标变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`目标变量表示为某个特定的目标设定的变量，该变量的值只适用于特殊目标\n声明：\n&amp;lt;target ...&amp;gt;:&amp;lt;variable-assignment&amp;gt;\n&amp;lt;target ...&amp;gt;:override &amp;lt;variable-assignment&amp;gt;\n注：\n&amp;lt;variable-assignment&amp;gt;表示常规赋值表达式\n第二个声明适用于make命令带入的变量或环境变量\n例：\nm = flag\ntarget：m= flag_target\ntarget:\n    @echo $(m)\n则$(m)的值为flage_target`&lt;/pre&gt;\n\n## 4.7模式变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`声明：\n&amp;lt;pattern ...&amp;gt;:&amp;lt;variable-assignment&amp;gt;\n&amp;lt;pattern ...&amp;gt;:override &amp;lt;variable-assignment&amp;gt;\n使用方式同目标变量\n例：\n%.o : CFLAGS = -g\nprog: prog1.o prog2.o\n    $(CC) $(CFLAGS ) prog1.o prog2.o\nprog1.o:prog1.c\n    $(CC) $(CFLAGS ) prog1.c\nprog2.o:prog2.c\n    $(CC) $(CFLAGS ) prog2.c\n以上只有prog1.o和prog2.o下的命令中的CFLAGS的值为-O，其余为系统变量的值`&lt;/pre&gt;\n\n## 4.8自动化变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`在模式规则中（将在&amp;lt;隐含规则&amp;gt;一节中讲解），规则的目标和依赖文件名代表了一类文件名。命令是对所有这一类文件重建过程的描述，显然，在命令中不能指定特定的文件名，否则模式规则将没有了意义。那么在模式规则的命令行中该如何表示文件，将成我们这一小节的讨论重点。make中使用了“自动环变量”来实现这个目的，自动化变量的取值是根据具体的规则决定的，就是说对不同的规则其所代表的文件名不同。\n前边我们也看到了很多例子中使用到了自动化变量。下面对所有的自动化变量进行说明：\n$@\n代表规则中的目标文件名。如果目标是一个文档（Linux中，一般称.a文件为文档），那么它代表这个文档的文件名。在多目标的模式规则中，它代表的是哪个触发规则被执行的目标文件名。\n$%\n规则的目标文件是一个静态库文件时，代表静态库的一个成员名。例如，规则的目标是“foo.a(bar.o)”，那么，“$%”的值就为“bar.o”，“$@”的值为“foo.a”。如果目标不是函数库文件，其值为空。\n$&amp;lt;\n规则的第一个依赖文件名。如果是隐含规则，则它代表通过目标指定的第一个依赖文件。\n$?\n所有比目标文件更新的依赖文件列表，空格分割。如果目标是静态库文件名，代表的是库成员（.o文件）的更新情况。\n$^\n规则的所有依赖文件列表，使用空格分隔。如果目标是静态库文件名，它所代表的只能是所有库成员（.o文件）名。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的一次引用情况。就是说变量“$^”会去掉重复的依赖文件。\n$+\n类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时，库的交叉引用场合。\n$*\n在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时，“茎”也包含目录（斜杠之前）部分）。例如：文件“dir/a.foo.b”，当目标的模式为“a.%.b”时，“$*”的值为“dir/a.foo”。“茎”对于构造相关文件名非常有用。\n自动化变量“$*”需要两点说明：\nØ        对于一个明确指定的规则来说不存在“茎”，这种情况下“$*”所代表的值发生变化。此时，如果目标文件名带有一个可识别的后缀，那么“$*”表示文件中除后缀以外的部分。例如：“foo.c”则“$*”的值为：“foo”，因为.c是一个可识别的文件后缀名。GUN make对明确规则的这种奇怪的处理行为是为了和其它版本的make兼容。通常，在除静态规则和模式规则以外，明确指定目标文件的规则中避免使用这个变量。\nØ        当明确指定文件名的规则中目标文件名包含不可识别的后缀时，此变量为空。\n自动化变量“$?”在显式规则中也是非常有用的，规则中可以使用它来指定只对更新的依赖文件进行操作。例如，函数库文件“libN.a”，它由一些.o文件组成。如下的规则实现了根据变化的.o文件更新库文件：\n\nlib: foo.o bar.o lose.o win.o\n    ar r lib $?\n\n上述列出的自动量变量中。其中有四个在规则中代表一个文件名（$@、$&amp;lt;、$%、$*）。而其它三个的在规则中代表一个文件名的列表。GUN make中，还可以通过这七个自动化变量来获取一个完整文件名中的目录部分或者具体文件名，需要在这些变量中加入“D”或者“F”字符。这样就形成了一系列变种的自动环变量。这些变量在以前版本的make中使用，在当前版本的make中，可以使用“dir”或者“notdir”函数来实现同样的功能。\n$(@D)\n代表目标文件的目录部分（去掉目录部分的最后一个斜杠）。如果“$@”是“dir/foo.o”，那么“$(@D)”的值为“dir”。如果“$@”不存在斜杠，其值就是“.”（当前目录）。注意它和函数“dir”的区别！\n$(@F)\n目标文件的完整文件名中除目录以外的部分（实际文件名）。如果“$@”为“dir/foo.o”，那么“$(@F)”只就是“foo.o”。“$(@F)”等价于函数“$(notdir $@)”。\n$(*D)\n$(*F)\n分别代表目标“茎”中的目录部分和文件名部分。\n$(%D)\n$(%F)\n当以如“archive(member)”形式静态库为目标时，分别表示库文件成员“member”名中的目录部分和文件名部分。它仅对这种形式的规则目标有效。\n$(&amp;lt;D)\n$(&amp;lt;F)\n分别表示规则中第一个依赖文件的目录部分和文件名部分。\n$(^D)\n$(^F)\n分别表示所有依赖文件的目录部分和文件部分（不存在同一文件）。\n$(+D)\n$(+F)\n分别表示所有依赖文件的目录部分和文件部分（可存在重复文件）。\n$(?D)\n$(?F)\n分别表示被更新的依赖文件的目录部分和文件部分。`&lt;/pre&gt;\n\n# 5.逻辑判断语句\n\n## 5.1使用语法\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.ifeq/else/endif\n    &amp;lt;1&amp;gt;\n    ifeq (&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;)\n    &amp;lt;text-ifeq&amp;gt;\n    else\n    &amp;lt;text-else&amp;gt;\n    endif\n\n    &amp;lt;2&amp;gt;\n    ifeq (&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;)\n    &amp;lt;text-ifeq&amp;gt;\n    endif\n\n2.ifneq/else/endif\n    &amp;lt;1&amp;gt;\n    ifneq (&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;)\n    &amp;lt;text-ifneq&amp;gt;\n    else\n    &amp;lt;text-else&amp;gt;\n    endif\n\n    &amp;lt;2&amp;gt;\n    ifneq (&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;)\n        &amp;lt;text-ifneq&amp;gt;\n    endif\n\n3.ifdef/else/endif\n    &amp;lt;1&amp;gt;\n    ifdef &amp;lt;variable-name&amp;gt;\n    &amp;lt;text-ifdef&amp;gt;\n    else\n    &amp;lt;text-else&amp;gt;\n    endif\n\n    &amp;lt;2&amp;gt;\n    ifdef &amp;lt;variable-name&amp;gt;\n    &amp;lt;text-ifdef&amp;gt;\n    endif\n\n4.if &amp;lt;condition&amp;gt;, &amp;lt;then-part&amp;gt;, &amp;lt;else-part&amp;gt;\n    相当于C语言中:\n    if(condition)\n        then-part;\n    else\n        else-part;`&lt;/pre&gt;\n\n# 6.常用函数\n\n## 6.1函数调用语法\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`语法：\n$(&amp;lt;function&amp;gt; &amp;lt;arguments&amp;gt;)\n${&amp;lt;function&amp;gt; &amp;lt;arguments&amp;gt;}`&lt;/pre&gt;\n\n## 6.2字符串处理函数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.subst\n字符串替换函数\n$(subst &amp;lt;from&amp;gt;,&amp;lt;to&amp;gt;,&amp;lt;text&amp;gt;)\n例：\n$(subst ee,EE,feet on the street)\n==&amp;gt;fEEt on the strEEt\n\n2.patsubst\n模式字符串替换函数\n$(patsubst &amp;lt;pattern&amp;gt;,&amp;lt;replacement&amp;gt;,&amp;lt;text&amp;gt;)\n\n3.strip\n去空格函数，去掉字符串开头和结尾的空格\n$(strip &amp;lt;string&amp;gt;)\n\n4.findstring\n查找字符串函数\n$(findstring &amp;lt;findstr&amp;gt;,&amp;lt;string&amp;gt;)\n\n5.filter\n过滤函数\n$(filter &amp;lt;pattern...&amp;gt;,&amp;lt;text&amp;gt;)\n\n6.filter-out\n反过滤函数\n$(filter-out &amp;lt;pattern...&amp;gt;,&amp;lt;text&amp;gt;)\n\n7.sort\n排序函数\n$(sort &amp;lt;list&amp;gt;)\n\n8.word\n取单词函数\n$(word &amp;lt;n&amp;gt;,&amp;lt;text&amp;gt;)\n\n9.wordlist\n取单词串函数，得到从&amp;lt;s_num&amp;gt;到&amp;lt;e_num&amp;gt;的单词串\n$(wordlist &amp;lt;s_num&amp;gt;,&amp;lt;e_num&amp;gt;,&amp;lt;text&amp;gt;)\n\n10.words\n单词数统计函数\n$(words &amp;lt;string&amp;gt;)\n\n11.firstword\n取首单词函数\n$(firstword &amp;lt;string&amp;gt;)\n`&lt;/pre&gt;\n\n## 6.3文件名操作函数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.dir\n取目录函数\n$(dir &amp;lt;path_files_name&amp;gt;)\n\n2.notdir\n取文件名函数\n$(nodir &amp;lt;path_files_name&amp;gt;)\n\n3.suffix\n取后缀函数\n$(suffix &amp;lt;names&amp;gt;)\n\n4.basename\n取前缀函数\n$(basename &amp;lt;names&amp;gt;)\n\n5.addsuffix\n添加后缀函数\n$(addsuffix &amp;lt;suffix&amp;gt;,&amp;lt;names&amp;gt;)\n\n6.addprefix\n添加前缀函数\n$(addprefix  &amp;lt;prefix&amp;gt;,&amp;lt;names&amp;gt;)\n\n7.join\n连接函数\n$(join &amp;lt;list1&amp;gt;,&amp;lt;list2&amp;gt;)\n`&lt;/pre&gt;\n\n## 6.4makefile调试函数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.error\n产生一个致命错误\n$(error &amp;lt;text&amp;gt;)\n\n2.warning\n生成一个警告信息\n$(warning &amp;lt;text&amp;gt;)\n\n3.info\n生成一个普通信息\n$(info &amp;lt;text&amp;gt;)`&lt;/pre&gt;\n\n## 6.5其他函数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.foreach\n循环函数\n$(foreach &amp;lt;var&amp;gt;,&amp;lt;list&amp;gt;,&amp;lt;text&amp;gt;)\n\n2.if\n条件判断函数\n$(if &amp;lt;condition&amp;gt;,&amp;lt;then-part&amp;gt;)\n$(if &amp;lt;condition&amp;gt;,&amp;lt;then-part&amp;gt;,&amp;lt;else-part&amp;gt;)\n\n3.call\n调用函数的函数\n$(call &amp;lt;func&amp;gt;,&amp;lt;parm1&amp;gt;,&amp;lt;parm2&amp;gt;,&amp;lt;parm3&amp;gt;,...)\n注：\nfunc：自定义函数\nparm1：func中的参数1（$(1)）\nparm2: func中的参数2（$(2)）\nfunc中的所有参数变量均用,$(1),$(2)...表示\n例：\nreverse = $(2) $(1)\nfoo=$(call reverse ,a,b)\n==&amp;gt;\nfoo=b a\n\n4.origin\n变量源函数，输出变量来源\n源列表：\n&amp;lt;1&amp;gt;undefined:未定义变量\n&amp;lt;2&amp;gt;default:默认定义\n&amp;lt;3&amp;gt;environment:环境变量\n&amp;lt;4&amp;gt;file:makefile中定义的变量\n&amp;lt;5&amp;gt;command line:命令行定义的变量\n&amp;lt;6&amp;gt;override:override重新定义的变量\n&amp;lt;7&amp;gt;automatic:自动化变量\n$(origin &amp;lt;variable&amp;gt;)\n\n5.shell\n调用外部shell命令函数\n$(shell commands)\n例：\nfileslist：=$(shell echo *.c)\n`&lt;/pre&gt;\n\n# 7.Makefile调试功能\n\n## 7.1makefile调试\n\n&lt;pre class=&quot;prettyprint&quot;&gt;&lt;/pre&gt;\n\n## 7.2makefile 源码调试\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`一般方式是通过makefile向源码增加宏定义\nmain.c:\n#ifdef DEBUG\n.....\nMakefile:\n.PHONY: all clean\n\nLINUX_ROOT=$(LINUX_SRC)\n\nobj-m := sil9024.o\n\nall:\n    @make -C $(LINUX_ROOT) M=$(PWD) modules &quot;CFLAGS += -DDEBUG&quot;\n    @cp sil9024.ko ../ko/  -vfr\n\nclean:\n    @make -C $(LINUX_ROOT) M=$(PWD) clean`&lt;/pre&gt;\n\n# 8.隐含规则\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`这里写代码片\n</code></pre><h1 id=\"9-写在后面\"><a href=\"#9-写在后面\" class=\"headerlink\" title=\"9.写在后面\"></a>9.写在后面</h1><p>非常感谢皓哥的《跟我一起写Makefile》，之前看过一点，不过没有机会全部了解，这次基本全部了解过，这是我的一点读书笔记，主要参考的就是皓哥的这本书（姑且算书吧^-^），目的为分析安卓源码中的makefile打基础，所以研究不是很深入，以后有时间再深入了解。</p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/4/23 18:56:25 [原文链接](http://blog.csdn.net/weiniluo/article/details/51136429)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：55 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51136429#comments)\n&lt;/div&gt;\n</code></pre>","excerpt":"","more":"<h1 id=\"1-Makfile初识\"><a href=\"#1-Makfile初识\" class=\"headerlink\" title=\"1.Makfile初识\"></a>1.Makfile初识</h1><h2 id=\"1-1Makefile规则\"><a href=\"#1-1Makefile规则\" class=\"headerlink\" title=\"1.1Makefile规则\"></a>1.1Makefile规则</h2><pre><code>target ... : prerequisites ...\n    command\n    ...\n    ...\n注：  \ntarget:目标\nprerequisites:依赖文件\ncommand:makefile 需要执行的命令\n\nMakfile规则：\n    在执行Makfile时，Makfile会判断target文件是否存在，\n    若不存在，则执行下面的command命令，\n    若存在，则判断prerequisites的时间戳是否比target的时间戳要新，\n    若是，则也执行下面的command命令。`&lt;/pre&gt;\n\n## 1.2引用其他Makefile文件\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`使用方式：\ninclude &amp;lt;filename&amp;gt;\n例：\ninclude foo.make $(value) `&lt;/pre&gt;\n\n## 1.3Makefile变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n使用方式：\nobj= a.o b.o c.o \\\n    d.o e.o\ntarget : prerequisites\n    command $(obj)\n2.CFLAGS,CXXFLAGS \n    CFLAGS 表示用于 C 编译器的选项，CXXFLAGS表示用于 C++ 编译器的选项。\n    CFLAGS指定头文件（.h文件）的路径、编译条件宏，如：CFLAGS=-I/usr/include -I/path/include -D_YUQIANG。\n    上面两个变量用于gcc的参数中：$(CC) $(CFLAGS)\n3.LDFLAGS：\n    gcc 等编译器会用到的一些优化参数，也可以在里面指定库文件的位置。用法：\n    LDFLAGS=-L/usr/lib -L/path/to/your/lib。\n4.LIBS：告诉链接器要链接哪些库文件，如LIBS = -lpthread -liconv\n`&lt;/pre&gt;\n\n## 1.4Makefile工作流程\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.在敲入make之后，make会在当前目录下寻找Makefile类型文件\n2.读入被include包含的makefile文件\n3.替换变量\n4.推到并分析所有规则\n5.位所有的目标创建依赖关系链\n6.找到文件中的第一个target作为最终的目标文件\n7.找到target后按照规则执行，若target的依赖文件也存在依赖文件，则同样按照规则递归执行，直到生成最终的目标文件后make执行完成`&lt;/pre&gt;\n\n# 2.书写规则\n\n## 2.1规则语法\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`方式1：\ntargets : prereuuisites\n    command\n    ...\n方式2：\ntargets : prereuuisites ; command\n    command\n    ...\n注意：\n1，若command为独立行，则需以&amp;lt;TAB&amp;gt;开头\n2.换行符：&apos;\\&apos;\n3.command默认使用/bash/sh来执行`&lt;/pre&gt;\n\n## 2.2通配符\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`&apos;*&apos;:代表『 0 个到无穷多个』任意字符\n&apos;?&apos;:代表『一定有一个』任意字符\n&apos;~&apos;:代表用户的主目录，~feison/data代表用户feison主目录下的data目录\n注：若需要使用这些特定字符，在该字符前加转义字符&apos;\\&apos;`&lt;/pre&gt;\n\n## 2.3文件搜索路径\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.VPATH变量\nVPATH:makefile中设定默认搜索文件路径的变量\n例：VPATH= src:../headers\n注：设置多个路径用冒号分隔\n2.vpath关键字\nvpath &amp;lt;pattern&amp;gt; &amp;lt;directories&amp;gt; :为符合模式&amp;lt;pattern&amp;gt;的文件指定搜索目录&amp;lt;directories&amp;gt;\nvpath &amp;lt;pattern&amp;gt; :清除符合模式&amp;lt;pattern&amp;gt;的文件的搜索目录\nvpath :清除所有已设置好的文件搜索目录\n例：vpath %h ../headers`&lt;/pre&gt;\n\n## 2.4伪目标\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`伪目标声明方式：\n隐式声明：\nphonytargets:\n    commands\n显式声明：\n.PHONY:phonytargets\nphonytargets:\n    commands\n例：生成多个可执行文件\nall:prog1 prog2 prog3\n.PHONY: all\n\nprog1:prog1.o\n    commands1\nprog2:prog2.o\n    commands2\nprog3:prog3.o\n    commands3`&lt;/pre&gt;\n\n## 2.5静态模式\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`规则：\n&amp;lt;targets&amp;gt;:&amp;lt;target-pattern&amp;gt;:&amp;lt;prereq-pattern&amp;gt;\n    &amp;lt;commands&amp;gt;\n    ...\n注：\ntargets：目标集，多个目标文件\ntarget-pattern：目标集模式\nprereq-pattern：依赖模式\n例：\nfoo.o bar.o abc.m : %.o : %.c\n    $(CC) -c $(CFLAGS) $&amp;lt; -o $@\n上述的.o文件的依赖文件为.c文件，当不满足makefile原则时，执行下面的命令`&lt;/pre&gt;\n\n# 3.书写命令\n\n## 3.1显示命令\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.@command和command比较\n    @command 该命令不会被make显示\n    command 该命令会被make显示\n例：\n    @echo this is a test\n    make输出：\n    this is a test\n\n    echo this is a test\n    make输出：\n    echo this is a test\n    this is a test\n2.make -n 只显示命令，但不执行命令\n3.make -s 全面禁止命令的显示`&lt;/pre&gt;\n\n## 3.2嵌套执行make\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`make嵌套，亦是make包含，以利于模块编译和分段编译\n例：\n./Makefile:(总控Makefile)\nsubsystem:\n    cd subdir &amp;amp;&amp;amp; $(MAKE)\n&amp;lt;==&amp;gt;\nsybsystem:\n    $(MAKE) -C subdir\n1.makefile中的变量传递\n默认情况下，上级的Makefile中的变量可以传递到下级makefile中，但不会覆盖下级makefile中的变量，除非制定了-e参数。\nexport &amp;lt;variable ...&amp;gt; 声明要传递到下级makefile的变量\nunport &amp;lt;variable ...&amp;gt; 声明不能传递到下级makefile的变量\n注：\nSHELL和MAKEFLAGS两个变量始终会被传递到下级makefile中\n2.make -w\n当make进入和离开下级目录时，输出相应的目录变化信息`&lt;/pre&gt;\n\n## 3.3定义命令块\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`规则：\ndefine cmdblocks-name\ncmd1\ncmd2\n...\nendef\n例：\ntarget : prereqs\n    $(cmdblocks-name)`&lt;/pre&gt;\n\n# 4.变量\n\n## 4.1变量声明\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.常规变量\nvariable = value\n$(variable)==&amp;gt;value\n${variable}==&amp;gt;value\n2.变量中的变量\nvariable ：=value\n1中的声明方式会出现无限的变量展开中，如下\nA=$(B)\nB=$(A)\n:=的声明方式规定前面的变量不能使用后面的变量,若使用的变量前面未被定义，则其值为空\n例：\nx:=foo\ny:=$(x) bar $(m)\nx:=later\n==&amp;gt;\ny:=foo bar\nx:=later\n3.定义一个其值为空格的变量\nnullstring:=\nspace:=$(nullstring) #end of the line\n注：nullstring为Empty变量，space表示一个空格，Empty变量表示一个变量的值开始了，#表示变量的定义终止\n4.操作符?=\nvariable ?=value\n表示若variable之前被定义过，则该语句无效，若没有被定义过，其值为value`&lt;/pre&gt;\n\n## 4.2变量使用\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.多重变量\nx=y\ny=z\na:=$($(x))\n==&amp;gt;\na:=z\n\n2.变量值的替换\n$(var:a=b)\n${var:a=b}\n表示把变量var中所有以a字符串结尾的a替换为b字符串\n例：\nfoo := a.o b.o c.o\nbar :=$(foo:.o=.c)\n\nfoo := a.o b.o c.o\nbar :=$(foo:%.o=%.c)\n\n3.追加变量\nvariable +=value\n例：\na := b\na +=c\n==&amp;gt;\na := b\na :=$(a) b\n\n4.其他\n例：\nfirst_second = Hello\na = first\nb = second\nc =$($(a)_$(b))\n==&amp;gt;\nc = Hello`&lt;/pre&gt;\n\n## 4.3override标识符\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`通过make的命令行参数设置的变量，通常在makefile中对这些变量赋值是无效的，但可以通过override标识符重新设置这些变量的值。\n1.\noverride &amp;lt;variable&amp;gt;; =&amp;lt;value&amp;gt;\n2.\noverride &amp;lt;variable&amp;gt;; :=&amp;lt;value&amp;gt;\n3.\noverride &amp;lt;variable&amp;gt;; +=&amp;lt;value&amp;gt;\n4.\noverride define foo\nbar\nendef\n`&lt;/pre&gt;\n\n## 4.4多行变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`声明方式：\ndefine two-lines\necho foo\necho $(bar)\nendef\n注：参见3.3定义命令块`&lt;/pre&gt;\n\n## 4.5环境变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`参见3.2嵌套执行make`&lt;/pre&gt;\n\n## 4.6目标变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`目标变量表示为某个特定的目标设定的变量，该变量的值只适用于特殊目标\n声明：\n&amp;lt;target ...&amp;gt;:&amp;lt;variable-assignment&amp;gt;\n&amp;lt;target ...&amp;gt;:override &amp;lt;variable-assignment&amp;gt;\n注：\n&amp;lt;variable-assignment&amp;gt;表示常规赋值表达式\n第二个声明适用于make命令带入的变量或环境变量\n例：\nm = flag\ntarget：m= flag_target\ntarget:\n    @echo $(m)\n则$(m)的值为flage_target`&lt;/pre&gt;\n\n## 4.7模式变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`声明：\n&amp;lt;pattern ...&amp;gt;:&amp;lt;variable-assignment&amp;gt;\n&amp;lt;pattern ...&amp;gt;:override &amp;lt;variable-assignment&amp;gt;\n使用方式同目标变量\n例：\n%.o : CFLAGS = -g\nprog: prog1.o prog2.o\n    $(CC) $(CFLAGS ) prog1.o prog2.o\nprog1.o:prog1.c\n    $(CC) $(CFLAGS ) prog1.c\nprog2.o:prog2.c\n    $(CC) $(CFLAGS ) prog2.c\n以上只有prog1.o和prog2.o下的命令中的CFLAGS的值为-O，其余为系统变量的值`&lt;/pre&gt;\n\n## 4.8自动化变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`在模式规则中（将在&amp;lt;隐含规则&amp;gt;一节中讲解），规则的目标和依赖文件名代表了一类文件名。命令是对所有这一类文件重建过程的描述，显然，在命令中不能指定特定的文件名，否则模式规则将没有了意义。那么在模式规则的命令行中该如何表示文件，将成我们这一小节的讨论重点。make中使用了“自动环变量”来实现这个目的，自动化变量的取值是根据具体的规则决定的，就是说对不同的规则其所代表的文件名不同。\n前边我们也看到了很多例子中使用到了自动化变量。下面对所有的自动化变量进行说明：\n$@\n代表规则中的目标文件名。如果目标是一个文档（Linux中，一般称.a文件为文档），那么它代表这个文档的文件名。在多目标的模式规则中，它代表的是哪个触发规则被执行的目标文件名。\n$%\n规则的目标文件是一个静态库文件时，代表静态库的一个成员名。例如，规则的目标是“foo.a(bar.o)”，那么，“$%”的值就为“bar.o”，“$@”的值为“foo.a”。如果目标不是函数库文件，其值为空。\n$&amp;lt;\n规则的第一个依赖文件名。如果是隐含规则，则它代表通过目标指定的第一个依赖文件。\n$?\n所有比目标文件更新的依赖文件列表，空格分割。如果目标是静态库文件名，代表的是库成员（.o文件）的更新情况。\n$^\n规则的所有依赖文件列表，使用空格分隔。如果目标是静态库文件名，它所代表的只能是所有库成员（.o文件）名。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的一次引用情况。就是说变量“$^”会去掉重复的依赖文件。\n$+\n类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时，库的交叉引用场合。\n$*\n在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时，“茎”也包含目录（斜杠之前）部分）。例如：文件“dir/a.foo.b”，当目标的模式为“a.%.b”时，“$*”的值为“dir/a.foo”。“茎”对于构造相关文件名非常有用。\n自动化变量“$*”需要两点说明：\nØ        对于一个明确指定的规则来说不存在“茎”，这种情况下“$*”所代表的值发生变化。此时，如果目标文件名带有一个可识别的后缀，那么“$*”表示文件中除后缀以外的部分。例如：“foo.c”则“$*”的值为：“foo”，因为.c是一个可识别的文件后缀名。GUN make对明确规则的这种奇怪的处理行为是为了和其它版本的make兼容。通常，在除静态规则和模式规则以外，明确指定目标文件的规则中避免使用这个变量。\nØ        当明确指定文件名的规则中目标文件名包含不可识别的后缀时，此变量为空。\n自动化变量“$?”在显式规则中也是非常有用的，规则中可以使用它来指定只对更新的依赖文件进行操作。例如，函数库文件“libN.a”，它由一些.o文件组成。如下的规则实现了根据变化的.o文件更新库文件：\n\nlib: foo.o bar.o lose.o win.o\n    ar r lib $?\n\n上述列出的自动量变量中。其中有四个在规则中代表一个文件名（$@、$&amp;lt;、$%、$*）。而其它三个的在规则中代表一个文件名的列表。GUN make中，还可以通过这七个自动化变量来获取一个完整文件名中的目录部分或者具体文件名，需要在这些变量中加入“D”或者“F”字符。这样就形成了一系列变种的自动环变量。这些变量在以前版本的make中使用，在当前版本的make中，可以使用“dir”或者“notdir”函数来实现同样的功能。\n$(@D)\n代表目标文件的目录部分（去掉目录部分的最后一个斜杠）。如果“$@”是“dir/foo.o”，那么“$(@D)”的值为“dir”。如果“$@”不存在斜杠，其值就是“.”（当前目录）。注意它和函数“dir”的区别！\n$(@F)\n目标文件的完整文件名中除目录以外的部分（实际文件名）。如果“$@”为“dir/foo.o”，那么“$(@F)”只就是“foo.o”。“$(@F)”等价于函数“$(notdir $@)”。\n$(*D)\n$(*F)\n分别代表目标“茎”中的目录部分和文件名部分。\n$(%D)\n$(%F)\n当以如“archive(member)”形式静态库为目标时，分别表示库文件成员“member”名中的目录部分和文件名部分。它仅对这种形式的规则目标有效。\n$(&amp;lt;D)\n$(&amp;lt;F)\n分别表示规则中第一个依赖文件的目录部分和文件名部分。\n$(^D)\n$(^F)\n分别表示所有依赖文件的目录部分和文件部分（不存在同一文件）。\n$(+D)\n$(+F)\n分别表示所有依赖文件的目录部分和文件部分（可存在重复文件）。\n$(?D)\n$(?F)\n分别表示被更新的依赖文件的目录部分和文件部分。`&lt;/pre&gt;\n\n# 5.逻辑判断语句\n\n## 5.1使用语法\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.ifeq/else/endif\n    &amp;lt;1&amp;gt;\n    ifeq (&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;)\n    &amp;lt;text-ifeq&amp;gt;\n    else\n    &amp;lt;text-else&amp;gt;\n    endif\n\n    &amp;lt;2&amp;gt;\n    ifeq (&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;)\n    &amp;lt;text-ifeq&amp;gt;\n    endif\n\n2.ifneq/else/endif\n    &amp;lt;1&amp;gt;\n    ifneq (&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;)\n    &amp;lt;text-ifneq&amp;gt;\n    else\n    &amp;lt;text-else&amp;gt;\n    endif\n\n    &amp;lt;2&amp;gt;\n    ifneq (&amp;lt;arg1&amp;gt;,&amp;lt;arg2&amp;gt;)\n        &amp;lt;text-ifneq&amp;gt;\n    endif\n\n3.ifdef/else/endif\n    &amp;lt;1&amp;gt;\n    ifdef &amp;lt;variable-name&amp;gt;\n    &amp;lt;text-ifdef&amp;gt;\n    else\n    &amp;lt;text-else&amp;gt;\n    endif\n\n    &amp;lt;2&amp;gt;\n    ifdef &amp;lt;variable-name&amp;gt;\n    &amp;lt;text-ifdef&amp;gt;\n    endif\n\n4.if &amp;lt;condition&amp;gt;, &amp;lt;then-part&amp;gt;, &amp;lt;else-part&amp;gt;\n    相当于C语言中:\n    if(condition)\n        then-part;\n    else\n        else-part;`&lt;/pre&gt;\n\n# 6.常用函数\n\n## 6.1函数调用语法\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`语法：\n$(&amp;lt;function&amp;gt; &amp;lt;arguments&amp;gt;)\n${&amp;lt;function&amp;gt; &amp;lt;arguments&amp;gt;}`&lt;/pre&gt;\n\n## 6.2字符串处理函数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.subst\n字符串替换函数\n$(subst &amp;lt;from&amp;gt;,&amp;lt;to&amp;gt;,&amp;lt;text&amp;gt;)\n例：\n$(subst ee,EE,feet on the street)\n==&amp;gt;fEEt on the strEEt\n\n2.patsubst\n模式字符串替换函数\n$(patsubst &amp;lt;pattern&amp;gt;,&amp;lt;replacement&amp;gt;,&amp;lt;text&amp;gt;)\n\n3.strip\n去空格函数，去掉字符串开头和结尾的空格\n$(strip &amp;lt;string&amp;gt;)\n\n4.findstring\n查找字符串函数\n$(findstring &amp;lt;findstr&amp;gt;,&amp;lt;string&amp;gt;)\n\n5.filter\n过滤函数\n$(filter &amp;lt;pattern...&amp;gt;,&amp;lt;text&amp;gt;)\n\n6.filter-out\n反过滤函数\n$(filter-out &amp;lt;pattern...&amp;gt;,&amp;lt;text&amp;gt;)\n\n7.sort\n排序函数\n$(sort &amp;lt;list&amp;gt;)\n\n8.word\n取单词函数\n$(word &amp;lt;n&amp;gt;,&amp;lt;text&amp;gt;)\n\n9.wordlist\n取单词串函数，得到从&amp;lt;s_num&amp;gt;到&amp;lt;e_num&amp;gt;的单词串\n$(wordlist &amp;lt;s_num&amp;gt;,&amp;lt;e_num&amp;gt;,&amp;lt;text&amp;gt;)\n\n10.words\n单词数统计函数\n$(words &amp;lt;string&amp;gt;)\n\n11.firstword\n取首单词函数\n$(firstword &amp;lt;string&amp;gt;)\n`&lt;/pre&gt;\n\n## 6.3文件名操作函数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.dir\n取目录函数\n$(dir &amp;lt;path_files_name&amp;gt;)\n\n2.notdir\n取文件名函数\n$(nodir &amp;lt;path_files_name&amp;gt;)\n\n3.suffix\n取后缀函数\n$(suffix &amp;lt;names&amp;gt;)\n\n4.basename\n取前缀函数\n$(basename &amp;lt;names&amp;gt;)\n\n5.addsuffix\n添加后缀函数\n$(addsuffix &amp;lt;suffix&amp;gt;,&amp;lt;names&amp;gt;)\n\n6.addprefix\n添加前缀函数\n$(addprefix  &amp;lt;prefix&amp;gt;,&amp;lt;names&amp;gt;)\n\n7.join\n连接函数\n$(join &amp;lt;list1&amp;gt;,&amp;lt;list2&amp;gt;)\n`&lt;/pre&gt;\n\n## 6.4makefile调试函数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.error\n产生一个致命错误\n$(error &amp;lt;text&amp;gt;)\n\n2.warning\n生成一个警告信息\n$(warning &amp;lt;text&amp;gt;)\n\n3.info\n生成一个普通信息\n$(info &amp;lt;text&amp;gt;)`&lt;/pre&gt;\n\n## 6.5其他函数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.foreach\n循环函数\n$(foreach &amp;lt;var&amp;gt;,&amp;lt;list&amp;gt;,&amp;lt;text&amp;gt;)\n\n2.if\n条件判断函数\n$(if &amp;lt;condition&amp;gt;,&amp;lt;then-part&amp;gt;)\n$(if &amp;lt;condition&amp;gt;,&amp;lt;then-part&amp;gt;,&amp;lt;else-part&amp;gt;)\n\n3.call\n调用函数的函数\n$(call &amp;lt;func&amp;gt;,&amp;lt;parm1&amp;gt;,&amp;lt;parm2&amp;gt;,&amp;lt;parm3&amp;gt;,...)\n注：\nfunc：自定义函数\nparm1：func中的参数1（$(1)）\nparm2: func中的参数2（$(2)）\nfunc中的所有参数变量均用,$(1),$(2)...表示\n例：\nreverse = $(2) $(1)\nfoo=$(call reverse ,a,b)\n==&amp;gt;\nfoo=b a\n\n4.origin\n变量源函数，输出变量来源\n源列表：\n&amp;lt;1&amp;gt;undefined:未定义变量\n&amp;lt;2&amp;gt;default:默认定义\n&amp;lt;3&amp;gt;environment:环境变量\n&amp;lt;4&amp;gt;file:makefile中定义的变量\n&amp;lt;5&amp;gt;command line:命令行定义的变量\n&amp;lt;6&amp;gt;override:override重新定义的变量\n&amp;lt;7&amp;gt;automatic:自动化变量\n$(origin &amp;lt;variable&amp;gt;)\n\n5.shell\n调用外部shell命令函数\n$(shell commands)\n例：\nfileslist：=$(shell echo *.c)\n`&lt;/pre&gt;\n\n# 7.Makefile调试功能\n\n## 7.1makefile调试\n\n&lt;pre class=&quot;prettyprint&quot;&gt;&lt;/pre&gt;\n\n## 7.2makefile 源码调试\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`一般方式是通过makefile向源码增加宏定义\nmain.c:\n#ifdef DEBUG\n.....\nMakefile:\n.PHONY: all clean\n\nLINUX_ROOT=$(LINUX_SRC)\n\nobj-m := sil9024.o\n\nall:\n    @make -C $(LINUX_ROOT) M=$(PWD) modules &quot;CFLAGS += -DDEBUG&quot;\n    @cp sil9024.ko ../ko/  -vfr\n\nclean:\n    @make -C $(LINUX_ROOT) M=$(PWD) clean`&lt;/pre&gt;\n\n# 8.隐含规则\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`这里写代码片\n</code></pre><h1 id=\"9-写在后面\"><a href=\"#9-写在后面\" class=\"headerlink\" title=\"9.写在后面\"></a>9.写在后面</h1><p>非常感谢皓哥的《跟我一起写Makefile》，之前看过一点，不过没有机会全部了解，这次基本全部了解过，这是我的一点读书笔记，主要参考的就是皓哥的这本书（姑且算书吧^-^），目的为分析安卓源码中的makefile打基础，所以研究不是很深入，以后有时间再深入了解。</p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/4/23 18:56:25 [原文链接](http://blog.csdn.net/weiniluo/article/details/51136429)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：55 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51136429#comments)\n&lt;/div&gt;\n</code></pre>"},{"title":"[原]SSH端口转发与内网穿透","date":"2016-08-03T17:54:33.000Z","_content":"\n1.内网系统配置：\n\n    localhost$sudo ssh -R 0.0.0.0:port_vps:127.0.0.1:port_local username@vps_ip -p vps_ssh_port\n    port_vps:vps端的转发端口\n    port_local：本地ssh登录端口\n    vps_ssh_port：vps的ssh登录端口\n    `</pre>\n\n    2.vps端配置\n\n    <pre class=\"prettyprint\">`vps_host$vi /etc/ssh/ssh_config\n    +  GatewayPorts yes\n    vps_host$service ssh restart\n\n3.帮助 \n\n[https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/](https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/)\n\n            <div>\n                作者：WEINILUO 发表于2016/8/3 13:54:33 [原文链接](http://blog.csdn.net/weiniluo/article/details/51946721)\n            </div>\n            <div>\n            阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51946721#comments)\n            </div>\n","source":"_posts/原-SSH端口转发与内网穿透.md","raw":"---\ntitle: '[原]SSH端口转发与内网穿透'\ntags: []\ndate: 2016-08-03 13:54:33\n---\n\n1.内网系统配置：\n\n    localhost$sudo ssh -R 0.0.0.0:port_vps:127.0.0.1:port_local username@vps_ip -p vps_ssh_port\n    port_vps:vps端的转发端口\n    port_local：本地ssh登录端口\n    vps_ssh_port：vps的ssh登录端口\n    `</pre>\n\n    2.vps端配置\n\n    <pre class=\"prettyprint\">`vps_host$vi /etc/ssh/ssh_config\n    +  GatewayPorts yes\n    vps_host$service ssh restart\n\n3.帮助 \n\n[https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/](https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/)\n\n            <div>\n                作者：WEINILUO 发表于2016/8/3 13:54:33 [原文链接](http://blog.csdn.net/weiniluo/article/details/51946721)\n            </div>\n            <div>\n            阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51946721#comments)\n            </div>\n","slug":"原-SSH端口转发与内网穿透","published":1,"updated":"2016-10-20T09:59:09.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnoc00003vzs62xmflyxf","content":"<p>1.内网系统配置：</p>\n<pre><code>localhost$sudo ssh -R 0.0.0.0:port_vps:127.0.0.1:port_local username@vps_ip -p vps_ssh_port\nport_vps:vps端的转发端口\nport_local：本地ssh登录端口\nvps_ssh_port：vps的ssh登录端口\n`&lt;/pre&gt;\n\n2.vps端配置\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`vps_host$vi /etc/ssh/ssh_config\n+  GatewayPorts yes\nvps_host$service ssh restart\n</code></pre><p>3.帮助 </p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/8/3 13:54:33 [原文链接](http://blog.csdn.net/weiniluo/article/details/51946721)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51946721#comments)\n&lt;/div&gt;\n</code></pre>","excerpt":"","more":"<p>1.内网系统配置：</p>\n<pre><code>localhost$sudo ssh -R 0.0.0.0:port_vps:127.0.0.1:port_local username@vps_ip -p vps_ssh_port\nport_vps:vps端的转发端口\nport_local：本地ssh登录端口\nvps_ssh_port：vps的ssh登录端口\n`&lt;/pre&gt;\n\n2.vps端配置\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`vps_host$vi /etc/ssh/ssh_config\n+  GatewayPorts yes\nvps_host$service ssh restart\n</code></pre><p>3.帮助 </p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/\">https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/8/3 13:54:33 [原文链接](http://blog.csdn.net/weiniluo/article/details/51946721)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51946721#comments)\n&lt;/div&gt;\n</code></pre>"},{"title":"[原]android系统重启流程分析","date":"2016-05-31T13:40:46.000Z","_content":"\n### 1.reboot命令实现\n\n    ./kernel/arch/alpha/kernel/setup.c:\n    void __init setup_arch(char **cmdline_p){\n    ...\n    if (mdesc-&gt;restart_mode)\n            reboot_setup(&amp;mdesc-&gt;restart_mode);\n    ...\n    if (mdesc-&gt;restart)\n            arm_pm_restart = mdesc-&gt;restart;\n    ...\n    }\n    ./mediatek/platform/mt6572/kernel/core/core.c:\n    MACHINE_START(MT6572, \"MT6572\")\n        .atag_offset    = 0x00000100,\n        .map_io         = mt_map_io,\n        .init_irq       = mt_init_irq,\n        .timer          = &amp;mt6572_timer,\n        .init_machine   = mt_init,\n        .fixup          = mt_fixup,\n        .restart        = arm_machine_restart,\n        .reserve        = mt_reserve,\n    MACHINE_END\n    ./kernel/arch/arm/kernel/process.c:\n    void arm_machine_restart(char mode, const char *cmd){\n    ...\n    arch_reset(mode, cmd);\n    ...\n    }\n    ./mediatek/kernel/kernel/system.c:\n    void arch_reset(char mode, const char *cmd)\n    {\n        char reboot = 0;\n        int res=0;\n        struct wd_api*wd_api = NULL;\n\n        res = get_wd_api(&amp;wd_api);\n        printk(\"arch_reset: cmd = %s\\n\", cmd ? : \"NULL\");\n\n        if (cmd &amp;&amp; !strcmp(cmd, \"charger\")) {\n            /* do nothing */\n        } else if (cmd &amp;&amp; !strcmp(cmd, \"recovery\")) {\n            rtc_mark_recovery();\n        } else if (cmd &amp;&amp; !strcmp(cmd, \"bootloader\")){\n                rtc_mark_fast();    \n        } \n    #ifdef MTK_KERNEL_POWER_OFF_CHARGING\n        else if (cmd &amp;&amp; !strcmp(cmd, \"kpoc\")){\n            rtc_mark_kpoc();\n        }\n    #endif\n        else {\n            reboot = 1;\n            //printk(\"rtc_mark_powerkey\\n\");//zhanglei add\n            //rtc_mark_powerkey();//zhanglei add\n\n        }\n\n        if(res){\n            printk(\"arch_reset, get wd api error %d\\n\",res);\n        } else {\n            wd_api-&gt;wd_sw_reset(reboot);\n        }\n    }\n    arch_reset根据上层传的命令执行不同的动作，最后执行wd_sw_reset(reboot)。\n    ./mediatek/kernel/drivers/wdk/wd_api.c:\n    static int wd_sw_reset(int type)\n    {\n       wdt_arch_reset(type);\n       return 0;\n    }\n    ./mediatek/platform/mt6572/kernel/drivers/wdt/mtk_wdt.c:\n    void wdt_arch_reset(char mode)\n    {\n    ...\n    DRV_WriteReg32(MTK_WDT_RESTART, MTK_WDT_RESTART_KEY);\n    ...\n    }\n    从上可以产出系统重启动作是通过看门狗完成的，如果关闭IPO（快速开关机功能）后，系统重启动作会导致系统完全掉电，内核关闭，看门狗无法正常工作，从而导致系统无法重启。`\n\n    ### 2.开机boot_mode_check\n\n    ass=\"prettyprint\">`preloader:\n    ./mediatek/platform/mt6572/preloader/src/drivers/platform.c:\n    void platform_init(void)\n    {\n    ...\n    g_boot_reason = reason = platform_boot_status();\n    ...\n    }\n    static boot_reason_t platform_boot_status(void)\n    {\n    ...\n    #if defined (MTK_KERNEL_POWER_OFF_CHARGING)\n        ulong begin = get_timer(0);\n        do  {\n            if (rtc_boot_check()) {\n                print(\"%s RTC boot!\\n\", MOD);\n                return BR_RTC;\n            }\n            if(!kpoc_flag)\n                break;\n        } while (get_timer(begin) &lt; 1000 &amp;&amp; kpoc_flag);\n    #else\n        if (rtc_boot_check()) {\n            print(\"%s RTC boot!\\n\", MOD);\n            return BR_RTC;\n        }\n\n    #endif\n    ...\n    }\n    ./mediatek/platform/mt6572/preloader/src/drivers/mt_rtc.c:\n    bool rtc_boot_check(void)\n    {\n    ...\n    if ((pdn1 &amp; 0x0030) == 0x0010) {    /* factory data reset */\n            /* keep bit 4 set until rtc_boot_check() in U-Boot */\n            return true;\n        }\n        //zhanglei add\n        if (pdn1 &amp; 0x0080) {    /*  power on  time */\n            /* keep bit 7 set until rtc_boot_check() in U-Boot */\n            return true;\n        }\n    #if defined (MTK_KERNEL_POWER_OFF_CHARGING)\n        if ((pdn1 &amp; 0x4000) == 0x4000) {   \n            kpoc_flag = true;\n            return false;\n        }\n    #endif\n\n        return false;\n    }\n    通过判断pdn1寄存器的标志位返回是否是真正的启动状态。\n    lk:\n    ./mediatek/platform/mt6572/lk/platform.c:\n    void platform_init(void)\n    {\n    ...\n    #ifndef CFG_POWER_CHARGING\n        /* NOTE: if define CFG_POWER_CHARGING, will rtc_boot_check() in mt65xx_bat_init() */\n        rtc_boot_check(false);\n    #endif\n    ...\n    }\n    ./mediatek/platform/mt6572/lk/mt_rtc.c:\n    bool rtc_boot_check(bool can_alarm_boot)\n    {\n    ...\n        if ((pdn1 &amp; RTC_PDN1_RECOVERY_MASK) == RTC_PDN1_FAC_RESET) {    /* factory data reset */\n            RTC_Write(RTC_PDN1, pdn1 &amp; ~RTC_PDN1_FAC_RESET);\n            rtc_write_trigger();\n            return true;\n        }\n\n        if (pdn1 &amp; 0x0040) {    /* bypass power key detection */\n            RTC_Write(RTC_PDN1, pdn1 &amp; ~0x0040);\n            rtc_write_trigger();\n            return true;\n        }\n        //zhanglei add\n        if (pdn1 &amp; 0x0080) {    /*  power on  time */\n            /* keep bit 7 set until rtc_boot_check() in U-Boot */\n            return true;\n        }\n\n        return false;\n    ...\n    }\n    原理同preloader层。\n\n            \n                作者：WEINILUO 发表于2016/5/31 9:40:46 [原文链接](http://blog.csdn.net/weiniluo/article/details/51539783)\n            \n            \n            阅读：322 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51539783#comments)\n            \n","source":"_posts/原-android系统重启流程分析.md","raw":"---\ntitle: '[原]android系统重启流程分析'\ntags: []\ndate: 2016-05-31 09:40:46\n---\n\n### 1.reboot命令实现\n\n    ./kernel/arch/alpha/kernel/setup.c:\n    void __init setup_arch(char **cmdline_p){\n    ...\n    if (mdesc-&gt;restart_mode)\n            reboot_setup(&amp;mdesc-&gt;restart_mode);\n    ...\n    if (mdesc-&gt;restart)\n            arm_pm_restart = mdesc-&gt;restart;\n    ...\n    }\n    ./mediatek/platform/mt6572/kernel/core/core.c:\n    MACHINE_START(MT6572, \"MT6572\")\n        .atag_offset    = 0x00000100,\n        .map_io         = mt_map_io,\n        .init_irq       = mt_init_irq,\n        .timer          = &amp;mt6572_timer,\n        .init_machine   = mt_init,\n        .fixup          = mt_fixup,\n        .restart        = arm_machine_restart,\n        .reserve        = mt_reserve,\n    MACHINE_END\n    ./kernel/arch/arm/kernel/process.c:\n    void arm_machine_restart(char mode, const char *cmd){\n    ...\n    arch_reset(mode, cmd);\n    ...\n    }\n    ./mediatek/kernel/kernel/system.c:\n    void arch_reset(char mode, const char *cmd)\n    {\n        char reboot = 0;\n        int res=0;\n        struct wd_api*wd_api = NULL;\n\n        res = get_wd_api(&amp;wd_api);\n        printk(\"arch_reset: cmd = %s\\n\", cmd ? : \"NULL\");\n\n        if (cmd &amp;&amp; !strcmp(cmd, \"charger\")) {\n            /* do nothing */\n        } else if (cmd &amp;&amp; !strcmp(cmd, \"recovery\")) {\n            rtc_mark_recovery();\n        } else if (cmd &amp;&amp; !strcmp(cmd, \"bootloader\")){\n                rtc_mark_fast();    \n        } \n    #ifdef MTK_KERNEL_POWER_OFF_CHARGING\n        else if (cmd &amp;&amp; !strcmp(cmd, \"kpoc\")){\n            rtc_mark_kpoc();\n        }\n    #endif\n        else {\n            reboot = 1;\n            //printk(\"rtc_mark_powerkey\\n\");//zhanglei add\n            //rtc_mark_powerkey();//zhanglei add\n\n        }\n\n        if(res){\n            printk(\"arch_reset, get wd api error %d\\n\",res);\n        } else {\n            wd_api-&gt;wd_sw_reset(reboot);\n        }\n    }\n    arch_reset根据上层传的命令执行不同的动作，最后执行wd_sw_reset(reboot)。\n    ./mediatek/kernel/drivers/wdk/wd_api.c:\n    static int wd_sw_reset(int type)\n    {\n       wdt_arch_reset(type);\n       return 0;\n    }\n    ./mediatek/platform/mt6572/kernel/drivers/wdt/mtk_wdt.c:\n    void wdt_arch_reset(char mode)\n    {\n    ...\n    DRV_WriteReg32(MTK_WDT_RESTART, MTK_WDT_RESTART_KEY);\n    ...\n    }\n    从上可以产出系统重启动作是通过看门狗完成的，如果关闭IPO（快速开关机功能）后，系统重启动作会导致系统完全掉电，内核关闭，看门狗无法正常工作，从而导致系统无法重启。`\n\n    ### 2.开机boot_mode_check\n\n    ass=\"prettyprint\">`preloader:\n    ./mediatek/platform/mt6572/preloader/src/drivers/platform.c:\n    void platform_init(void)\n    {\n    ...\n    g_boot_reason = reason = platform_boot_status();\n    ...\n    }\n    static boot_reason_t platform_boot_status(void)\n    {\n    ...\n    #if defined (MTK_KERNEL_POWER_OFF_CHARGING)\n        ulong begin = get_timer(0);\n        do  {\n            if (rtc_boot_check()) {\n                print(\"%s RTC boot!\\n\", MOD);\n                return BR_RTC;\n            }\n            if(!kpoc_flag)\n                break;\n        } while (get_timer(begin) &lt; 1000 &amp;&amp; kpoc_flag);\n    #else\n        if (rtc_boot_check()) {\n            print(\"%s RTC boot!\\n\", MOD);\n            return BR_RTC;\n        }\n\n    #endif\n    ...\n    }\n    ./mediatek/platform/mt6572/preloader/src/drivers/mt_rtc.c:\n    bool rtc_boot_check(void)\n    {\n    ...\n    if ((pdn1 &amp; 0x0030) == 0x0010) {    /* factory data reset */\n            /* keep bit 4 set until rtc_boot_check() in U-Boot */\n            return true;\n        }\n        //zhanglei add\n        if (pdn1 &amp; 0x0080) {    /*  power on  time */\n            /* keep bit 7 set until rtc_boot_check() in U-Boot */\n            return true;\n        }\n    #if defined (MTK_KERNEL_POWER_OFF_CHARGING)\n        if ((pdn1 &amp; 0x4000) == 0x4000) {   \n            kpoc_flag = true;\n            return false;\n        }\n    #endif\n\n        return false;\n    }\n    通过判断pdn1寄存器的标志位返回是否是真正的启动状态。\n    lk:\n    ./mediatek/platform/mt6572/lk/platform.c:\n    void platform_init(void)\n    {\n    ...\n    #ifndef CFG_POWER_CHARGING\n        /* NOTE: if define CFG_POWER_CHARGING, will rtc_boot_check() in mt65xx_bat_init() */\n        rtc_boot_check(false);\n    #endif\n    ...\n    }\n    ./mediatek/platform/mt6572/lk/mt_rtc.c:\n    bool rtc_boot_check(bool can_alarm_boot)\n    {\n    ...\n        if ((pdn1 &amp; RTC_PDN1_RECOVERY_MASK) == RTC_PDN1_FAC_RESET) {    /* factory data reset */\n            RTC_Write(RTC_PDN1, pdn1 &amp; ~RTC_PDN1_FAC_RESET);\n            rtc_write_trigger();\n            return true;\n        }\n\n        if (pdn1 &amp; 0x0040) {    /* bypass power key detection */\n            RTC_Write(RTC_PDN1, pdn1 &amp; ~0x0040);\n            rtc_write_trigger();\n            return true;\n        }\n        //zhanglei add\n        if (pdn1 &amp; 0x0080) {    /*  power on  time */\n            /* keep bit 7 set until rtc_boot_check() in U-Boot */\n            return true;\n        }\n\n        return false;\n    ...\n    }\n    原理同preloader层。\n\n            \n                作者：WEINILUO 发表于2016/5/31 9:40:46 [原文链接](http://blog.csdn.net/weiniluo/article/details/51539783)\n            \n            \n            阅读：322 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51539783#comments)\n            \n","slug":"原-android系统重启流程分析","published":1,"updated":"2016-10-20T10:21:14.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnoc20004vzs6aa16v24l","content":"<h3 id=\"1-reboot命令实现\"><a href=\"#1-reboot命令实现\" class=\"headerlink\" title=\"1.reboot命令实现\"></a>1.reboot命令实现</h3><pre><code>./kernel/arch/alpha/kernel/setup.c:\nvoid __init setup_arch(char **cmdline_p){\n...\nif (mdesc-&amp;gt;restart_mode)\n        reboot_setup(&amp;amp;mdesc-&amp;gt;restart_mode);\n...\nif (mdesc-&amp;gt;restart)\n        arm_pm_restart = mdesc-&amp;gt;restart;\n...\n}\n./mediatek/platform/mt6572/kernel/core/core.c:\nMACHINE_START(MT6572, &quot;MT6572&quot;)\n    .atag_offset    = 0x00000100,\n    .map_io         = mt_map_io,\n    .init_irq       = mt_init_irq,\n    .timer          = &amp;amp;mt6572_timer,\n    .init_machine   = mt_init,\n    .fixup          = mt_fixup,\n    .restart        = arm_machine_restart,\n    .reserve        = mt_reserve,\nMACHINE_END\n./kernel/arch/arm/kernel/process.c:\nvoid arm_machine_restart(char mode, const char *cmd){\n...\narch_reset(mode, cmd);\n...\n}\n./mediatek/kernel/kernel/system.c:\nvoid arch_reset(char mode, const char *cmd)\n{\n    char reboot = 0;\n    int res=0;\n    struct wd_api*wd_api = NULL;\n\n    res = get_wd_api(&amp;amp;wd_api);\n    printk(&quot;arch_reset: cmd = %s\\n&quot;, cmd ? : &quot;NULL&quot;);\n\n    if (cmd &amp;amp;&amp;amp; !strcmp(cmd, &quot;charger&quot;)) {\n        /* do nothing */\n    } else if (cmd &amp;amp;&amp;amp; !strcmp(cmd, &quot;recovery&quot;)) {\n        rtc_mark_recovery();\n    } else if (cmd &amp;amp;&amp;amp; !strcmp(cmd, &quot;bootloader&quot;)){\n            rtc_mark_fast();    \n    } \n#ifdef MTK_KERNEL_POWER_OFF_CHARGING\n    else if (cmd &amp;amp;&amp;amp; !strcmp(cmd, &quot;kpoc&quot;)){\n        rtc_mark_kpoc();\n    }\n#endif\n    else {\n        reboot = 1;\n        //printk(&quot;rtc_mark_powerkey\\n&quot;);//zhanglei add\n        //rtc_mark_powerkey();//zhanglei add\n\n    }\n\n    if(res){\n        printk(&quot;arch_reset, get wd api error %d\\n&quot;,res);\n    } else {\n        wd_api-&amp;gt;wd_sw_reset(reboot);\n    }\n}\narch_reset根据上层传的命令执行不同的动作，最后执行wd_sw_reset(reboot)。\n./mediatek/kernel/drivers/wdk/wd_api.c:\nstatic int wd_sw_reset(int type)\n{\n   wdt_arch_reset(type);\n   return 0;\n}\n./mediatek/platform/mt6572/kernel/drivers/wdt/mtk_wdt.c:\nvoid wdt_arch_reset(char mode)\n{\n...\nDRV_WriteReg32(MTK_WDT_RESTART, MTK_WDT_RESTART_KEY);\n...\n}\n从上可以产出系统重启动作是通过看门狗完成的，如果关闭IPO（快速开关机功能）后，系统重启动作会导致系统完全掉电，内核关闭，看门狗无法正常工作，从而导致系统无法重启。`\n\n### 2.开机boot_mode_check\n\nass=&quot;prettyprint&quot;&gt;`preloader:\n./mediatek/platform/mt6572/preloader/src/drivers/platform.c:\nvoid platform_init(void)\n{\n...\ng_boot_reason = reason = platform_boot_status();\n...\n}\nstatic boot_reason_t platform_boot_status(void)\n{\n...\n#if defined (MTK_KERNEL_POWER_OFF_CHARGING)\n    ulong begin = get_timer(0);\n    do  {\n        if (rtc_boot_check()) {\n            print(&quot;%s RTC boot!\\n&quot;, MOD);\n            return BR_RTC;\n        }\n        if(!kpoc_flag)\n            break;\n    } while (get_timer(begin) &amp;lt; 1000 &amp;amp;&amp;amp; kpoc_flag);\n#else\n    if (rtc_boot_check()) {\n        print(&quot;%s RTC boot!\\n&quot;, MOD);\n        return BR_RTC;\n    }\n\n#endif\n...\n}\n./mediatek/platform/mt6572/preloader/src/drivers/mt_rtc.c:\nbool rtc_boot_check(void)\n{\n...\nif ((pdn1 &amp;amp; 0x0030) == 0x0010) {    /* factory data reset */\n        /* keep bit 4 set until rtc_boot_check() in U-Boot */\n        return true;\n    }\n    //zhanglei add\n    if (pdn1 &amp;amp; 0x0080) {    /*  power on  time */\n        /* keep bit 7 set until rtc_boot_check() in U-Boot */\n        return true;\n    }\n#if defined (MTK_KERNEL_POWER_OFF_CHARGING)\n    if ((pdn1 &amp;amp; 0x4000) == 0x4000) {   \n        kpoc_flag = true;\n        return false;\n    }\n#endif\n\n    return false;\n}\n通过判断pdn1寄存器的标志位返回是否是真正的启动状态。\nlk:\n./mediatek/platform/mt6572/lk/platform.c:\nvoid platform_init(void)\n{\n...\n#ifndef CFG_POWER_CHARGING\n    /* NOTE: if define CFG_POWER_CHARGING, will rtc_boot_check() in mt65xx_bat_init() */\n    rtc_boot_check(false);\n#endif\n...\n}\n./mediatek/platform/mt6572/lk/mt_rtc.c:\nbool rtc_boot_check(bool can_alarm_boot)\n{\n...\n    if ((pdn1 &amp;amp; RTC_PDN1_RECOVERY_MASK) == RTC_PDN1_FAC_RESET) {    /* factory data reset */\n        RTC_Write(RTC_PDN1, pdn1 &amp;amp; ~RTC_PDN1_FAC_RESET);\n        rtc_write_trigger();\n        return true;\n    }\n\n    if (pdn1 &amp;amp; 0x0040) {    /* bypass power key detection */\n        RTC_Write(RTC_PDN1, pdn1 &amp;amp; ~0x0040);\n        rtc_write_trigger();\n        return true;\n    }\n    //zhanglei add\n    if (pdn1 &amp;amp; 0x0080) {    /*  power on  time */\n        /* keep bit 7 set until rtc_boot_check() in U-Boot */\n        return true;\n    }\n\n    return false;\n...\n}\n原理同preloader层。\n\n\n            作者：WEINILUO 发表于2016/5/31 9:40:46 [原文链接](http://blog.csdn.net/weiniluo/article/details/51539783)\n\n\n        阅读：322 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51539783#comments)\n</code></pre>","excerpt":"","more":"<h3 id=\"1-reboot命令实现\"><a href=\"#1-reboot命令实现\" class=\"headerlink\" title=\"1.reboot命令实现\"></a>1.reboot命令实现</h3><pre><code>./kernel/arch/alpha/kernel/setup.c:\nvoid __init setup_arch(char **cmdline_p){\n...\nif (mdesc-&amp;gt;restart_mode)\n        reboot_setup(&amp;amp;mdesc-&amp;gt;restart_mode);\n...\nif (mdesc-&amp;gt;restart)\n        arm_pm_restart = mdesc-&amp;gt;restart;\n...\n}\n./mediatek/platform/mt6572/kernel/core/core.c:\nMACHINE_START(MT6572, &quot;MT6572&quot;)\n    .atag_offset    = 0x00000100,\n    .map_io         = mt_map_io,\n    .init_irq       = mt_init_irq,\n    .timer          = &amp;amp;mt6572_timer,\n    .init_machine   = mt_init,\n    .fixup          = mt_fixup,\n    .restart        = arm_machine_restart,\n    .reserve        = mt_reserve,\nMACHINE_END\n./kernel/arch/arm/kernel/process.c:\nvoid arm_machine_restart(char mode, const char *cmd){\n...\narch_reset(mode, cmd);\n...\n}\n./mediatek/kernel/kernel/system.c:\nvoid arch_reset(char mode, const char *cmd)\n{\n    char reboot = 0;\n    int res=0;\n    struct wd_api*wd_api = NULL;\n\n    res = get_wd_api(&amp;amp;wd_api);\n    printk(&quot;arch_reset: cmd = %s\\n&quot;, cmd ? : &quot;NULL&quot;);\n\n    if (cmd &amp;amp;&amp;amp; !strcmp(cmd, &quot;charger&quot;)) {\n        /* do nothing */\n    } else if (cmd &amp;amp;&amp;amp; !strcmp(cmd, &quot;recovery&quot;)) {\n        rtc_mark_recovery();\n    } else if (cmd &amp;amp;&amp;amp; !strcmp(cmd, &quot;bootloader&quot;)){\n            rtc_mark_fast();    \n    } \n#ifdef MTK_KERNEL_POWER_OFF_CHARGING\n    else if (cmd &amp;amp;&amp;amp; !strcmp(cmd, &quot;kpoc&quot;)){\n        rtc_mark_kpoc();\n    }\n#endif\n    else {\n        reboot = 1;\n        //printk(&quot;rtc_mark_powerkey\\n&quot;);//zhanglei add\n        //rtc_mark_powerkey();//zhanglei add\n\n    }\n\n    if(res){\n        printk(&quot;arch_reset, get wd api error %d\\n&quot;,res);\n    } else {\n        wd_api-&amp;gt;wd_sw_reset(reboot);\n    }\n}\narch_reset根据上层传的命令执行不同的动作，最后执行wd_sw_reset(reboot)。\n./mediatek/kernel/drivers/wdk/wd_api.c:\nstatic int wd_sw_reset(int type)\n{\n   wdt_arch_reset(type);\n   return 0;\n}\n./mediatek/platform/mt6572/kernel/drivers/wdt/mtk_wdt.c:\nvoid wdt_arch_reset(char mode)\n{\n...\nDRV_WriteReg32(MTK_WDT_RESTART, MTK_WDT_RESTART_KEY);\n...\n}\n从上可以产出系统重启动作是通过看门狗完成的，如果关闭IPO（快速开关机功能）后，系统重启动作会导致系统完全掉电，内核关闭，看门狗无法正常工作，从而导致系统无法重启。`\n\n### 2.开机boot_mode_check\n\nass=&quot;prettyprint&quot;&gt;`preloader:\n./mediatek/platform/mt6572/preloader/src/drivers/platform.c:\nvoid platform_init(void)\n{\n...\ng_boot_reason = reason = platform_boot_status();\n...\n}\nstatic boot_reason_t platform_boot_status(void)\n{\n...\n#if defined (MTK_KERNEL_POWER_OFF_CHARGING)\n    ulong begin = get_timer(0);\n    do  {\n        if (rtc_boot_check()) {\n            print(&quot;%s RTC boot!\\n&quot;, MOD);\n            return BR_RTC;\n        }\n        if(!kpoc_flag)\n            break;\n    } while (get_timer(begin) &amp;lt; 1000 &amp;amp;&amp;amp; kpoc_flag);\n#else\n    if (rtc_boot_check()) {\n        print(&quot;%s RTC boot!\\n&quot;, MOD);\n        return BR_RTC;\n    }\n\n#endif\n...\n}\n./mediatek/platform/mt6572/preloader/src/drivers/mt_rtc.c:\nbool rtc_boot_check(void)\n{\n...\nif ((pdn1 &amp;amp; 0x0030) == 0x0010) {    /* factory data reset */\n        /* keep bit 4 set until rtc_boot_check() in U-Boot */\n        return true;\n    }\n    //zhanglei add\n    if (pdn1 &amp;amp; 0x0080) {    /*  power on  time */\n        /* keep bit 7 set until rtc_boot_check() in U-Boot */\n        return true;\n    }\n#if defined (MTK_KERNEL_POWER_OFF_CHARGING)\n    if ((pdn1 &amp;amp; 0x4000) == 0x4000) {   \n        kpoc_flag = true;\n        return false;\n    }\n#endif\n\n    return false;\n}\n通过判断pdn1寄存器的标志位返回是否是真正的启动状态。\nlk:\n./mediatek/platform/mt6572/lk/platform.c:\nvoid platform_init(void)\n{\n...\n#ifndef CFG_POWER_CHARGING\n    /* NOTE: if define CFG_POWER_CHARGING, will rtc_boot_check() in mt65xx_bat_init() */\n    rtc_boot_check(false);\n#endif\n...\n}\n./mediatek/platform/mt6572/lk/mt_rtc.c:\nbool rtc_boot_check(bool can_alarm_boot)\n{\n...\n    if ((pdn1 &amp;amp; RTC_PDN1_RECOVERY_MASK) == RTC_PDN1_FAC_RESET) {    /* factory data reset */\n        RTC_Write(RTC_PDN1, pdn1 &amp;amp; ~RTC_PDN1_FAC_RESET);\n        rtc_write_trigger();\n        return true;\n    }\n\n    if (pdn1 &amp;amp; 0x0040) {    /* bypass power key detection */\n        RTC_Write(RTC_PDN1, pdn1 &amp;amp; ~0x0040);\n        rtc_write_trigger();\n        return true;\n    }\n    //zhanglei add\n    if (pdn1 &amp;amp; 0x0080) {    /*  power on  time */\n        /* keep bit 7 set until rtc_boot_check() in U-Boot */\n        return true;\n    }\n\n    return false;\n...\n}\n原理同preloader层。\n\n\n            作者：WEINILUO 发表于2016/5/31 9:40:46 [原文链接](http://blog.csdn.net/weiniluo/article/details/51539783)\n\n\n        阅读：322 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51539783#comments)\n</code></pre>"},{"title":"[原]c 差缺补漏","date":"2016-08-25T14:08:29.000Z","_content":"\n1.类型转换 \n\n1.1自动转换\n\n    高        double    ←←    float\n    ↑          ↑             \n    ↑         long     \n    ↑          ↑\n    ↑        unsigned\n    ↑          ↑\n    低         int      ←←    char,short`</pre>\n\n    规则：在进行自动类型转换的时候，如果原来的数是无符号数，那么在扩展的时候，高位填充的是0；如果是有符号数，那么高位填充的时符号位！这一点有点类似于“&gt;&gt;”操作符，当无符号数右移的时候，高位填充的是0；有符号数右移的时候，高位填充的是符号位。\n\n    <pre class=\"prettyprint\">`  1 #include &lt;stdio.h&gt;\n      2\n      3 int main()\n      4 {\n      5     char v16s;\n      6     unsigned char v16u;\n      7     int v32s;\n      8     unsigned int v32u;\n      9     v16s=0xfb;\n     10     v16u=(unsigned char)v16s;\n     11     v32s=(int)v16s;\n     12     v32u=(unsigned int)v16s;\n     13     printf(\"v16u:%x,v32s:%x,v32u:%x\\n\",v16u,v32s,v32u);\n     14     v16s=0x0b;\n     15     v32s=(int)v16s;\n     16     v32u=(unsigned int)v16s;\n     17     printf(\"v32s:%x,v32u:%x\\n\",v32s,v32u);\n     18     v32s=0xfffffffb;\n     19     v16s=(char)v32s;\n     20     v16u=(unsigned char)v32s;\n     21     printf(\"v16s:%x,v16u:%x\\n\",v16s,v16u);\n     22     v16s=0xfb;\n     23     v16u=0xfb;\n     24     v32s=(int)v16s;\n     25     v32u=(unsigned char)v16u;\n     26     printf(\"v32s:%x,v32u:%x\\n\",v32s,v32u);\n     27\n     28     return 0;\n     29 }\n\n            <div>\n                作者：WEINILUO 发表于2016/8/25 10:08:29 [原文链接](http://blog.csdn.net/weiniluo/article/details/52303134)\n            </div>\n            <div>\n            阅读：104 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52303134#comments)\n            </div>\n","source":"_posts/原-c-差缺补漏.md","raw":"---\ntitle: '[原]c 差缺补漏'\ntags: []\ndate: 2016-08-25 10:08:29\n---\n\n1.类型转换 \n\n1.1自动转换\n\n    高        double    ←←    float\n    ↑          ↑             \n    ↑         long     \n    ↑          ↑\n    ↑        unsigned\n    ↑          ↑\n    低         int      ←←    char,short`</pre>\n\n    规则：在进行自动类型转换的时候，如果原来的数是无符号数，那么在扩展的时候，高位填充的是0；如果是有符号数，那么高位填充的时符号位！这一点有点类似于“&gt;&gt;”操作符，当无符号数右移的时候，高位填充的是0；有符号数右移的时候，高位填充的是符号位。\n\n    <pre class=\"prettyprint\">`  1 #include &lt;stdio.h&gt;\n      2\n      3 int main()\n      4 {\n      5     char v16s;\n      6     unsigned char v16u;\n      7     int v32s;\n      8     unsigned int v32u;\n      9     v16s=0xfb;\n     10     v16u=(unsigned char)v16s;\n     11     v32s=(int)v16s;\n     12     v32u=(unsigned int)v16s;\n     13     printf(\"v16u:%x,v32s:%x,v32u:%x\\n\",v16u,v32s,v32u);\n     14     v16s=0x0b;\n     15     v32s=(int)v16s;\n     16     v32u=(unsigned int)v16s;\n     17     printf(\"v32s:%x,v32u:%x\\n\",v32s,v32u);\n     18     v32s=0xfffffffb;\n     19     v16s=(char)v32s;\n     20     v16u=(unsigned char)v32s;\n     21     printf(\"v16s:%x,v16u:%x\\n\",v16s,v16u);\n     22     v16s=0xfb;\n     23     v16u=0xfb;\n     24     v32s=(int)v16s;\n     25     v32u=(unsigned char)v16u;\n     26     printf(\"v32s:%x,v32u:%x\\n\",v32s,v32u);\n     27\n     28     return 0;\n     29 }\n\n            <div>\n                作者：WEINILUO 发表于2016/8/25 10:08:29 [原文链接](http://blog.csdn.net/weiniluo/article/details/52303134)\n            </div>\n            <div>\n            阅读：104 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52303134#comments)\n            </div>\n","slug":"原-c-差缺补漏","published":1,"updated":"2016-10-20T09:48:05.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnoc90005vzs6erww14un","content":"<p>1.类型转换 </p>\n<p>1.1自动转换</p>\n<pre><code>高        double    ←←    float\n↑          ↑             \n↑         long     \n↑          ↑\n↑        unsigned\n↑          ↑\n低         int      ←←    char,short`&lt;/pre&gt;\n\n规则：在进行自动类型转换的时候，如果原来的数是无符号数，那么在扩展的时候，高位填充的是0；如果是有符号数，那么高位填充的时符号位！这一点有点类似于“&amp;gt;&amp;gt;”操作符，当无符号数右移的时候，高位填充的是0；有符号数右移的时候，高位填充的是符号位。\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`  1 #include &amp;lt;stdio.h&amp;gt;\n  2\n  3 int main()\n  4 {\n  5     char v16s;\n  6     unsigned char v16u;\n  7     int v32s;\n  8     unsigned int v32u;\n  9     v16s=0xfb;\n 10     v16u=(unsigned char)v16s;\n 11     v32s=(int)v16s;\n 12     v32u=(unsigned int)v16s;\n 13     printf(&quot;v16u:%x,v32s:%x,v32u:%x\\n&quot;,v16u,v32s,v32u);\n 14     v16s=0x0b;\n 15     v32s=(int)v16s;\n 16     v32u=(unsigned int)v16s;\n 17     printf(&quot;v32s:%x,v32u:%x\\n&quot;,v32s,v32u);\n 18     v32s=0xfffffffb;\n 19     v16s=(char)v32s;\n 20     v16u=(unsigned char)v32s;\n 21     printf(&quot;v16s:%x,v16u:%x\\n&quot;,v16s,v16u);\n 22     v16s=0xfb;\n 23     v16u=0xfb;\n 24     v32s=(int)v16s;\n 25     v32u=(unsigned char)v16u;\n 26     printf(&quot;v32s:%x,v32u:%x\\n&quot;,v32s,v32u);\n 27\n 28     return 0;\n 29 }\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/8/25 10:08:29 [原文链接](http://blog.csdn.net/weiniluo/article/details/52303134)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：104 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52303134#comments)\n        &lt;/div&gt;\n</code></pre>","excerpt":"","more":"<p>1.类型转换 </p>\n<p>1.1自动转换</p>\n<pre><code>高        double    ←←    float\n↑          ↑             \n↑         long     \n↑          ↑\n↑        unsigned\n↑          ↑\n低         int      ←←    char,short`&lt;/pre&gt;\n\n规则：在进行自动类型转换的时候，如果原来的数是无符号数，那么在扩展的时候，高位填充的是0；如果是有符号数，那么高位填充的时符号位！这一点有点类似于“&amp;gt;&amp;gt;”操作符，当无符号数右移的时候，高位填充的是0；有符号数右移的时候，高位填充的是符号位。\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`  1 #include &amp;lt;stdio.h&amp;gt;\n  2\n  3 int main()\n  4 {\n  5     char v16s;\n  6     unsigned char v16u;\n  7     int v32s;\n  8     unsigned int v32u;\n  9     v16s=0xfb;\n 10     v16u=(unsigned char)v16s;\n 11     v32s=(int)v16s;\n 12     v32u=(unsigned int)v16s;\n 13     printf(&quot;v16u:%x,v32s:%x,v32u:%x\\n&quot;,v16u,v32s,v32u);\n 14     v16s=0x0b;\n 15     v32s=(int)v16s;\n 16     v32u=(unsigned int)v16s;\n 17     printf(&quot;v32s:%x,v32u:%x\\n&quot;,v32s,v32u);\n 18     v32s=0xfffffffb;\n 19     v16s=(char)v32s;\n 20     v16u=(unsigned char)v32s;\n 21     printf(&quot;v16s:%x,v16u:%x\\n&quot;,v16s,v16u);\n 22     v16s=0xfb;\n 23     v16u=0xfb;\n 24     v32s=(int)v16s;\n 25     v32u=(unsigned char)v16u;\n 26     printf(&quot;v32s:%x,v32u:%x\\n&quot;,v32s,v32u);\n 27\n 28     return 0;\n 29 }\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/8/25 10:08:29 [原文链接](http://blog.csdn.net/weiniluo/article/details/52303134)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：104 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52303134#comments)\n        &lt;/div&gt;\n</code></pre>"},{"title":"[原]linux字符设备驱动初识","date":"2016-05-17T01:09:43.000Z","_content":"\n# 1.设备号申请\n\n    字符设备号申请和注销函数\n    register_chrdev_region/alloc_chrdev_region\n    unregister_chrdev_region`</pre>\n\n    # 2.字符设备注册\n\n    <pre class=\"prettyprint\">`字符设备添加函数\n    cdev_init/cdev_add/cdev_del\n    `</pre>\n\n    # 3.创建/dev设备文件\n\n    <pre class=\"prettyprint\">`1.创建class结构，以便device_create使用，同时在/sys/class/添加设备目录\n    class_create/class_destroy\n    2.在/dev/下添加设备目录,相当于mknod命令\n    #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,26) \n        #define CLASS_DEV_CREATE(class, devt, device, name) \\ \n                device_create(class, device, devt, name) \n    #else\n        #define CLASS_DEV_CREATE(class, devt, device, name) \\ \n                class_device_create(class, device, devt, name) \n    #endif\n\n    #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,26) \n        #define CLASS_DEV_DESTROY(class, devt) \\ \n                device_destroy(class, devt) \n    #else\n        #define CLASS_DEV_DESTROY(class, devt) \\ \n                class_device_destroy(class, devt)\n    #endif`</pre>\n\n    # 4.创建设备属性\n\n    <pre class=\"prettyprint\">`在device_create创建的目录下创建设备属性，作为属性和函数的对应关系\n    device_create_file\n    `</pre>\n\n    # 5.创建/proc设备文件\n\n    <pre class=\"prettyprint\">`在/proc/目录下创建设备文件\n    create_proc_entry\n    `</pre>\n\n    # 6.平台驱动注册\n\n    <pre class=\"prettyprint\">`platform_driver_register`</pre>\n\n    # 7.平台设备文件注册\n\n    <pre class=\"prettyprint\">`在/sys/platform/下注册设备文件\n    platform_device_register\n\n            <div>\n                作者：WEINILUO 发表于2016/5/16 21:09:43 [原文链接](http://blog.csdn.net/weiniluo/article/details/51261676)\n            </div>\n            <div>\n            阅读：141 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51261676#comments)\n            </div>\n","source":"_posts/原-linux字符设备驱动初识.md","raw":"---\ntitle: '[原]linux字符设备驱动初识'\ntags: []\ndate: 2016-05-16 21:09:43\n---\n\n# 1.设备号申请\n\n    字符设备号申请和注销函数\n    register_chrdev_region/alloc_chrdev_region\n    unregister_chrdev_region`</pre>\n\n    # 2.字符设备注册\n\n    <pre class=\"prettyprint\">`字符设备添加函数\n    cdev_init/cdev_add/cdev_del\n    `</pre>\n\n    # 3.创建/dev设备文件\n\n    <pre class=\"prettyprint\">`1.创建class结构，以便device_create使用，同时在/sys/class/添加设备目录\n    class_create/class_destroy\n    2.在/dev/下添加设备目录,相当于mknod命令\n    #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,26) \n        #define CLASS_DEV_CREATE(class, devt, device, name) \\ \n                device_create(class, device, devt, name) \n    #else\n        #define CLASS_DEV_CREATE(class, devt, device, name) \\ \n                class_device_create(class, device, devt, name) \n    #endif\n\n    #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,26) \n        #define CLASS_DEV_DESTROY(class, devt) \\ \n                device_destroy(class, devt) \n    #else\n        #define CLASS_DEV_DESTROY(class, devt) \\ \n                class_device_destroy(class, devt)\n    #endif`</pre>\n\n    # 4.创建设备属性\n\n    <pre class=\"prettyprint\">`在device_create创建的目录下创建设备属性，作为属性和函数的对应关系\n    device_create_file\n    `</pre>\n\n    # 5.创建/proc设备文件\n\n    <pre class=\"prettyprint\">`在/proc/目录下创建设备文件\n    create_proc_entry\n    `</pre>\n\n    # 6.平台驱动注册\n\n    <pre class=\"prettyprint\">`platform_driver_register`</pre>\n\n    # 7.平台设备文件注册\n\n    <pre class=\"prettyprint\">`在/sys/platform/下注册设备文件\n    platform_device_register\n\n            <div>\n                作者：WEINILUO 发表于2016/5/16 21:09:43 [原文链接](http://blog.csdn.net/weiniluo/article/details/51261676)\n            </div>\n            <div>\n            阅读：141 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51261676#comments)\n            </div>\n","slug":"原-linux字符设备驱动初识","published":1,"updated":"2016-10-20T10:00:20.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnocc0006vzs686p3sbpo","content":"<h1 id=\"1-设备号申请\"><a href=\"#1-设备号申请\" class=\"headerlink\" title=\"1.设备号申请\"></a>1.设备号申请</h1><pre><code>字符设备号申请和注销函数\nregister_chrdev_region/alloc_chrdev_region\nunregister_chrdev_region`&lt;/pre&gt;\n\n# 2.字符设备注册\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`字符设备添加函数\ncdev_init/cdev_add/cdev_del\n`&lt;/pre&gt;\n\n# 3.创建/dev设备文件\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.创建class结构，以便device_create使用，同时在/sys/class/添加设备目录\nclass_create/class_destroy\n2.在/dev/下添加设备目录,相当于mknod命令\n#if LINUX_VERSION_CODE &amp;gt;= KERNEL_VERSION(2,6,26) \n    #define CLASS_DEV_CREATE(class, devt, device, name) \\ \n            device_create(class, device, devt, name) \n#else\n    #define CLASS_DEV_CREATE(class, devt, device, name) \\ \n            class_device_create(class, device, devt, name) \n#endif\n\n#if LINUX_VERSION_CODE &amp;gt;= KERNEL_VERSION(2,6,26) \n    #define CLASS_DEV_DESTROY(class, devt) \\ \n            device_destroy(class, devt) \n#else\n    #define CLASS_DEV_DESTROY(class, devt) \\ \n            class_device_destroy(class, devt)\n#endif`&lt;/pre&gt;\n\n# 4.创建设备属性\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`在device_create创建的目录下创建设备属性，作为属性和函数的对应关系\ndevice_create_file\n`&lt;/pre&gt;\n\n# 5.创建/proc设备文件\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`在/proc/目录下创建设备文件\ncreate_proc_entry\n`&lt;/pre&gt;\n\n# 6.平台驱动注册\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`platform_driver_register`&lt;/pre&gt;\n\n# 7.平台设备文件注册\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`在/sys/platform/下注册设备文件\nplatform_device_register\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/5/16 21:09:43 [原文链接](http://blog.csdn.net/weiniluo/article/details/51261676)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：141 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51261676#comments)\n        &lt;/div&gt;\n</code></pre>","excerpt":"","more":"<h1 id=\"1-设备号申请\"><a href=\"#1-设备号申请\" class=\"headerlink\" title=\"1.设备号申请\"></a>1.设备号申请</h1><pre><code>字符设备号申请和注销函数\nregister_chrdev_region/alloc_chrdev_region\nunregister_chrdev_region`&lt;/pre&gt;\n\n# 2.字符设备注册\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`字符设备添加函数\ncdev_init/cdev_add/cdev_del\n`&lt;/pre&gt;\n\n# 3.创建/dev设备文件\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.创建class结构，以便device_create使用，同时在/sys/class/添加设备目录\nclass_create/class_destroy\n2.在/dev/下添加设备目录,相当于mknod命令\n#if LINUX_VERSION_CODE &amp;gt;= KERNEL_VERSION(2,6,26) \n    #define CLASS_DEV_CREATE(class, devt, device, name) \\ \n            device_create(class, device, devt, name) \n#else\n    #define CLASS_DEV_CREATE(class, devt, device, name) \\ \n            class_device_create(class, device, devt, name) \n#endif\n\n#if LINUX_VERSION_CODE &amp;gt;= KERNEL_VERSION(2,6,26) \n    #define CLASS_DEV_DESTROY(class, devt) \\ \n            device_destroy(class, devt) \n#else\n    #define CLASS_DEV_DESTROY(class, devt) \\ \n            class_device_destroy(class, devt)\n#endif`&lt;/pre&gt;\n\n# 4.创建设备属性\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`在device_create创建的目录下创建设备属性，作为属性和函数的对应关系\ndevice_create_file\n`&lt;/pre&gt;\n\n# 5.创建/proc设备文件\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`在/proc/目录下创建设备文件\ncreate_proc_entry\n`&lt;/pre&gt;\n\n# 6.平台驱动注册\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`platform_driver_register`&lt;/pre&gt;\n\n# 7.平台设备文件注册\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`在/sys/platform/下注册设备文件\nplatform_device_register\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/5/16 21:09:43 [原文链接](http://blog.csdn.net/weiniluo/article/details/51261676)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：141 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51261676#comments)\n        &lt;/div&gt;\n</code></pre>"},{"title":"[原]list_for_each_entry深入理解","date":"2016-08-03T18:49:58.000Z","_content":"\n在内核编程中经常会遇到list_for_each_entry(pos, head, member)，今天深入分析一下list_for_each_entry在内核中是如何定义的。 \n\nlist_for_each_entry主要作用是遍历给定类型的链表，被定义在include/linux/list.h中：\n\n    /**\n     * list_for_each_entry  -   iterate over list of given type\n     * @pos:    the type * to use as a loop cursor.\n     * @head:   the head for your list.\n     * @member: the name of the list_struct within the struct.\n     */\n    #define list_for_each_entry(pos, head, member)              \\\n        for (pos = list_entry((head)-&gt;next, typeof(*pos), member);  \\\n             &amp;pos-&gt;member != (head);    \\\n             pos = list_entry(pos-&gt;member.next, typeof(*pos), member))`\n\n    接着需要理解list_entry，list_entry的作用是获取条目的结构类型，同样被定义在include/linux/list.h中：\n\n    ass=\"prettyprint\">`/**\n     * list_entry - get the struct for this entry\n     * @ptr:    the &amp;struct list_head pointer.\n     * @type:   the type of the struct this is embedded in.\n     * @member: the name of the list_struct within the struct.\n     */\n    #define list_entry(ptr, type, member) \\\n        container_of(ptr, type, member)`\n\n    container_of作用是通过结构体成员变量的地址和结构体成员变量名以及结构体类型获取该结构体变量的地址，被定义在include/linux/kernel.h中：\n\n    ass=\"prettyprint\">`/**\n     * container_of - cast a member of a structure out to the containing structure\n     * @ptr:    the pointer to the member.\n     * @type:   the type of the container struct this is embedded in.\n     * @member: the name of the member within the struct.\n     *\n     */\n    #define container_of(ptr, type, member) ({          \\\n        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \\\n        (type *)( (char *)__mptr - offsetof(type,member) );})`\n\n    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \n\n    typeof是c    语言的一个新拓展，有多重用法，主要用于得到其参数的类型，参数可以是表达式，函数，类型等，这里表示获取成员member的类型。 \n\n    这里定义的局部指针变量__mptr被赋值为member的地址。\n\n    (type _)( (char _)__mptr - offsetof(type,member) ); \n\n     (char *)__mptr：将__mptr转换为字节类型地址。 \n\n    offsetof(type, member)的作用是返回member在type中的偏移，其在include/linux/stddef.h中的定义如下：\n\n    ass=\"prettyprint\">`#ifdef __compiler_offsetof\n    #define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)\n    #else\n    #define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)\n    #endif\n\n用实际的结构体成员变量的地址减去成员变量在结构体中的偏移地址，自然就得到该结构体变量的起始地址，最终得到(type*)类型的指针。\n\n            \n                作者：WEINILUO 发表于2016/8/3 14:49:58 [原文链接](http://blog.csdn.net/weiniluo/article/details/52103145)\n            \n            \n            阅读：114 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52103145#comments)\n            \n","source":"_posts/原-list-for-each-entry深入理解.md","raw":"---\ntitle: '[原]list_for_each_entry深入理解'\ntags: []\ndate: 2016-08-03 14:49:58\n---\n\n在内核编程中经常会遇到list_for_each_entry(pos, head, member)，今天深入分析一下list_for_each_entry在内核中是如何定义的。 \n\nlist_for_each_entry主要作用是遍历给定类型的链表，被定义在include/linux/list.h中：\n\n    /**\n     * list_for_each_entry  -   iterate over list of given type\n     * @pos:    the type * to use as a loop cursor.\n     * @head:   the head for your list.\n     * @member: the name of the list_struct within the struct.\n     */\n    #define list_for_each_entry(pos, head, member)              \\\n        for (pos = list_entry((head)-&gt;next, typeof(*pos), member);  \\\n             &amp;pos-&gt;member != (head);    \\\n             pos = list_entry(pos-&gt;member.next, typeof(*pos), member))`\n\n    接着需要理解list_entry，list_entry的作用是获取条目的结构类型，同样被定义在include/linux/list.h中：\n\n    ass=\"prettyprint\">`/**\n     * list_entry - get the struct for this entry\n     * @ptr:    the &amp;struct list_head pointer.\n     * @type:   the type of the struct this is embedded in.\n     * @member: the name of the list_struct within the struct.\n     */\n    #define list_entry(ptr, type, member) \\\n        container_of(ptr, type, member)`\n\n    container_of作用是通过结构体成员变量的地址和结构体成员变量名以及结构体类型获取该结构体变量的地址，被定义在include/linux/kernel.h中：\n\n    ass=\"prettyprint\">`/**\n     * container_of - cast a member of a structure out to the containing structure\n     * @ptr:    the pointer to the member.\n     * @type:   the type of the container struct this is embedded in.\n     * @member: the name of the member within the struct.\n     *\n     */\n    #define container_of(ptr, type, member) ({          \\\n        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \\\n        (type *)( (char *)__mptr - offsetof(type,member) );})`\n\n    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \n\n    typeof是c    语言的一个新拓展，有多重用法，主要用于得到其参数的类型，参数可以是表达式，函数，类型等，这里表示获取成员member的类型。 \n\n    这里定义的局部指针变量__mptr被赋值为member的地址。\n\n    (type _)( (char _)__mptr - offsetof(type,member) ); \n\n     (char *)__mptr：将__mptr转换为字节类型地址。 \n\n    offsetof(type, member)的作用是返回member在type中的偏移，其在include/linux/stddef.h中的定义如下：\n\n    ass=\"prettyprint\">`#ifdef __compiler_offsetof\n    #define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)\n    #else\n    #define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)\n    #endif\n\n用实际的结构体成员变量的地址减去成员变量在结构体中的偏移地址，自然就得到该结构体变量的起始地址，最终得到(type*)类型的指针。\n\n            \n                作者：WEINILUO 发表于2016/8/3 14:49:58 [原文链接](http://blog.csdn.net/weiniluo/article/details/52103145)\n            \n            \n            阅读：114 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52103145#comments)\n            \n","slug":"原-list-for-each-entry深入理解","published":1,"updated":"2016-10-20T09:38:00.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnocf0007vzs654d94exa","content":"<p>在内核编程中经常会遇到list_for_each_entry(pos, head, member)，今天深入分析一下list_for_each_entry在内核中是如何定义的。 </p>\n<p>list_for_each_entry主要作用是遍历给定类型的链表，被定义在include/linux/list.h中：</p>\n<pre><code>/**\n * list_for_each_entry  -   iterate over list of given type\n * @pos:    the type * to use as a loop cursor.\n * @head:   the head for your list.\n * @member: the name of the list_struct within the struct.\n */\n#define list_for_each_entry(pos, head, member)              \\\n    for (pos = list_entry((head)-&amp;gt;next, typeof(*pos), member);  \\\n         &amp;amp;pos-&amp;gt;member != (head);    \\\n         pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member))`\n\n接着需要理解list_entry，list_entry的作用是获取条目的结构类型，同样被定义在include/linux/list.h中：\n\nass=&quot;prettyprint&quot;&gt;`/**\n * list_entry - get the struct for this entry\n * @ptr:    the &amp;amp;struct list_head pointer.\n * @type:   the type of the struct this is embedded in.\n * @member: the name of the list_struct within the struct.\n */\n#define list_entry(ptr, type, member) \\\n    container_of(ptr, type, member)`\n\ncontainer_of作用是通过结构体成员变量的地址和结构体成员变量名以及结构体类型获取该结构体变量的地址，被定义在include/linux/kernel.h中：\n\nass=&quot;prettyprint&quot;&gt;`/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:    the pointer to the member.\n * @type:   the type of the container struct this is embedded in.\n * @member: the name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) ({          \\\n    const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr);    \\\n    (type *)( (char *)__mptr - offsetof(type,member) );})`\n\nconst typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr); \n\ntypeof是c    语言的一个新拓展，有多重用法，主要用于得到其参数的类型，参数可以是表达式，函数，类型等，这里表示获取成员member的类型。 \n\n这里定义的局部指针变量__mptr被赋值为member的地址。\n\n(type _)( (char _)__mptr - offsetof(type,member) ); \n\n (char *)__mptr：将__mptr转换为字节类型地址。 \n\noffsetof(type, member)的作用是返回member在type中的偏移，其在include/linux/stddef.h中的定义如下：\n\nass=&quot;prettyprint&quot;&gt;`#ifdef __compiler_offsetof\n#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)\n#else\n#define offsetof(TYPE, MEMBER) ((size_t) &amp;amp;((TYPE *)0)-&amp;gt;MEMBER)\n#endif\n</code></pre><p>用实际的结构体成员变量的地址减去成员变量在结构体中的偏移地址，自然就得到该结构体变量的起始地址，最终得到(type*)类型的指针。</p>\n<pre><code>    作者：WEINILUO 发表于2016/8/3 14:49:58 [原文链接](http://blog.csdn.net/weiniluo/article/details/52103145)\n\n\n阅读：114 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52103145#comments)\n</code></pre>","excerpt":"","more":"<p>在内核编程中经常会遇到list_for_each_entry(pos, head, member)，今天深入分析一下list_for_each_entry在内核中是如何定义的。 </p>\n<p>list_for_each_entry主要作用是遍历给定类型的链表，被定义在include/linux/list.h中：</p>\n<pre><code>/**\n * list_for_each_entry  -   iterate over list of given type\n * @pos:    the type * to use as a loop cursor.\n * @head:   the head for your list.\n * @member: the name of the list_struct within the struct.\n */\n#define list_for_each_entry(pos, head, member)              \\\n    for (pos = list_entry((head)-&amp;gt;next, typeof(*pos), member);  \\\n         &amp;amp;pos-&amp;gt;member != (head);    \\\n         pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member))`\n\n接着需要理解list_entry，list_entry的作用是获取条目的结构类型，同样被定义在include/linux/list.h中：\n\nass=&quot;prettyprint&quot;&gt;`/**\n * list_entry - get the struct for this entry\n * @ptr:    the &amp;amp;struct list_head pointer.\n * @type:   the type of the struct this is embedded in.\n * @member: the name of the list_struct within the struct.\n */\n#define list_entry(ptr, type, member) \\\n    container_of(ptr, type, member)`\n\ncontainer_of作用是通过结构体成员变量的地址和结构体成员变量名以及结构体类型获取该结构体变量的地址，被定义在include/linux/kernel.h中：\n\nass=&quot;prettyprint&quot;&gt;`/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:    the pointer to the member.\n * @type:   the type of the container struct this is embedded in.\n * @member: the name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) ({          \\\n    const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr);    \\\n    (type *)( (char *)__mptr - offsetof(type,member) );})`\n\nconst typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr); \n\ntypeof是c    语言的一个新拓展，有多重用法，主要用于得到其参数的类型，参数可以是表达式，函数，类型等，这里表示获取成员member的类型。 \n\n这里定义的局部指针变量__mptr被赋值为member的地址。\n\n(type _)( (char _)__mptr - offsetof(type,member) ); \n\n (char *)__mptr：将__mptr转换为字节类型地址。 \n\noffsetof(type, member)的作用是返回member在type中的偏移，其在include/linux/stddef.h中的定义如下：\n\nass=&quot;prettyprint&quot;&gt;`#ifdef __compiler_offsetof\n#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)\n#else\n#define offsetof(TYPE, MEMBER) ((size_t) &amp;amp;((TYPE *)0)-&amp;gt;MEMBER)\n#endif\n</code></pre><p>用实际的结构体成员变量的地址减去成员变量在结构体中的偏移地址，自然就得到该结构体变量的起始地址，最终得到(type*)类型的指针。</p>\n<pre><code>    作者：WEINILUO 发表于2016/8/3 14:49:58 [原文链接](http://blog.csdn.net/weiniluo/article/details/52103145)\n\n\n阅读：114 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52103145#comments)\n</code></pre>"},{"title":"[原]shell  初识","date":"2016-06-29T15:06:30.000Z","_content":"\n### 1.shell简介\n\n#### 1.1 shell\n\n    Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。\n    Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。`</pre>\n\n    #### 1.2 shell脚本\n\n    <pre class=\"prettyprint\">`Shell 脚本（shell script），是一种为shell编写的脚本程序。`</pre>\n\n    #### 1.3shell类型\n\n    <pre class=\"prettyprint\">`bash\n    csh\n    dash\n    ksh\n    ....`</pre>\n\n    ### 2.shell入门\n\n    #### 2.1编写第一个shell脚本\n\n    <pre class=\"prettyprint\">`test.sh:\n    #!/bin/bash\n    echo \"Hello World !\"\n\n    注：\n        #!为一个约定的标记，指定shell的相应类型，用什么解释器执行`</pre>\n\n    #### 2.2执行脚本\n\n    <pre class=\"prettyprint\">`1.\n        #chmod +x test.sh\n        #./test.sh\n    2.\n        /bin/bash test.sh\n    `</pre>\n\n    ### 3.shell 变量\n\n    #### 3.1变量定义\n\n    <pre class=\"prettyprint\">`var=val\n    var=\"val\"\n    var='val'\n    循环赋值：\n    for file in 'ls /etc'\n    规则：\n    1.变量定义时，不使用$符号；\n    2.变量名与等号之间不能有空格；\n    3.首个字符必须为字母（a-z，A-Z）；\n    4.中间不能有空格，可以使用下划线（_）；\n    5.不能使用标点符号；\n    6.不能使用bash里的关键字（可用help命令查看保留关键字）。`</pre>\n\n    #### 3.2使用变量\n\n    <pre class=\"prettyprint\">`var=val\n    echo $var\n    echo $(var)`</pre>\n\n    #### 3.3只读变量\n\n    <pre class=\"prettyprint\">`通过readonly关键字声明：\n    var=val\n    readonly var`</pre>\n\n    #### 3.4删除变量\n\n    <pre class=\"prettyprint\">`通过unset关键字声明：\n    var=val\n    unset var`</pre>\n\n    #### 3.5变量类型\n\n    <pre class=\"prettyprint\">`环境变量： 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n\n    局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n\n    shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行`</pre>\n\n    #### 3.6shell字符串\n\n    <pre class=\"prettyprint\">`1.字符串声明：\n    单引号：\n        str='string'\n        单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；\n        单引号字串中不能出现单引号（对单引号使用转义符后也不行）。\n    双引号：\n        str=\"string\"\n        双引号里可以有变量；\n        双引号里可以出现转义字符\n    无引：\n        str=string\n    2.拼接字符串：\n        your_name=\"qinjx\"\n        greeting=\"hello, \"$your_name\" !\"\n        greeting_1=\"hello, ${your_name} !\"\n        echo $greeting $greeting_1\n    3.获取字符串长度：\n        string=\"abcd\"\n        echo ${#string} #输出 4\n    4.提取子字符串：\n        string=\"runoob is a great site\"\n        echo ${string:1:4} # 输出 unoo\n    5.查找子字符串：\n        string=\"runoob is a great company\"\n        echo `expr index \"$string\" is`  # 输出 8\n        注意： 以上脚本中 \"`\" 是反引号，而不是单引号 \"'\"。`</pre>\n\n    #### 3.7shell数组\n\n    <pre class=\"prettyprint\">`bash支持一维数组（不支持多维数组），并且没有限定数组的大小。\n    1.定义数组\n        array=(val0 val1 val2 ...)\n\n        array_name=(\n        value0\n        value1\n        value2\n        value3\n        )\n\n        array_name[0]=value0\n        array_name[1]=value1\n        array_name[n]=valuen\n    2.读取数组\n        ${array[index]}\n        通过\"@\"获得数组中的所有元素：\n        echo ${array[@]}\n    3.获取数组长度\n        获取数组元素个数：\n        length=${#array[@]}\n        length=${#array[*]}\n        获得单个数组元素的长度：\n        length=${#array[n]}`</pre>\n\n    #### 3.8shell注释\n\n    <pre class=\"prettyprint\">`1.以\"#\"开头行表示shell注释行\n    2.shell无多行注释操作，只能每行行头添加\"#\"`</pre>\n\n    ### 4.Shell 传递参数\n\n    #### 4.1传递参数使用\n\n    <pre class=\"prettyprint\">`我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……\n    例：\n    test.sh:\n    #!/bin/bash\n    echo \"Shell 传递参数实例！\";\n    echo \"执行的文件名：$0\";\n    echo \"第一个参数为：$1\";\n    echo \"第二个参数为：$2\";\n    echo \"第三个参数为：$3\";\n\n    效果：\n    $ ./test.sh 1 2 3\n    Shell 传递参数实例！\n    执行的文件名：test.sh\n    第一个参数为：1\n    第二个参数为：2\n    第三个参数为：3`</pre>\n\n    #### 4.2特殊参数\n\n    <pre class=\"prettyprint\">`$# 传递到脚本的参数个数\n    $* 以一个单字符串显示所有向脚本传递的参数。\n        如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。\n    $$    脚本运行的当前进程ID号\n    $! 后台运行的最后一个进程的ID号\n    $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。\n        如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。\n    $- 显示Shell使用的当前选项，与set命令功能相同。\n    $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。\n\n    注：\n    $* 与 $@ 区别：\n    相同点：都是引用所有参数。\n    不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \" * \" 等价于 \"1 2 3\"（传递了一个参数），而 \"@\" 等价于 \"1\" \"2\" \"3\"（传递了三个参数）。\n    例：\n    test.sh:\n    #!/bin/bash\n    \n    echo \"-- \\$* 演示 ---\"\n    for i in \"$*\"; do\n        echo $i\n    done\n\n    echo \"-- \\$@ 演示 ---\"\n    for i in \"$@\"; do\n        echo $i\n    done\n\n    效果：\n    $ ./test.sh 1 2 3\n    -- $* 演示 ---\n    1 2 3\n    -- $@ 演示 ---\n    1\n    2\n    3`</pre>\n\n    ### 5.shell基本运算符\n\n    <pre class=\"prettyprint\">`原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。\n    expr 是一款表达式计算工具，使用它能完成表达式的求值操作。\n    注意\n    1.使用的是反引号 ` 而不是单引号 '；\n    2.表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。\n    例：\n    test.sh:\n    #!/bin/bash\n\n    val=`expr 2 + 2`\n    echo \"两数之和为 : $val\"`</pre>\n\n    #### 5.1 算数运算符\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th align=\"left\">举例</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>+</td>\n      <td align=\"left\">加法</td>\n      <td align=\"left\">`expr b` 结果为 30。</td>\n    </tr>\n    <tr>\n      <td>-</td>\n      <td align=\"left\">减法</td>\n      <td align=\"left\">`expr b` 结果为 10。</td>\n    </tr>\n    <tr>\n      <td>*</td>\n      <td align=\"left\">乘法</td>\n      <td align=\"left\">`expr b` 结果为  200。</td>\n    </tr>\n    <tr>\n      <td>/</td>\n      <td align=\"left\">除法</td>\n      <td align=\"left\">`expr a` 结果为 2。</td>\n    </tr>\n    <tr>\n      <td>%</td>\n      <td align=\"left\">取余</td>\n      <td align=\"left\">`expr a` 结果为 0。</td>\n    </tr>\n    <tr>\n      <td>=</td>\n      <td align=\"left\">赋值</td>\n      <td align=\"left\">a=$b 将把变量 b 的值赋给 a。</td>\n    </tr>\n    <tr>\n      <td>==</td>\n      <td align=\"left\">相等。用于比较两个数字，相同则返回 true。</td>\n      <td align=\"left\">[ b ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>!=</td>\n      <td align=\"left\">不相等。用于比较两个数字，不相同则返回 true。</td>\n      <td align=\"left\">[ b ] 返回 true。</td>\n    </tr>\n    </tbody></table>\n\n    #### 5.2 关系运算符\n\n    关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th align=\"left\">返回值</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>-eq</td>\n      <td align=\"left\">检测两个数是否相等，相等返回 true。</td>\n      <td align=\"left\">[  $b ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-ne</td>\n      <td align=\"left\">检测两个数是否相等，不相等返回 true。</td>\n      <td align=\"left\">[  $b ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-gt</td>\n      <td align=\"left\">检测左边的数是否大于右边的，如果是，则返回 true。</td>\n      <td align=\"left\">[  $b ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-lt</td>\n      <td align=\"left\">检测左边的数是否小于右边的，如果是，则返回 true。</td>\n      <td align=\"left\">[  $b ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-ge</td>\n      <td align=\"left\">检测左边的数是否大等于右边的，如果是，则返回 true。</td>\n      <td align=\"left\">[ $b ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-le</td>\n      <td align=\"left\">检测左边的数是否小于等于右边的，如果是，则返回 true。</td>\n      <td align=\"left\">[  $b ] 返回 true。</td>\n    </tr>\n    </tbody></table>\n\n    #### 5.3 布尔运算符\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th align=\"left\">举例</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>!</td>\n      <td align=\"left\">非运算，表达式为 true 则返回 false，否则返回 true。</td>\n      <td align=\"left\">[ ! false ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-o</td>\n      <td align=\"left\">或运算，有一个表达式为 true 则返回 true。</td>\n      <td align=\"left\">[  20 -o $b -gt 100 ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-a</td>\n      <td align=\"left\">与运算，两个表达式都为 true 才返回 true。</td>\n      <td align=\"left\">[  20 -a $b -gt 100 ] 返回 false。</td>\n    </tr>\n    </tbody></table>\n\n    #### 5.4 逻辑运算符\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th>举例</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>&amp;&amp;</td>\n      <td align=\"left\">逻辑的 AND</td>\n      <td>[[  100 &amp;&amp; $b -gt 100 ]] 返回 false</td>\n    </tr>\n    <tr>\n      <td>||</td>\n      <td align=\"left\">逻辑的 OR</td>\n      <td>[[  100 ||  100 ]] 返回 true</td>\n    </tr>\n    </tbody></table>\n\n    #### 5.5 字符串运算符\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th align=\"left\">举例</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>=</td>\n      <td align=\"left\">检测两个字符串是否相等，相等返回 true。</td>\n      <td align=\"left\">[ b ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>!=</td>\n      <td align=\"left\">检测两个字符串是否相等，不相等返回 true。</td>\n      <td align=\"left\">[ b ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-z</td>\n      <td align=\"left\">检测字符串长度是否为0，为0返回 true。</td>\n      <td align=\"left\">[ -z $a ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-n</td>\n      <td align=\"left\">检测字符串长度是否为0，不为0返回 true。</td>\n      <td align=\"left\">[ -n $a ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>str</td>\n      <td align=\"left\">检测字符串是否为空，不为空返回 true。</td>\n      <td align=\"left\">[ $a ] 返回 true。</td>\n    </tr>\n    </tbody></table>\n\n    #### 5.6 文件测试运算符\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th align=\"left\">举例</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>-b file</td>\n      <td align=\"left\">检测文件是否是块设备文件，如果是，则返回 true。</td>\n      <td align=\"left\">[ -b $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-c file</td>\n      <td align=\"left\">检测文件是否是字符设备文件，如果是，则返回 true。</td>\n      <td align=\"left\">[ -c $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-d file</td>\n      <td align=\"left\">检测文件是否是目录，如果是，则返回 true。</td>\n      <td align=\"left\">[ -d $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-f file</td>\n      <td align=\"left\">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>\n      <td align=\"left\">[ -f $file ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-g file</td>\n      <td align=\"left\">检测文件是否设置了 SGID 位，如果是，则返回 true。</td>\n      <td align=\"left\">[ -g $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-k file</td>\n      <td align=\"left\">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>\n      <td align=\"left\">[ -k $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-p file</td>\n      <td align=\"left\">检测文件是否是具名管道，如果是，则返回 true。</td>\n      <td align=\"left\">[ -p $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-u file</td>\n      <td align=\"left\">检测文件是否设置了 SUID 位，如果是，则返回 true。</td>\n      <td align=\"left\">[ -u $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-r file</td>\n      <td align=\"left\">检测文件是否可读，如果是，则返回 true。</td>\n      <td align=\"left\">[ -r $file ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-w file</td>\n      <td align=\"left\">检测文件是否可写，如果是，则返回 true。</td>\n      <td align=\"left\">[ -w $file ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-x file</td>\n      <td align=\"left\">检测文件是否可执行，如果是，则返回 true。</td>\n      <td align=\"left\">[ -x $file ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-s file</td>\n      <td align=\"left\">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>\n      <td align=\"left\">[ -s $file ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-e file</td>\n      <td align=\"left\">检测文件（包括目录）是否存在，如果是，则返回 true。</td>\n      <td align=\"left\">[ -e $file ] 返回 true。</td>\n    </tr>\n    </tbody></table>\n\n    ### 6.shell echo命令\n\n    #### 6.1 显示普通字符串\n\n    <pre class=\"prettyprint\">`echo \"It is a test\"\n    echo It is a test`</pre>\n\n    #### 6.2 显示转义字符\n\n    <pre class=\"prettyprint\">`echo \"\\\"It is a test\\\"\"`</pre>\n\n    #### 6.3 显示变量\n\n    <pre class=\"prettyprint\">`#!/bin/sh\n    read name \n    echo \"$name It is a test\"`</pre>\n\n    #### 6.4 显示换行\n\n    <pre class=\"prettyprint\">`echo -e \"OK! \\n\" # -e 开启转义\n    echo \"It it a test\"`</pre>\n\n    #### 6.5 显示不换行\n\n    <pre class=\"prettyprint\">`#!/bin/sh\n    echo -e \"OK! \\c\" # -e 开启转义 \\c 不换行\n    echo \"It is a test\"`</pre>\n\n    #### 6.6 显示结果定向至文件\n\n    <pre class=\"prettyprint\">`echo \"It is a test\" &gt; myfile`</pre>\n\n    #### 6.7 原样输出字符串，不进行转义或取变量(用单引号)\n\n    <pre class=\"prettyprint\">`echo '$name\\\"'`</pre>\n\n    #### 6.8 显示命令执行结果\n\n    <pre class=\"prettyprint\">`echo `date`\n    注意是反引号，适用于执行相关命令。`</pre>\n\n    ### 7\\. shell printf命令\n\n    <pre class=\"prettyprint\">`1.printf语法\n        printf format-string [arguments ...]\n    例：\n    test.sh:\n    #!/bin/bash\n    \n    printf \"%-10s %-8s %-4s\\n\" 姓名 性别 体重kg  \n    printf \"%-10s %-8s %-4.2f\\n\" 郭靖 男 66.1234 \n    printf \"%-10s %-8s %-4.2f\\n\" 杨过 男 48.6543 \n    printf \"%-10s %-8s %-4.2f\\n\" 郭芙 女 47.9876 \n\n    格式符使用同C语言的printf函数。`</pre>\n\n    ### 7\\. shell test命令\n\n    Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。\n\n    #### 7.1 数值测试\n\n    <table>\n    <thead>\n    <tr>\n      <th>参数</th>\n      <th align=\"left\">说明</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>-eq</td>\n      <td align=\"left\">等于则为真</td>\n    </tr>\n    <tr>\n      <td>-ne</td>\n      <td align=\"left\">不等于则为真</td>\n    </tr>\n    <tr>\n      <td>-gt</td>\n      <td align=\"left\">大于则为真</td>\n    </tr>\n    <tr>\n      <td>-ge</td>\n      <td align=\"left\">大于等于则为真</td>\n    </tr>\n    <tr>\n      <td>-lt</td>\n      <td align=\"left\">小于则为真</td>\n    </tr>\n    <tr>\n      <td>-le</td>\n      <td align=\"left\">小于等于则为真</td>\n    </tr>\n    </tbody></table>\n\n    #### 7.2 字符串测试\n\n    <table>\n    <thead>\n    <tr>\n      <th>参数</th>\n      <th align=\"left\">说明</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>=</td>\n      <td align=\"left\">等于则为真</td>\n    </tr>\n    <tr>\n      <td>!=</td>\n      <td align=\"left\">不相等则为真</td>\n    </tr>\n    <tr>\n      <td>-z 字符串</td>\n      <td align=\"left\">字符串的长度为零则为真</td>\n    </tr>\n    <tr>\n      <td>-n 字符串</td>\n      <td align=\"left\">字符串的长度不为零则为真</td>\n    </tr>\n    </tbody></table>\n\n    #### 7.3 文件测试\n\n    <table>\n    <thead>\n    <tr>\n      <th>参数</th>\n      <th align=\"left\">说明</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>-e 文件名</td>\n      <td align=\"left\">如果文件存在则为真</td>\n    </tr>\n    <tr>\n      <td>-r 文件名</td>\n      <td align=\"left\">如果文件存在且可读则为真</td>\n    </tr>\n    <tr>\n      <td>-w 文件名</td>\n      <td align=\"left\">如果文件存在且可写则为真</td>\n    </tr>\n    <tr>\n      <td>-x 文件名</td>\n      <td align=\"left\">如果文件存在且可执行则为真</td>\n    </tr>\n    <tr>\n      <td>-s 文件名</td>\n      <td align=\"left\">如果文件存在且至少有一个字符则为真</td>\n    </tr>\n    <tr>\n      <td>-d 文件名</td>\n      <td align=\"left\">如果文件存在且为目录则为真</td>\n    </tr>\n    <tr>\n      <td>-f 文件名</td>\n      <td align=\"left\">如果文件存在且为普通文件则为真</td>\n    </tr>\n    <tr>\n      <td>-c 文件名</td>\n      <td align=\"left\">如果文件存在且为字符型特殊文件则为真</td>\n    </tr>\n    <tr>\n      <td>-b 文件名</td>\n      <td align=\"left\">如果文件存在且为块特殊文件则为真</td>\n    </tr>\n    </tbody></table>\n\n    <pre class=\"prettyprint\">`另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：\"!\"最高，\"-a\"次之，\"-o\"最低。例如：\n    #!/bin/bash\n    cd /bin\n    if test -e ./notFile -o -e ./bash\n    then\n        echo '有一个文件存在!'\n    else\n        echo '两个文件都不存在'\n    fi`</pre>\n\n    ### 8.流程控制\n\n    #### 8.1if else\n\n    <pre class=\"prettyprint\">`1.\n        if condition\n        then\n            command1 \n            command2\n            ...\n            commandN \n        fi\n    2.\n        if condition\n        then\n            command1 \n            command2\n            ...\n            commandN\n        else\n            command\n        fi\n    3.\n        if condition1\n        then\n            command1\n        elif condition2 \n        then \n            command2\n        else\n            commandN\n        fi`</pre>\n\n    #### 8.2for\n\n    <pre class=\"prettyprint\">`1.\n        for var in item1 item2 ... itemN\n        do\n            command1\n            command2\n            ...\n            commandN\n        done\n\n    无限循环：\n        for (( ; ; ))\n        do\n            commands\n        done`</pre>\n\n    #### 8.3while\n\n    <pre class=\"prettyprint\">`1.\n        while condition\n        do\n            command\n        done\n    无限循环：\n    1.\n        while :\n        do\n            command\n        done\n    2.\n        while true\n        do\n            command\n        done\n    `</pre>\n\n    #### 8.4case\n\n    <pre class=\"prettyprint\">`1.\n        case 值 in\n        模式1)\n            command1\n            command2\n            ...\n            commandN\n            ;;\n        模式2）\n            command1\n            command2\n            ...\n            commandN\n            ;;\n        esac`</pre>\n\n    #### 8.5until\n\n    <pre class=\"prettyprint\">`1.\n        until condition\n        do\n            command\n        done`</pre>\n\n    ### 8.6 跳出循环\n\n    <pre class=\"prettyprint\">`1.break：适用于所有循环，并且跳出所有循环\n    2.continue：适用于所有循环，跳出当前循环\n    3.esca：仅用于case循环中`</pre>\n\n    ### 9.shell函数\n\n    #### 9.1 shell函数定义\n\n    <pre class=\"prettyprint\">`[ function ] funname [()]\n\n    {\n\n        action;\n\n        [return int;]\n\n    }\n    说明：\n        1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。\n        2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)`</pre>\n\n    #### 9.2 shell 函数参数\n\n    <pre class=\"prettyprint\">`1.\n    在shell函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...\n    例：\n    test.sh:\n\n    #!/bin/bash\n    funWithParam(){\n        echo \"第一个参数为 $1 !\"\n        echo \"第二个参数为 $2 !\"\n        echo \"第十个参数为 $10 !\"\n        echo \"第十个参数为 ${10} !\"\n        echo \"第十一个参数为 ${11} !\"\n        echo \"参数总数有 $# 个!\"\n        echo \"作为一个字符串输出所有参数 $* !\"\n    }\n    funWithParam 1 2 3 4 5 6 7 8 9 34 73\n\n    效果：\n    第一个参数为 1 !\n    第二个参数为 2 !\n    第十个参数为 10 !\n    第十个参数为 34 !\n    第十一个参数为 73 !\n    参数总数有 11 个!\n    作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n\n    注意：\n        $10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。\n\n    2.特殊参数\n        同shell脚本传参相同，请回顾该小节。`</pre>\n\n    ### 10.Shell 输入/输出重定向\n\n    #### 10.1重定向命令表\n\n    <table>\n    <thead>\n    <tr>\n      <th>命令</th>\n      <th align=\"left\">说明</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>command &gt; file</td>\n      <td align=\"left\">将输出重定向到 file。</td>\n    </tr>\n    <tr>\n      <td>command &lt; file</td>\n      <td align=\"left\">将输入重定向到 file。</td>\n    </tr>\n    <tr>\n      <td>command &gt;&gt; file</td>\n      <td align=\"left\">将输出以追加的方式重定向到 file。</td>\n    </tr>\n    <tr>\n      <td>n &gt; file</td>\n      <td align=\"left\">将文件描述符为 n 的文件重定向到 file。</td>\n    </tr>\n    <tr>\n      <td>n &gt;&gt; file</td>\n      <td align=\"left\">将文件描述符为 n 的文件以追加的方式重定向到 file。</td>\n    </tr>\n    <tr>\n      <td>n &gt;&amp; m</td>\n      <td align=\"left\">将输出文件 m 和 n 合并。</td>\n    </tr>\n    <tr>\n      <td>n &lt;&amp; m</td>\n      <td align=\"left\">将输入文件 m 和 n 合并。</td>\n    </tr>\n    <tr>\n      <td>&lt;&lt; tag</td>\n      <td align=\"left\">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>\n    </tr>\n    </tbody></table>\n\n    #### 10.2 Here Document\n\n    <pre class=\"prettyprint\">`Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。\n    它的基本的形式如下：\n    command &lt;&lt; delimiter\n        document\n    delimiter\n    注意：\n        1.结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。\n        2.开始的delimiter前后的空格会被忽略掉。\n    例：\n    test.sh:\n    #!/bin/bash\n    \n    cat &lt;&lt; EOF\n        welcome\n        feison`s blog！\n    EOF\n\n    效果：\n    welcome\n    feison`s blog！`</pre>\n\n    #### 11.shell文件包含\n\n    <pre class=\"prettyprint\">`1.Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。\n    2.文件包含语法格式：\n    . filename   # 注意点号(.)和文件名中间有一空格\n    或\n    source filename\n\n    注意：\n        被包含的文件 test1.sh 不需要可执行权限。`</pre>\n\n    ### 12.写在后面\n\n    <pre>`本文是学习[菜鸟教程shell](http://www.runoob.com/linux/linux-shell.html)的笔记，记录的是本人在shell方面的薄弱点，主要是打基础，方便以后回顾，编写的不够深入和全面，大家如有不同看法可以留言评论，相互交流学习。\n\n            <div>\n                作者：WEINILUO 发表于2016/6/29 11:06:30 [原文链接](http://blog.csdn.net/weiniluo/article/details/51776869)\n            </div>\n            <div>\n            阅读：1954 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51776869#comments)\n            </div>\n","source":"_posts/原-shell-初识.md","raw":"---\ntitle: '[原]shell  初识'\ntags: []\ndate: 2016-06-29 11:06:30\n---\n\n### 1.shell简介\n\n#### 1.1 shell\n\n    Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。\n    Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。`</pre>\n\n    #### 1.2 shell脚本\n\n    <pre class=\"prettyprint\">`Shell 脚本（shell script），是一种为shell编写的脚本程序。`</pre>\n\n    #### 1.3shell类型\n\n    <pre class=\"prettyprint\">`bash\n    csh\n    dash\n    ksh\n    ....`</pre>\n\n    ### 2.shell入门\n\n    #### 2.1编写第一个shell脚本\n\n    <pre class=\"prettyprint\">`test.sh:\n    #!/bin/bash\n    echo \"Hello World !\"\n\n    注：\n        #!为一个约定的标记，指定shell的相应类型，用什么解释器执行`</pre>\n\n    #### 2.2执行脚本\n\n    <pre class=\"prettyprint\">`1.\n        #chmod +x test.sh\n        #./test.sh\n    2.\n        /bin/bash test.sh\n    `</pre>\n\n    ### 3.shell 变量\n\n    #### 3.1变量定义\n\n    <pre class=\"prettyprint\">`var=val\n    var=\"val\"\n    var='val'\n    循环赋值：\n    for file in 'ls /etc'\n    规则：\n    1.变量定义时，不使用$符号；\n    2.变量名与等号之间不能有空格；\n    3.首个字符必须为字母（a-z，A-Z）；\n    4.中间不能有空格，可以使用下划线（_）；\n    5.不能使用标点符号；\n    6.不能使用bash里的关键字（可用help命令查看保留关键字）。`</pre>\n\n    #### 3.2使用变量\n\n    <pre class=\"prettyprint\">`var=val\n    echo $var\n    echo $(var)`</pre>\n\n    #### 3.3只读变量\n\n    <pre class=\"prettyprint\">`通过readonly关键字声明：\n    var=val\n    readonly var`</pre>\n\n    #### 3.4删除变量\n\n    <pre class=\"prettyprint\">`通过unset关键字声明：\n    var=val\n    unset var`</pre>\n\n    #### 3.5变量类型\n\n    <pre class=\"prettyprint\">`环境变量： 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n\n    局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n\n    shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行`</pre>\n\n    #### 3.6shell字符串\n\n    <pre class=\"prettyprint\">`1.字符串声明：\n    单引号：\n        str='string'\n        单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；\n        单引号字串中不能出现单引号（对单引号使用转义符后也不行）。\n    双引号：\n        str=\"string\"\n        双引号里可以有变量；\n        双引号里可以出现转义字符\n    无引：\n        str=string\n    2.拼接字符串：\n        your_name=\"qinjx\"\n        greeting=\"hello, \"$your_name\" !\"\n        greeting_1=\"hello, ${your_name} !\"\n        echo $greeting $greeting_1\n    3.获取字符串长度：\n        string=\"abcd\"\n        echo ${#string} #输出 4\n    4.提取子字符串：\n        string=\"runoob is a great site\"\n        echo ${string:1:4} # 输出 unoo\n    5.查找子字符串：\n        string=\"runoob is a great company\"\n        echo `expr index \"$string\" is`  # 输出 8\n        注意： 以上脚本中 \"`\" 是反引号，而不是单引号 \"'\"。`</pre>\n\n    #### 3.7shell数组\n\n    <pre class=\"prettyprint\">`bash支持一维数组（不支持多维数组），并且没有限定数组的大小。\n    1.定义数组\n        array=(val0 val1 val2 ...)\n\n        array_name=(\n        value0\n        value1\n        value2\n        value3\n        )\n\n        array_name[0]=value0\n        array_name[1]=value1\n        array_name[n]=valuen\n    2.读取数组\n        ${array[index]}\n        通过\"@\"获得数组中的所有元素：\n        echo ${array[@]}\n    3.获取数组长度\n        获取数组元素个数：\n        length=${#array[@]}\n        length=${#array[*]}\n        获得单个数组元素的长度：\n        length=${#array[n]}`</pre>\n\n    #### 3.8shell注释\n\n    <pre class=\"prettyprint\">`1.以\"#\"开头行表示shell注释行\n    2.shell无多行注释操作，只能每行行头添加\"#\"`</pre>\n\n    ### 4.Shell 传递参数\n\n    #### 4.1传递参数使用\n\n    <pre class=\"prettyprint\">`我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……\n    例：\n    test.sh:\n    #!/bin/bash\n    echo \"Shell 传递参数实例！\";\n    echo \"执行的文件名：$0\";\n    echo \"第一个参数为：$1\";\n    echo \"第二个参数为：$2\";\n    echo \"第三个参数为：$3\";\n\n    效果：\n    $ ./test.sh 1 2 3\n    Shell 传递参数实例！\n    执行的文件名：test.sh\n    第一个参数为：1\n    第二个参数为：2\n    第三个参数为：3`</pre>\n\n    #### 4.2特殊参数\n\n    <pre class=\"prettyprint\">`$# 传递到脚本的参数个数\n    $* 以一个单字符串显示所有向脚本传递的参数。\n        如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。\n    $$    脚本运行的当前进程ID号\n    $! 后台运行的最后一个进程的ID号\n    $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。\n        如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。\n    $- 显示Shell使用的当前选项，与set命令功能相同。\n    $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。\n\n    注：\n    $* 与 $@ 区别：\n    相同点：都是引用所有参数。\n    不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 \" * \" 等价于 \"1 2 3\"（传递了一个参数），而 \"@\" 等价于 \"1\" \"2\" \"3\"（传递了三个参数）。\n    例：\n    test.sh:\n    #!/bin/bash\n    \n    echo \"-- \\$* 演示 ---\"\n    for i in \"$*\"; do\n        echo $i\n    done\n\n    echo \"-- \\$@ 演示 ---\"\n    for i in \"$@\"; do\n        echo $i\n    done\n\n    效果：\n    $ ./test.sh 1 2 3\n    -- $* 演示 ---\n    1 2 3\n    -- $@ 演示 ---\n    1\n    2\n    3`</pre>\n\n    ### 5.shell基本运算符\n\n    <pre class=\"prettyprint\">`原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。\n    expr 是一款表达式计算工具，使用它能完成表达式的求值操作。\n    注意\n    1.使用的是反引号 ` 而不是单引号 '；\n    2.表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。\n    例：\n    test.sh:\n    #!/bin/bash\n\n    val=`expr 2 + 2`\n    echo \"两数之和为 : $val\"`</pre>\n\n    #### 5.1 算数运算符\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th align=\"left\">举例</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>+</td>\n      <td align=\"left\">加法</td>\n      <td align=\"left\">`expr b` 结果为 30。</td>\n    </tr>\n    <tr>\n      <td>-</td>\n      <td align=\"left\">减法</td>\n      <td align=\"left\">`expr b` 结果为 10。</td>\n    </tr>\n    <tr>\n      <td>*</td>\n      <td align=\"left\">乘法</td>\n      <td align=\"left\">`expr b` 结果为  200。</td>\n    </tr>\n    <tr>\n      <td>/</td>\n      <td align=\"left\">除法</td>\n      <td align=\"left\">`expr a` 结果为 2。</td>\n    </tr>\n    <tr>\n      <td>%</td>\n      <td align=\"left\">取余</td>\n      <td align=\"left\">`expr a` 结果为 0。</td>\n    </tr>\n    <tr>\n      <td>=</td>\n      <td align=\"left\">赋值</td>\n      <td align=\"left\">a=$b 将把变量 b 的值赋给 a。</td>\n    </tr>\n    <tr>\n      <td>==</td>\n      <td align=\"left\">相等。用于比较两个数字，相同则返回 true。</td>\n      <td align=\"left\">[ b ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>!=</td>\n      <td align=\"left\">不相等。用于比较两个数字，不相同则返回 true。</td>\n      <td align=\"left\">[ b ] 返回 true。</td>\n    </tr>\n    </tbody></table>\n\n    #### 5.2 关系运算符\n\n    关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th align=\"left\">返回值</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>-eq</td>\n      <td align=\"left\">检测两个数是否相等，相等返回 true。</td>\n      <td align=\"left\">[  $b ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-ne</td>\n      <td align=\"left\">检测两个数是否相等，不相等返回 true。</td>\n      <td align=\"left\">[  $b ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-gt</td>\n      <td align=\"left\">检测左边的数是否大于右边的，如果是，则返回 true。</td>\n      <td align=\"left\">[  $b ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-lt</td>\n      <td align=\"left\">检测左边的数是否小于右边的，如果是，则返回 true。</td>\n      <td align=\"left\">[  $b ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-ge</td>\n      <td align=\"left\">检测左边的数是否大等于右边的，如果是，则返回 true。</td>\n      <td align=\"left\">[ $b ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-le</td>\n      <td align=\"left\">检测左边的数是否小于等于右边的，如果是，则返回 true。</td>\n      <td align=\"left\">[  $b ] 返回 true。</td>\n    </tr>\n    </tbody></table>\n\n    #### 5.3 布尔运算符\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th align=\"left\">举例</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>!</td>\n      <td align=\"left\">非运算，表达式为 true 则返回 false，否则返回 true。</td>\n      <td align=\"left\">[ ! false ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-o</td>\n      <td align=\"left\">或运算，有一个表达式为 true 则返回 true。</td>\n      <td align=\"left\">[  20 -o $b -gt 100 ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-a</td>\n      <td align=\"left\">与运算，两个表达式都为 true 才返回 true。</td>\n      <td align=\"left\">[  20 -a $b -gt 100 ] 返回 false。</td>\n    </tr>\n    </tbody></table>\n\n    #### 5.4 逻辑运算符\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th>举例</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>&amp;&amp;</td>\n      <td align=\"left\">逻辑的 AND</td>\n      <td>[[  100 &amp;&amp; $b -gt 100 ]] 返回 false</td>\n    </tr>\n    <tr>\n      <td>||</td>\n      <td align=\"left\">逻辑的 OR</td>\n      <td>[[  100 ||  100 ]] 返回 true</td>\n    </tr>\n    </tbody></table>\n\n    #### 5.5 字符串运算符\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th align=\"left\">举例</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>=</td>\n      <td align=\"left\">检测两个字符串是否相等，相等返回 true。</td>\n      <td align=\"left\">[ b ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>!=</td>\n      <td align=\"left\">检测两个字符串是否相等，不相等返回 true。</td>\n      <td align=\"left\">[ b ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-z</td>\n      <td align=\"left\">检测字符串长度是否为0，为0返回 true。</td>\n      <td align=\"left\">[ -z $a ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-n</td>\n      <td align=\"left\">检测字符串长度是否为0，不为0返回 true。</td>\n      <td align=\"left\">[ -n $a ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>str</td>\n      <td align=\"left\">检测字符串是否为空，不为空返回 true。</td>\n      <td align=\"left\">[ $a ] 返回 true。</td>\n    </tr>\n    </tbody></table>\n\n    #### 5.6 文件测试运算符\n\n    <table>\n    <thead>\n    <tr>\n      <th>运算符</th>\n      <th align=\"left\">说明</th>\n      <th align=\"left\">举例</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>-b file</td>\n      <td align=\"left\">检测文件是否是块设备文件，如果是，则返回 true。</td>\n      <td align=\"left\">[ -b $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-c file</td>\n      <td align=\"left\">检测文件是否是字符设备文件，如果是，则返回 true。</td>\n      <td align=\"left\">[ -c $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-d file</td>\n      <td align=\"left\">检测文件是否是目录，如果是，则返回 true。</td>\n      <td align=\"left\">[ -d $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-f file</td>\n      <td align=\"left\">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>\n      <td align=\"left\">[ -f $file ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-g file</td>\n      <td align=\"left\">检测文件是否设置了 SGID 位，如果是，则返回 true。</td>\n      <td align=\"left\">[ -g $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-k file</td>\n      <td align=\"left\">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>\n      <td align=\"left\">[ -k $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-p file</td>\n      <td align=\"left\">检测文件是否是具名管道，如果是，则返回 true。</td>\n      <td align=\"left\">[ -p $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-u file</td>\n      <td align=\"left\">检测文件是否设置了 SUID 位，如果是，则返回 true。</td>\n      <td align=\"left\">[ -u $file ] 返回 false。</td>\n    </tr>\n    <tr>\n      <td>-r file</td>\n      <td align=\"left\">检测文件是否可读，如果是，则返回 true。</td>\n      <td align=\"left\">[ -r $file ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-w file</td>\n      <td align=\"left\">检测文件是否可写，如果是，则返回 true。</td>\n      <td align=\"left\">[ -w $file ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-x file</td>\n      <td align=\"left\">检测文件是否可执行，如果是，则返回 true。</td>\n      <td align=\"left\">[ -x $file ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-s file</td>\n      <td align=\"left\">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>\n      <td align=\"left\">[ -s $file ] 返回 true。</td>\n    </tr>\n    <tr>\n      <td>-e file</td>\n      <td align=\"left\">检测文件（包括目录）是否存在，如果是，则返回 true。</td>\n      <td align=\"left\">[ -e $file ] 返回 true。</td>\n    </tr>\n    </tbody></table>\n\n    ### 6.shell echo命令\n\n    #### 6.1 显示普通字符串\n\n    <pre class=\"prettyprint\">`echo \"It is a test\"\n    echo It is a test`</pre>\n\n    #### 6.2 显示转义字符\n\n    <pre class=\"prettyprint\">`echo \"\\\"It is a test\\\"\"`</pre>\n\n    #### 6.3 显示变量\n\n    <pre class=\"prettyprint\">`#!/bin/sh\n    read name \n    echo \"$name It is a test\"`</pre>\n\n    #### 6.4 显示换行\n\n    <pre class=\"prettyprint\">`echo -e \"OK! \\n\" # -e 开启转义\n    echo \"It it a test\"`</pre>\n\n    #### 6.5 显示不换行\n\n    <pre class=\"prettyprint\">`#!/bin/sh\n    echo -e \"OK! \\c\" # -e 开启转义 \\c 不换行\n    echo \"It is a test\"`</pre>\n\n    #### 6.6 显示结果定向至文件\n\n    <pre class=\"prettyprint\">`echo \"It is a test\" &gt; myfile`</pre>\n\n    #### 6.7 原样输出字符串，不进行转义或取变量(用单引号)\n\n    <pre class=\"prettyprint\">`echo '$name\\\"'`</pre>\n\n    #### 6.8 显示命令执行结果\n\n    <pre class=\"prettyprint\">`echo `date`\n    注意是反引号，适用于执行相关命令。`</pre>\n\n    ### 7\\. shell printf命令\n\n    <pre class=\"prettyprint\">`1.printf语法\n        printf format-string [arguments ...]\n    例：\n    test.sh:\n    #!/bin/bash\n    \n    printf \"%-10s %-8s %-4s\\n\" 姓名 性别 体重kg  \n    printf \"%-10s %-8s %-4.2f\\n\" 郭靖 男 66.1234 \n    printf \"%-10s %-8s %-4.2f\\n\" 杨过 男 48.6543 \n    printf \"%-10s %-8s %-4.2f\\n\" 郭芙 女 47.9876 \n\n    格式符使用同C语言的printf函数。`</pre>\n\n    ### 7\\. shell test命令\n\n    Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。\n\n    #### 7.1 数值测试\n\n    <table>\n    <thead>\n    <tr>\n      <th>参数</th>\n      <th align=\"left\">说明</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>-eq</td>\n      <td align=\"left\">等于则为真</td>\n    </tr>\n    <tr>\n      <td>-ne</td>\n      <td align=\"left\">不等于则为真</td>\n    </tr>\n    <tr>\n      <td>-gt</td>\n      <td align=\"left\">大于则为真</td>\n    </tr>\n    <tr>\n      <td>-ge</td>\n      <td align=\"left\">大于等于则为真</td>\n    </tr>\n    <tr>\n      <td>-lt</td>\n      <td align=\"left\">小于则为真</td>\n    </tr>\n    <tr>\n      <td>-le</td>\n      <td align=\"left\">小于等于则为真</td>\n    </tr>\n    </tbody></table>\n\n    #### 7.2 字符串测试\n\n    <table>\n    <thead>\n    <tr>\n      <th>参数</th>\n      <th align=\"left\">说明</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>=</td>\n      <td align=\"left\">等于则为真</td>\n    </tr>\n    <tr>\n      <td>!=</td>\n      <td align=\"left\">不相等则为真</td>\n    </tr>\n    <tr>\n      <td>-z 字符串</td>\n      <td align=\"left\">字符串的长度为零则为真</td>\n    </tr>\n    <tr>\n      <td>-n 字符串</td>\n      <td align=\"left\">字符串的长度不为零则为真</td>\n    </tr>\n    </tbody></table>\n\n    #### 7.3 文件测试\n\n    <table>\n    <thead>\n    <tr>\n      <th>参数</th>\n      <th align=\"left\">说明</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>-e 文件名</td>\n      <td align=\"left\">如果文件存在则为真</td>\n    </tr>\n    <tr>\n      <td>-r 文件名</td>\n      <td align=\"left\">如果文件存在且可读则为真</td>\n    </tr>\n    <tr>\n      <td>-w 文件名</td>\n      <td align=\"left\">如果文件存在且可写则为真</td>\n    </tr>\n    <tr>\n      <td>-x 文件名</td>\n      <td align=\"left\">如果文件存在且可执行则为真</td>\n    </tr>\n    <tr>\n      <td>-s 文件名</td>\n      <td align=\"left\">如果文件存在且至少有一个字符则为真</td>\n    </tr>\n    <tr>\n      <td>-d 文件名</td>\n      <td align=\"left\">如果文件存在且为目录则为真</td>\n    </tr>\n    <tr>\n      <td>-f 文件名</td>\n      <td align=\"left\">如果文件存在且为普通文件则为真</td>\n    </tr>\n    <tr>\n      <td>-c 文件名</td>\n      <td align=\"left\">如果文件存在且为字符型特殊文件则为真</td>\n    </tr>\n    <tr>\n      <td>-b 文件名</td>\n      <td align=\"left\">如果文件存在且为块特殊文件则为真</td>\n    </tr>\n    </tbody></table>\n\n    <pre class=\"prettyprint\">`另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：\"!\"最高，\"-a\"次之，\"-o\"最低。例如：\n    #!/bin/bash\n    cd /bin\n    if test -e ./notFile -o -e ./bash\n    then\n        echo '有一个文件存在!'\n    else\n        echo '两个文件都不存在'\n    fi`</pre>\n\n    ### 8.流程控制\n\n    #### 8.1if else\n\n    <pre class=\"prettyprint\">`1.\n        if condition\n        then\n            command1 \n            command2\n            ...\n            commandN \n        fi\n    2.\n        if condition\n        then\n            command1 \n            command2\n            ...\n            commandN\n        else\n            command\n        fi\n    3.\n        if condition1\n        then\n            command1\n        elif condition2 \n        then \n            command2\n        else\n            commandN\n        fi`</pre>\n\n    #### 8.2for\n\n    <pre class=\"prettyprint\">`1.\n        for var in item1 item2 ... itemN\n        do\n            command1\n            command2\n            ...\n            commandN\n        done\n\n    无限循环：\n        for (( ; ; ))\n        do\n            commands\n        done`</pre>\n\n    #### 8.3while\n\n    <pre class=\"prettyprint\">`1.\n        while condition\n        do\n            command\n        done\n    无限循环：\n    1.\n        while :\n        do\n            command\n        done\n    2.\n        while true\n        do\n            command\n        done\n    `</pre>\n\n    #### 8.4case\n\n    <pre class=\"prettyprint\">`1.\n        case 值 in\n        模式1)\n            command1\n            command2\n            ...\n            commandN\n            ;;\n        模式2）\n            command1\n            command2\n            ...\n            commandN\n            ;;\n        esac`</pre>\n\n    #### 8.5until\n\n    <pre class=\"prettyprint\">`1.\n        until condition\n        do\n            command\n        done`</pre>\n\n    ### 8.6 跳出循环\n\n    <pre class=\"prettyprint\">`1.break：适用于所有循环，并且跳出所有循环\n    2.continue：适用于所有循环，跳出当前循环\n    3.esca：仅用于case循环中`</pre>\n\n    ### 9.shell函数\n\n    #### 9.1 shell函数定义\n\n    <pre class=\"prettyprint\">`[ function ] funname [()]\n\n    {\n\n        action;\n\n        [return int;]\n\n    }\n    说明：\n        1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。\n        2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)`</pre>\n\n    #### 9.2 shell 函数参数\n\n    <pre class=\"prettyprint\">`1.\n    在shell函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...\n    例：\n    test.sh:\n\n    #!/bin/bash\n    funWithParam(){\n        echo \"第一个参数为 $1 !\"\n        echo \"第二个参数为 $2 !\"\n        echo \"第十个参数为 $10 !\"\n        echo \"第十个参数为 ${10} !\"\n        echo \"第十一个参数为 ${11} !\"\n        echo \"参数总数有 $# 个!\"\n        echo \"作为一个字符串输出所有参数 $* !\"\n    }\n    funWithParam 1 2 3 4 5 6 7 8 9 34 73\n\n    效果：\n    第一个参数为 1 !\n    第二个参数为 2 !\n    第十个参数为 10 !\n    第十个参数为 34 !\n    第十一个参数为 73 !\n    参数总数有 11 个!\n    作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n\n    注意：\n        $10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。\n\n    2.特殊参数\n        同shell脚本传参相同，请回顾该小节。`</pre>\n\n    ### 10.Shell 输入/输出重定向\n\n    #### 10.1重定向命令表\n\n    <table>\n    <thead>\n    <tr>\n      <th>命令</th>\n      <th align=\"left\">说明</th>\n    </tr>\n    </thead>\n    <tbody><tr>\n      <td>command &gt; file</td>\n      <td align=\"left\">将输出重定向到 file。</td>\n    </tr>\n    <tr>\n      <td>command &lt; file</td>\n      <td align=\"left\">将输入重定向到 file。</td>\n    </tr>\n    <tr>\n      <td>command &gt;&gt; file</td>\n      <td align=\"left\">将输出以追加的方式重定向到 file。</td>\n    </tr>\n    <tr>\n      <td>n &gt; file</td>\n      <td align=\"left\">将文件描述符为 n 的文件重定向到 file。</td>\n    </tr>\n    <tr>\n      <td>n &gt;&gt; file</td>\n      <td align=\"left\">将文件描述符为 n 的文件以追加的方式重定向到 file。</td>\n    </tr>\n    <tr>\n      <td>n &gt;&amp; m</td>\n      <td align=\"left\">将输出文件 m 和 n 合并。</td>\n    </tr>\n    <tr>\n      <td>n &lt;&amp; m</td>\n      <td align=\"left\">将输入文件 m 和 n 合并。</td>\n    </tr>\n    <tr>\n      <td>&lt;&lt; tag</td>\n      <td align=\"left\">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>\n    </tr>\n    </tbody></table>\n\n    #### 10.2 Here Document\n\n    <pre class=\"prettyprint\">`Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。\n    它的基本的形式如下：\n    command &lt;&lt; delimiter\n        document\n    delimiter\n    注意：\n        1.结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。\n        2.开始的delimiter前后的空格会被忽略掉。\n    例：\n    test.sh:\n    #!/bin/bash\n    \n    cat &lt;&lt; EOF\n        welcome\n        feison`s blog！\n    EOF\n\n    效果：\n    welcome\n    feison`s blog！`</pre>\n\n    #### 11.shell文件包含\n\n    <pre class=\"prettyprint\">`1.Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。\n    2.文件包含语法格式：\n    . filename   # 注意点号(.)和文件名中间有一空格\n    或\n    source filename\n\n    注意：\n        被包含的文件 test1.sh 不需要可执行权限。`</pre>\n\n    ### 12.写在后面\n\n    <pre>`本文是学习[菜鸟教程shell](http://www.runoob.com/linux/linux-shell.html)的笔记，记录的是本人在shell方面的薄弱点，主要是打基础，方便以后回顾，编写的不够深入和全面，大家如有不同看法可以留言评论，相互交流学习。\n\n            <div>\n                作者：WEINILUO 发表于2016/6/29 11:06:30 [原文链接](http://blog.csdn.net/weiniluo/article/details/51776869)\n            </div>\n            <div>\n            阅读：1954 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51776869#comments)\n            </div>\n","slug":"原-shell-初识","published":1,"updated":"2016-10-20T09:57:44.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnoco0008vzs6vcvm1173","content":"<h3 id=\"1-shell简介\"><a href=\"#1-shell简介\" class=\"headerlink\" title=\"1.shell简介\"></a>1.shell简介</h3><h4 id=\"1-1-shell\"><a href=\"#1-1-shell\" class=\"headerlink\" title=\"1.1 shell\"></a>1.1 shell</h4><pre><code>Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。\nShell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。`&lt;/pre&gt;\n\n#### 1.2 shell脚本\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`Shell 脚本（shell script），是一种为shell编写的脚本程序。`&lt;/pre&gt;\n\n#### 1.3shell类型\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`bash\ncsh\ndash\nksh\n....`&lt;/pre&gt;\n\n### 2.shell入门\n\n#### 2.1编写第一个shell脚本\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`test.sh:\n#!/bin/bash\necho &quot;Hello World !&quot;\n\n注：\n    #!为一个约定的标记，指定shell的相应类型，用什么解释器执行`&lt;/pre&gt;\n\n#### 2.2执行脚本\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    #chmod +x test.sh\n    #./test.sh\n2.\n    /bin/bash test.sh\n`&lt;/pre&gt;\n\n### 3.shell 变量\n\n#### 3.1变量定义\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`var=val\nvar=&quot;val&quot;\nvar=&apos;val&apos;\n循环赋值：\nfor file in &apos;ls /etc&apos;\n规则：\n1.变量定义时，不使用$符号；\n2.变量名与等号之间不能有空格；\n3.首个字符必须为字母（a-z，A-Z）；\n4.中间不能有空格，可以使用下划线（_）；\n5.不能使用标点符号；\n6.不能使用bash里的关键字（可用help命令查看保留关键字）。`&lt;/pre&gt;\n\n#### 3.2使用变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`var=val\necho $var\necho $(var)`&lt;/pre&gt;\n\n#### 3.3只读变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`通过readonly关键字声明：\nvar=val\nreadonly var`&lt;/pre&gt;\n\n#### 3.4删除变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`通过unset关键字声明：\nvar=val\nunset var`&lt;/pre&gt;\n\n#### 3.5变量类型\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`环境变量： 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n\n局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n\nshell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行`&lt;/pre&gt;\n\n#### 3.6shell字符串\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.字符串声明：\n单引号：\n    str=&apos;string&apos;\n    单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；\n    单引号字串中不能出现单引号（对单引号使用转义符后也不行）。\n双引号：\n    str=&quot;string&quot;\n    双引号里可以有变量；\n    双引号里可以出现转义字符\n无引：\n    str=string\n2.拼接字符串：\n    your_name=&quot;qinjx&quot;\n    greeting=&quot;hello, &quot;$your_name&quot; !&quot;\n    greeting_1=&quot;hello, ${your_name} !&quot;\n    echo $greeting $greeting_1\n3.获取字符串长度：\n    string=&quot;abcd&quot;\n    echo ${#string} #输出 4\n4.提取子字符串：\n    string=&quot;runoob is a great site&quot;\n    echo ${string:1:4} # 输出 unoo\n5.查找子字符串：\n    string=&quot;runoob is a great company&quot;\n    echo `expr index &quot;$string&quot; is`  # 输出 8\n    注意： 以上脚本中 &quot;`&quot; 是反引号，而不是单引号 &quot;&apos;&quot;。`&lt;/pre&gt;\n\n#### 3.7shell数组\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`bash支持一维数组（不支持多维数组），并且没有限定数组的大小。\n1.定义数组\n    array=(val0 val1 val2 ...)\n\n    array_name=(\n    value0\n    value1\n    value2\n    value3\n    )\n\n    array_name[0]=value0\n    array_name[1]=value1\n    array_name[n]=valuen\n2.读取数组\n    ${array[index]}\n    通过&quot;@&quot;获得数组中的所有元素：\n    echo ${array[@]}\n3.获取数组长度\n    获取数组元素个数：\n    length=${#array[@]}\n    length=${#array[*]}\n    获得单个数组元素的长度：\n    length=${#array[n]}`&lt;/pre&gt;\n\n#### 3.8shell注释\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.以&quot;#&quot;开头行表示shell注释行\n2.shell无多行注释操作，只能每行行头添加&quot;#&quot;`&lt;/pre&gt;\n\n### 4.Shell 传递参数\n\n#### 4.1传递参数使用\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……\n例：\ntest.sh:\n#!/bin/bash\necho &quot;Shell 传递参数实例！&quot;;\necho &quot;执行的文件名：$0&quot;;\necho &quot;第一个参数为：$1&quot;;\necho &quot;第二个参数为：$2&quot;;\necho &quot;第三个参数为：$3&quot;;\n\n效果：\n$ ./test.sh 1 2 3\nShell 传递参数实例！\n执行的文件名：test.sh\n第一个参数为：1\n第二个参数为：2\n第三个参数为：3`&lt;/pre&gt;\n\n#### 4.2特殊参数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`$# 传递到脚本的参数个数\n$* 以一个单字符串显示所有向脚本传递的参数。\n    如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。\n$$    脚本运行的当前进程ID号\n$! 后台运行的最后一个进程的ID号\n$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。\n    如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。\n$- 显示Shell使用的当前选项，与set命令功能相同。\n$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。\n\n注：\n$* 与 $@ 区别：\n相同点：都是引用所有参数。\n不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。\n例：\ntest.sh:\n#!/bin/bash\n\necho &quot;-- \\$* 演示 ---&quot;\nfor i in &quot;$*&quot;; do\n    echo $i\ndone\n\necho &quot;-- \\$@ 演示 ---&quot;\nfor i in &quot;$@&quot;; do\n    echo $i\ndone\n\n效果：\n$ ./test.sh 1 2 3\n-- $* 演示 ---\n1 2 3\n-- $@ 演示 ---\n1\n2\n3`&lt;/pre&gt;\n\n### 5.shell基本运算符\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\n注意\n1.使用的是反引号 ` 而不是单引号 &apos;；\n2.表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。\n例：\ntest.sh:\n#!/bin/bash\n\nval=`expr 2 + 2`\necho &quot;两数之和为 : $val&quot;`&lt;/pre&gt;\n\n#### 5.1 算数运算符\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;+&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;加法&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;`expr b` 结果为 30。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;减法&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;`expr b` 结果为 10。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;*&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;乘法&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;`expr b` 结果为  200。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;/&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;除法&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;`expr a` 结果为 2。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;%&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;取余&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;`expr a` 结果为 0。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;赋值&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;a=$b 将把变量 b 的值赋给 a。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;==&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;相等。用于比较两个数字，相同则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ b ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;!=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;不相等。用于比较两个数字，不相同则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ b ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 5.2 关系运算符\n\n关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;返回值&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;-eq&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测两个数是否相等，相等返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  $b ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-ne&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测两个数是否相等，不相等返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  $b ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-gt&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测左边的数是否大于右边的，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  $b ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-lt&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测左边的数是否小于右边的，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  $b ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-ge&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测左边的数是否大等于右边的，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ $b ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-le&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测左边的数是否小于等于右边的，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  $b ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 5.3 布尔运算符\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;!&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;非运算，表达式为 true 则返回 false，否则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ ! false ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-o&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;或运算，有一个表达式为 true 则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  20 -o $b -gt 100 ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-a&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;与运算，两个表达式都为 true 才返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  20 -a $b -gt 100 ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 5.4 逻辑运算符\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;逻辑的 AND&lt;/td&gt;\n  &lt;td&gt;[[  100 &amp;amp;&amp;amp; $b -gt 100 ]] 返回 false&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;||&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;逻辑的 OR&lt;/td&gt;\n  &lt;td&gt;[[  100 ||  100 ]] 返回 true&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 5.5 字符串运算符\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测两个字符串是否相等，相等返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ b ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;!=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测两个字符串是否相等，不相等返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ b ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-z&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测字符串长度是否为0，为0返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -z $a ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-n&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测字符串长度是否为0，不为0返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -n $a ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;str&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测字符串是否为空，不为空返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ $a ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 5.6 文件测试运算符\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;-b file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否是块设备文件，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -b $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-c file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否是字符设备文件，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -c $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-d file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否是目录，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -d $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-f file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -f $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-g file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否设置了 SGID 位，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -g $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-k file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -k $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-p file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否是具名管道，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -p $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-u file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否设置了 SUID 位，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -u $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-r file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否可读，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -r $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-w file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否可写，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -w $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-x file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否可执行，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -x $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-s file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否为空（文件大小是否大于0），不为空返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -s $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-e file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件（包括目录）是否存在，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -e $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n### 6.shell echo命令\n\n#### 6.1 显示普通字符串\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo &quot;It is a test&quot;\necho It is a test`&lt;/pre&gt;\n\n#### 6.2 显示转义字符\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo &quot;\\&quot;It is a test\\&quot;&quot;`&lt;/pre&gt;\n\n#### 6.3 显示变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#!/bin/sh\nread name \necho &quot;$name It is a test&quot;`&lt;/pre&gt;\n\n#### 6.4 显示换行\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo -e &quot;OK! \\n&quot; # -e 开启转义\necho &quot;It it a test&quot;`&lt;/pre&gt;\n\n#### 6.5 显示不换行\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#!/bin/sh\necho -e &quot;OK! \\c&quot; # -e 开启转义 \\c 不换行\necho &quot;It is a test&quot;`&lt;/pre&gt;\n\n#### 6.6 显示结果定向至文件\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo &quot;It is a test&quot; &amp;gt; myfile`&lt;/pre&gt;\n\n#### 6.7 原样输出字符串，不进行转义或取变量(用单引号)\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo &apos;$name\\&quot;&apos;`&lt;/pre&gt;\n\n#### 6.8 显示命令执行结果\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo `date`\n注意是反引号，适用于执行相关命令。`&lt;/pre&gt;\n\n### 7\\. shell printf命令\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.printf语法\n    printf format-string [arguments ...]\n例：\ntest.sh:\n#!/bin/bash\n\nprintf &quot;%-10s %-8s %-4s\\n&quot; 姓名 性别 体重kg  \nprintf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234 \nprintf &quot;%-10s %-8s %-4.2f\\n&quot; 杨过 男 48.6543 \nprintf &quot;%-10s %-8s %-4.2f\\n&quot; 郭芙 女 47.9876 \n\n格式符使用同C语言的printf函数。`&lt;/pre&gt;\n\n### 7\\. shell test命令\n\nShell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。\n\n#### 7.1 数值测试\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;参数&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;-eq&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;等于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-ne&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;不等于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-gt&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;大于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-ge&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;大于等于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-lt&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;小于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-le&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;小于等于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 7.2 字符串测试\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;参数&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;等于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;!=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;不相等则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-z 字符串&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;字符串的长度为零则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-n 字符串&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;字符串的长度不为零则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 7.3 文件测试\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;参数&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;-e 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-r 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且可读则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-w 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且可写则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-x 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且可执行则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-s 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且至少有一个字符则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-d 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且为目录则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-f 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且为普通文件则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-c 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且为字符型特殊文件则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-b 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且为块特殊文件则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：&quot;!&quot;最高，&quot;-a&quot;次之，&quot;-o&quot;最低。例如：\n#!/bin/bash\ncd /bin\nif test -e ./notFile -o -e ./bash\nthen\n    echo &apos;有一个文件存在!&apos;\nelse\n    echo &apos;两个文件都不存在&apos;\nfi`&lt;/pre&gt;\n\n### 8.流程控制\n\n#### 8.1if else\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    if condition\n    then\n        command1 \n        command2\n        ...\n        commandN \n    fi\n2.\n    if condition\n    then\n        command1 \n        command2\n        ...\n        commandN\n    else\n        command\n    fi\n3.\n    if condition1\n    then\n        command1\n    elif condition2 \n    then \n        command2\n    else\n        commandN\n    fi`&lt;/pre&gt;\n\n#### 8.2for\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    for var in item1 item2 ... itemN\n    do\n        command1\n        command2\n        ...\n        commandN\n    done\n\n无限循环：\n    for (( ; ; ))\n    do\n        commands\n    done`&lt;/pre&gt;\n\n#### 8.3while\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    while condition\n    do\n        command\n    done\n无限循环：\n1.\n    while :\n    do\n        command\n    done\n2.\n    while true\n    do\n        command\n    done\n`&lt;/pre&gt;\n\n#### 8.4case\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    case 值 in\n    模式1)\n        command1\n        command2\n        ...\n        commandN\n        ;;\n    模式2）\n        command1\n        command2\n        ...\n        commandN\n        ;;\n    esac`&lt;/pre&gt;\n\n#### 8.5until\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    until condition\n    do\n        command\n    done`&lt;/pre&gt;\n\n### 8.6 跳出循环\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.break：适用于所有循环，并且跳出所有循环\n2.continue：适用于所有循环，跳出当前循环\n3.esca：仅用于case循环中`&lt;/pre&gt;\n\n### 9.shell函数\n\n#### 9.1 shell函数定义\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`[ function ] funname [()]\n\n{\n\n    action;\n\n    [return int;]\n\n}\n说明：\n    1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。\n    2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)`&lt;/pre&gt;\n\n#### 9.2 shell 函数参数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n在shell函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...\n例：\ntest.sh:\n\n#!/bin/bash\nfunWithParam(){\n    echo &quot;第一个参数为 $1 !&quot;\n    echo &quot;第二个参数为 $2 !&quot;\n    echo &quot;第十个参数为 $10 !&quot;\n    echo &quot;第十个参数为 ${10} !&quot;\n    echo &quot;第十一个参数为 ${11} !&quot;\n    echo &quot;参数总数有 $# 个!&quot;\n    echo &quot;作为一个字符串输出所有参数 $* !&quot;\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\n\n效果：\n第一个参数为 1 !\n第二个参数为 2 !\n第十个参数为 10 !\n第十个参数为 34 !\n第十一个参数为 73 !\n参数总数有 11 个!\n作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n\n注意：\n    $10 不能获取第十个参数，获取第十个参数需要${10}。当n&amp;gt;=10时，需要使用${n}来获取参数。\n\n2.特殊参数\n    同shell脚本传参相同，请回顾该小节。`&lt;/pre&gt;\n\n### 10.Shell 输入/输出重定向\n\n#### 10.1重定向命令表\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;命令&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;command &amp;gt; file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将输出重定向到 file。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;command &amp;lt; file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将输入重定向到 file。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;command &amp;gt;&amp;gt; file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将输出以追加的方式重定向到 file。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;n &amp;gt; file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将文件描述符为 n 的文件重定向到 file。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;n &amp;gt;&amp;gt; file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将文件描述符为 n 的文件以追加的方式重定向到 file。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;n &amp;gt;&amp;amp; m&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将输出文件 m 和 n 合并。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;n &amp;lt;&amp;amp; m&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将输入文件 m 和 n 合并。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;&amp;lt;&amp;lt; tag&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将开始标记 tag 和结束标记 tag 之间的内容作为输入。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 10.2 Here Document\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。\n它的基本的形式如下：\ncommand &amp;lt;&amp;lt; delimiter\n    document\ndelimiter\n注意：\n    1.结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。\n    2.开始的delimiter前后的空格会被忽略掉。\n例：\ntest.sh:\n#!/bin/bash\n\ncat &amp;lt;&amp;lt; EOF\n    welcome\n    feison`s blog！\nEOF\n\n效果：\nwelcome\nfeison`s blog！`&lt;/pre&gt;\n\n#### 11.shell文件包含\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。\n2.文件包含语法格式：\n. filename   # 注意点号(.)和文件名中间有一空格\n或\nsource filename\n\n注意：\n    被包含的文件 test1.sh 不需要可执行权限。`&lt;/pre&gt;\n\n### 12.写在后面\n\n&lt;pre&gt;`本文是学习[菜鸟教程shell](http://www.runoob.com/linux/linux-shell.html)的笔记，记录的是本人在shell方面的薄弱点，主要是打基础，方便以后回顾，编写的不够深入和全面，大家如有不同看法可以留言评论，相互交流学习。\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/6/29 11:06:30 [原文链接](http://blog.csdn.net/weiniluo/article/details/51776869)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：1954 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51776869#comments)\n        &lt;/div&gt;\n</code></pre>","excerpt":"","more":"<h3 id=\"1-shell简介\"><a href=\"#1-shell简介\" class=\"headerlink\" title=\"1.shell简介\"></a>1.shell简介</h3><h4 id=\"1-1-shell\"><a href=\"#1-1-shell\" class=\"headerlink\" title=\"1.1 shell\"></a>1.1 shell</h4><pre><code>Shell 是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。\nShell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。`&lt;/pre&gt;\n\n#### 1.2 shell脚本\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`Shell 脚本（shell script），是一种为shell编写的脚本程序。`&lt;/pre&gt;\n\n#### 1.3shell类型\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`bash\ncsh\ndash\nksh\n....`&lt;/pre&gt;\n\n### 2.shell入门\n\n#### 2.1编写第一个shell脚本\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`test.sh:\n#!/bin/bash\necho &quot;Hello World !&quot;\n\n注：\n    #!为一个约定的标记，指定shell的相应类型，用什么解释器执行`&lt;/pre&gt;\n\n#### 2.2执行脚本\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    #chmod +x test.sh\n    #./test.sh\n2.\n    /bin/bash test.sh\n`&lt;/pre&gt;\n\n### 3.shell 变量\n\n#### 3.1变量定义\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`var=val\nvar=&quot;val&quot;\nvar=&apos;val&apos;\n循环赋值：\nfor file in &apos;ls /etc&apos;\n规则：\n1.变量定义时，不使用$符号；\n2.变量名与等号之间不能有空格；\n3.首个字符必须为字母（a-z，A-Z）；\n4.中间不能有空格，可以使用下划线（_）；\n5.不能使用标点符号；\n6.不能使用bash里的关键字（可用help命令查看保留关键字）。`&lt;/pre&gt;\n\n#### 3.2使用变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`var=val\necho $var\necho $(var)`&lt;/pre&gt;\n\n#### 3.3只读变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`通过readonly关键字声明：\nvar=val\nreadonly var`&lt;/pre&gt;\n\n#### 3.4删除变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`通过unset关键字声明：\nvar=val\nunset var`&lt;/pre&gt;\n\n#### 3.5变量类型\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`环境变量： 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n\n局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n\nshell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行`&lt;/pre&gt;\n\n#### 3.6shell字符串\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.字符串声明：\n单引号：\n    str=&apos;string&apos;\n    单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；\n    单引号字串中不能出现单引号（对单引号使用转义符后也不行）。\n双引号：\n    str=&quot;string&quot;\n    双引号里可以有变量；\n    双引号里可以出现转义字符\n无引：\n    str=string\n2.拼接字符串：\n    your_name=&quot;qinjx&quot;\n    greeting=&quot;hello, &quot;$your_name&quot; !&quot;\n    greeting_1=&quot;hello, ${your_name} !&quot;\n    echo $greeting $greeting_1\n3.获取字符串长度：\n    string=&quot;abcd&quot;\n    echo ${#string} #输出 4\n4.提取子字符串：\n    string=&quot;runoob is a great site&quot;\n    echo ${string:1:4} # 输出 unoo\n5.查找子字符串：\n    string=&quot;runoob is a great company&quot;\n    echo `expr index &quot;$string&quot; is`  # 输出 8\n    注意： 以上脚本中 &quot;`&quot; 是反引号，而不是单引号 &quot;&apos;&quot;。`&lt;/pre&gt;\n\n#### 3.7shell数组\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`bash支持一维数组（不支持多维数组），并且没有限定数组的大小。\n1.定义数组\n    array=(val0 val1 val2 ...)\n\n    array_name=(\n    value0\n    value1\n    value2\n    value3\n    )\n\n    array_name[0]=value0\n    array_name[1]=value1\n    array_name[n]=valuen\n2.读取数组\n    ${array[index]}\n    通过&quot;@&quot;获得数组中的所有元素：\n    echo ${array[@]}\n3.获取数组长度\n    获取数组元素个数：\n    length=${#array[@]}\n    length=${#array[*]}\n    获得单个数组元素的长度：\n    length=${#array[n]}`&lt;/pre&gt;\n\n#### 3.8shell注释\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.以&quot;#&quot;开头行表示shell注释行\n2.shell无多行注释操作，只能每行行头添加&quot;#&quot;`&lt;/pre&gt;\n\n### 4.Shell 传递参数\n\n#### 4.1传递参数使用\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……\n例：\ntest.sh:\n#!/bin/bash\necho &quot;Shell 传递参数实例！&quot;;\necho &quot;执行的文件名：$0&quot;;\necho &quot;第一个参数为：$1&quot;;\necho &quot;第二个参数为：$2&quot;;\necho &quot;第三个参数为：$3&quot;;\n\n效果：\n$ ./test.sh 1 2 3\nShell 传递参数实例！\n执行的文件名：test.sh\n第一个参数为：1\n第二个参数为：2\n第三个参数为：3`&lt;/pre&gt;\n\n#### 4.2特殊参数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`$# 传递到脚本的参数个数\n$* 以一个单字符串显示所有向脚本传递的参数。\n    如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。\n$$    脚本运行的当前进程ID号\n$! 后台运行的最后一个进程的ID号\n$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。\n    如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。\n$- 显示Shell使用的当前选项，与set命令功能相同。\n$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。\n\n注：\n$* 与 $@ 区别：\n相同点：都是引用所有参数。\n不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。\n例：\ntest.sh:\n#!/bin/bash\n\necho &quot;-- \\$* 演示 ---&quot;\nfor i in &quot;$*&quot;; do\n    echo $i\ndone\n\necho &quot;-- \\$@ 演示 ---&quot;\nfor i in &quot;$@&quot;; do\n    echo $i\ndone\n\n效果：\n$ ./test.sh 1 2 3\n-- $* 演示 ---\n1 2 3\n-- $@ 演示 ---\n1\n2\n3`&lt;/pre&gt;\n\n### 5.shell基本运算符\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。\nexpr 是一款表达式计算工具，使用它能完成表达式的求值操作。\n注意\n1.使用的是反引号 ` 而不是单引号 &apos;；\n2.表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。\n例：\ntest.sh:\n#!/bin/bash\n\nval=`expr 2 + 2`\necho &quot;两数之和为 : $val&quot;`&lt;/pre&gt;\n\n#### 5.1 算数运算符\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;+&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;加法&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;`expr b` 结果为 30。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;减法&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;`expr b` 结果为 10。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;*&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;乘法&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;`expr b` 结果为  200。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;/&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;除法&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;`expr a` 结果为 2。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;%&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;取余&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;`expr a` 结果为 0。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;赋值&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;a=$b 将把变量 b 的值赋给 a。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;==&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;相等。用于比较两个数字，相同则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ b ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;!=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;不相等。用于比较两个数字，不相同则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ b ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 5.2 关系运算符\n\n关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;返回值&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;-eq&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测两个数是否相等，相等返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  $b ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-ne&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测两个数是否相等，不相等返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  $b ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-gt&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测左边的数是否大于右边的，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  $b ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-lt&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测左边的数是否小于右边的，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  $b ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-ge&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测左边的数是否大等于右边的，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ $b ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-le&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测左边的数是否小于等于右边的，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  $b ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 5.3 布尔运算符\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;!&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;非运算，表达式为 true 则返回 false，否则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ ! false ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-o&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;或运算，有一个表达式为 true 则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  20 -o $b -gt 100 ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-a&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;与运算，两个表达式都为 true 才返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[  20 -a $b -gt 100 ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 5.4 逻辑运算符\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;逻辑的 AND&lt;/td&gt;\n  &lt;td&gt;[[  100 &amp;amp;&amp;amp; $b -gt 100 ]] 返回 false&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;||&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;逻辑的 OR&lt;/td&gt;\n  &lt;td&gt;[[  100 ||  100 ]] 返回 true&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 5.5 字符串运算符\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测两个字符串是否相等，相等返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ b ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;!=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测两个字符串是否相等，不相等返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ b ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-z&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测字符串长度是否为0，为0返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -z $a ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-n&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测字符串长度是否为0，不为0返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -n $a ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;str&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测字符串是否为空，不为空返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ $a ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 5.6 文件测试运算符\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;运算符&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;举例&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;-b file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否是块设备文件，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -b $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-c file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否是字符设备文件，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -c $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-d file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否是目录，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -d $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-f file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -f $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-g file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否设置了 SGID 位，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -g $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-k file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -k $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-p file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否是具名管道，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -p $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-u file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否设置了 SUID 位，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -u $file ] 返回 false。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-r file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否可读，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -r $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-w file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否可写，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -w $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-x file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否可执行，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -x $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-s file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件是否为空（文件大小是否大于0），不为空返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -s $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-e file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;检测文件（包括目录）是否存在，如果是，则返回 true。&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;[ -e $file ] 返回 true。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n### 6.shell echo命令\n\n#### 6.1 显示普通字符串\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo &quot;It is a test&quot;\necho It is a test`&lt;/pre&gt;\n\n#### 6.2 显示转义字符\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo &quot;\\&quot;It is a test\\&quot;&quot;`&lt;/pre&gt;\n\n#### 6.3 显示变量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#!/bin/sh\nread name \necho &quot;$name It is a test&quot;`&lt;/pre&gt;\n\n#### 6.4 显示换行\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo -e &quot;OK! \\n&quot; # -e 开启转义\necho &quot;It it a test&quot;`&lt;/pre&gt;\n\n#### 6.5 显示不换行\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#!/bin/sh\necho -e &quot;OK! \\c&quot; # -e 开启转义 \\c 不换行\necho &quot;It is a test&quot;`&lt;/pre&gt;\n\n#### 6.6 显示结果定向至文件\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo &quot;It is a test&quot; &amp;gt; myfile`&lt;/pre&gt;\n\n#### 6.7 原样输出字符串，不进行转义或取变量(用单引号)\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo &apos;$name\\&quot;&apos;`&lt;/pre&gt;\n\n#### 6.8 显示命令执行结果\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`echo `date`\n注意是反引号，适用于执行相关命令。`&lt;/pre&gt;\n\n### 7\\. shell printf命令\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.printf语法\n    printf format-string [arguments ...]\n例：\ntest.sh:\n#!/bin/bash\n\nprintf &quot;%-10s %-8s %-4s\\n&quot; 姓名 性别 体重kg  \nprintf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234 \nprintf &quot;%-10s %-8s %-4.2f\\n&quot; 杨过 男 48.6543 \nprintf &quot;%-10s %-8s %-4.2f\\n&quot; 郭芙 女 47.9876 \n\n格式符使用同C语言的printf函数。`&lt;/pre&gt;\n\n### 7\\. shell test命令\n\nShell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。\n\n#### 7.1 数值测试\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;参数&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;-eq&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;等于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-ne&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;不等于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-gt&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;大于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-ge&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;大于等于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-lt&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;小于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-le&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;小于等于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 7.2 字符串测试\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;参数&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;等于则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;!=&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;不相等则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-z 字符串&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;字符串的长度为零则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-n 字符串&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;字符串的长度不为零则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 7.3 文件测试\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;参数&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;-e 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-r 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且可读则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-w 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且可写则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-x 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且可执行则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-s 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且至少有一个字符则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-d 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且为目录则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-f 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且为普通文件则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-c 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且为字符型特殊文件则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;-b 文件名&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;如果文件存在且为块特殊文件则为真&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：&quot;!&quot;最高，&quot;-a&quot;次之，&quot;-o&quot;最低。例如：\n#!/bin/bash\ncd /bin\nif test -e ./notFile -o -e ./bash\nthen\n    echo &apos;有一个文件存在!&apos;\nelse\n    echo &apos;两个文件都不存在&apos;\nfi`&lt;/pre&gt;\n\n### 8.流程控制\n\n#### 8.1if else\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    if condition\n    then\n        command1 \n        command2\n        ...\n        commandN \n    fi\n2.\n    if condition\n    then\n        command1 \n        command2\n        ...\n        commandN\n    else\n        command\n    fi\n3.\n    if condition1\n    then\n        command1\n    elif condition2 \n    then \n        command2\n    else\n        commandN\n    fi`&lt;/pre&gt;\n\n#### 8.2for\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    for var in item1 item2 ... itemN\n    do\n        command1\n        command2\n        ...\n        commandN\n    done\n\n无限循环：\n    for (( ; ; ))\n    do\n        commands\n    done`&lt;/pre&gt;\n\n#### 8.3while\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    while condition\n    do\n        command\n    done\n无限循环：\n1.\n    while :\n    do\n        command\n    done\n2.\n    while true\n    do\n        command\n    done\n`&lt;/pre&gt;\n\n#### 8.4case\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    case 值 in\n    模式1)\n        command1\n        command2\n        ...\n        commandN\n        ;;\n    模式2）\n        command1\n        command2\n        ...\n        commandN\n        ;;\n    esac`&lt;/pre&gt;\n\n#### 8.5until\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n    until condition\n    do\n        command\n    done`&lt;/pre&gt;\n\n### 8.6 跳出循环\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.break：适用于所有循环，并且跳出所有循环\n2.continue：适用于所有循环，跳出当前循环\n3.esca：仅用于case循环中`&lt;/pre&gt;\n\n### 9.shell函数\n\n#### 9.1 shell函数定义\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`[ function ] funname [()]\n\n{\n\n    action;\n\n    [return int;]\n\n}\n说明：\n    1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。\n    2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)`&lt;/pre&gt;\n\n#### 9.2 shell 函数参数\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.\n在shell函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...\n例：\ntest.sh:\n\n#!/bin/bash\nfunWithParam(){\n    echo &quot;第一个参数为 $1 !&quot;\n    echo &quot;第二个参数为 $2 !&quot;\n    echo &quot;第十个参数为 $10 !&quot;\n    echo &quot;第十个参数为 ${10} !&quot;\n    echo &quot;第十一个参数为 ${11} !&quot;\n    echo &quot;参数总数有 $# 个!&quot;\n    echo &quot;作为一个字符串输出所有参数 $* !&quot;\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\n\n效果：\n第一个参数为 1 !\n第二个参数为 2 !\n第十个参数为 10 !\n第十个参数为 34 !\n第十一个参数为 73 !\n参数总数有 11 个!\n作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !\n\n注意：\n    $10 不能获取第十个参数，获取第十个参数需要${10}。当n&amp;gt;=10时，需要使用${n}来获取参数。\n\n2.特殊参数\n    同shell脚本传参相同，请回顾该小节。`&lt;/pre&gt;\n\n### 10.Shell 输入/输出重定向\n\n#### 10.1重定向命令表\n\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n  &lt;th&gt;命令&lt;/th&gt;\n  &lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;&lt;tr&gt;\n  &lt;td&gt;command &amp;gt; file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将输出重定向到 file。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;command &amp;lt; file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将输入重定向到 file。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;command &amp;gt;&amp;gt; file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将输出以追加的方式重定向到 file。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;n &amp;gt; file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将文件描述符为 n 的文件重定向到 file。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;n &amp;gt;&amp;gt; file&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将文件描述符为 n 的文件以追加的方式重定向到 file。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;n &amp;gt;&amp;amp; m&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将输出文件 m 和 n 合并。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;n &amp;lt;&amp;amp; m&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将输入文件 m 和 n 合并。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;&amp;lt;&amp;lt; tag&lt;/td&gt;\n  &lt;td align=&quot;left&quot;&gt;将开始标记 tag 和结束标记 tag 之间的内容作为输入。&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;&lt;/table&gt;\n\n#### 10.2 Here Document\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。\n它的基本的形式如下：\ncommand &amp;lt;&amp;lt; delimiter\n    document\ndelimiter\n注意：\n    1.结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。\n    2.开始的delimiter前后的空格会被忽略掉。\n例：\ntest.sh:\n#!/bin/bash\n\ncat &amp;lt;&amp;lt; EOF\n    welcome\n    feison`s blog！\nEOF\n\n效果：\nwelcome\nfeison`s blog！`&lt;/pre&gt;\n\n#### 11.shell文件包含\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。\n2.文件包含语法格式：\n. filename   # 注意点号(.)和文件名中间有一空格\n或\nsource filename\n\n注意：\n    被包含的文件 test1.sh 不需要可执行权限。`&lt;/pre&gt;\n\n### 12.写在后面\n\n&lt;pre&gt;`本文是学习[菜鸟教程shell](http://www.runoob.com/linux/linux-shell.html)的笔记，记录的是本人在shell方面的薄弱点，主要是打基础，方便以后回顾，编写的不够深入和全面，大家如有不同看法可以留言评论，相互交流学习。\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/6/29 11:06:30 [原文链接](http://blog.csdn.net/weiniluo/article/details/51776869)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：1954 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51776869#comments)\n        &lt;/div&gt;\n</code></pre>"},{"title":"[原]ubuntu 定时任务","date":"2016-08-24T17:58:32.000Z","_content":"\n1.编辑/etc/crontab文件\n\n    # /etc/crontab: system-wide crontab\n    # Unlike any other crontab you don't have to run the `crontab'\n    # command to install the new version when you edit this file\n    # and files in /etc/cron.d. These files also have username fields,\n    # that none of the other crontabs do.\n\n    SHELL=/bin/sh\n    PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n\n    # m h dom mon dow user  command\n    17 *    * * *   root    cd / &amp;&amp; run-parts --report /etc/cron.hourly\n    25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )\n    47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )\n    52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )\n    #\n    10 6    * * *   zhanglei run-parts /home/zhanglei/zlwork/script/\n\n    注：\n    1.注释\n        m h dom mon dow user  command\n        m 0-59的数值，*表示任何数值都执行\n        h 0-23的数值，*表示任何数值都执行\n        dom 1-31的数值，*表示任何数值都执行\n        mon 1-12的数值，*表示任何数值都执行\n        dow 0-7的数值，*表示任何数值都执行,0/7代表周日\n        user 表示以某个用户身份执行命令\n        command 需要执行的脚本或命令（直接为命令或脚本文件或者run-parts 脚本文件目录）\n\n    2.或者用crontab -e 为当前用户创建cron任务   \n    3.脚本文件注意PATH引用\n        由于cron是系统进程，脚本的执行经常会受到环境变量的影响，因此需要格外小心，例如我的环境变量：\n        export PATH=~/bin:$PATH:/sbin\n\n2.service cron restart\n\n参考文章： \n\n[http://blog.csdn.net/liu414226580/article/details/16339935](http://blog.csdn.net/liu414226580/article/details/16339935) \n\n[http://blog.csdn.net/wide288/article/details/8765951](http://blog.csdn.net/wide288/article/details/8765951)\n\n            <div>\n                作者：WEINILUO 发表于2016/8/24 13:58:32 [原文链接](http://blog.csdn.net/weiniluo/article/details/52299236)\n            </div>\n            <div>\n            阅读：90 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52299236#comments)\n            </div>\n","source":"_posts/原-ubuntu-定时任务.md","raw":"---\ntitle: '[原]ubuntu 定时任务'\ntags: []\ndate: 2016-08-24 13:58:32\n---\n\n1.编辑/etc/crontab文件\n\n    # /etc/crontab: system-wide crontab\n    # Unlike any other crontab you don't have to run the `crontab'\n    # command to install the new version when you edit this file\n    # and files in /etc/cron.d. These files also have username fields,\n    # that none of the other crontabs do.\n\n    SHELL=/bin/sh\n    PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n\n    # m h dom mon dow user  command\n    17 *    * * *   root    cd / &amp;&amp; run-parts --report /etc/cron.hourly\n    25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )\n    47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )\n    52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )\n    #\n    10 6    * * *   zhanglei run-parts /home/zhanglei/zlwork/script/\n\n    注：\n    1.注释\n        m h dom mon dow user  command\n        m 0-59的数值，*表示任何数值都执行\n        h 0-23的数值，*表示任何数值都执行\n        dom 1-31的数值，*表示任何数值都执行\n        mon 1-12的数值，*表示任何数值都执行\n        dow 0-7的数值，*表示任何数值都执行,0/7代表周日\n        user 表示以某个用户身份执行命令\n        command 需要执行的脚本或命令（直接为命令或脚本文件或者run-parts 脚本文件目录）\n\n    2.或者用crontab -e 为当前用户创建cron任务   \n    3.脚本文件注意PATH引用\n        由于cron是系统进程，脚本的执行经常会受到环境变量的影响，因此需要格外小心，例如我的环境变量：\n        export PATH=~/bin:$PATH:/sbin\n\n2.service cron restart\n\n参考文章： \n\n[http://blog.csdn.net/liu414226580/article/details/16339935](http://blog.csdn.net/liu414226580/article/details/16339935) \n\n[http://blog.csdn.net/wide288/article/details/8765951](http://blog.csdn.net/wide288/article/details/8765951)\n\n            <div>\n                作者：WEINILUO 发表于2016/8/24 13:58:32 [原文链接](http://blog.csdn.net/weiniluo/article/details/52299236)\n            </div>\n            <div>\n            阅读：90 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52299236#comments)\n            </div>\n","slug":"原-ubuntu-定时任务","published":1,"updated":"2016-10-20T10:00:33.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnocs0009vzs6gh4ik75y","content":"<p>1.编辑/etc/crontab文件</p>\n<pre><code># /etc/crontab: system-wide crontab\n# Unlike any other crontab you don&apos;t have to run the `crontab&apos;\n# command to install the new version when you edit this file\n# and files in /etc/cron.d. These files also have username fields,\n# that none of the other crontabs do.\n\nSHELL=/bin/sh\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n\n# m h dom mon dow user  command\n17 *    * * *   root    cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.hourly\n25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.daily )\n47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.weekly )\n52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.monthly )\n#\n10 6    * * *   zhanglei run-parts /home/zhanglei/zlwork/script/\n\n注：\n1.注释\n    m h dom mon dow user  command\n    m 0-59的数值，*表示任何数值都执行\n    h 0-23的数值，*表示任何数值都执行\n    dom 1-31的数值，*表示任何数值都执行\n    mon 1-12的数值，*表示任何数值都执行\n    dow 0-7的数值，*表示任何数值都执行,0/7代表周日\n    user 表示以某个用户身份执行命令\n    command 需要执行的脚本或命令（直接为命令或脚本文件或者run-parts 脚本文件目录）\n\n2.或者用crontab -e 为当前用户创建cron任务   \n3.脚本文件注意PATH引用\n    由于cron是系统进程，脚本的执行经常会受到环境变量的影响，因此需要格外小心，例如我的环境变量：\n    export PATH=~/bin:$PATH:/sbin\n</code></pre><p>2.service cron restart</p>\n<p>参考文章： </p>\n<p><a href=\"http://blog.csdn.net/liu414226580/article/details/16339935\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/liu414226580/article/details/16339935</a> </p>\n<p><a href=\"http://blog.csdn.net/wide288/article/details/8765951\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/wide288/article/details/8765951</a></p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/8/24 13:58:32 [原文链接](http://blog.csdn.net/weiniluo/article/details/52299236)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：90 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52299236#comments)\n&lt;/div&gt;\n</code></pre>","excerpt":"","more":"<p>1.编辑/etc/crontab文件</p>\n<pre><code># /etc/crontab: system-wide crontab\n# Unlike any other crontab you don&apos;t have to run the `crontab&apos;\n# command to install the new version when you edit this file\n# and files in /etc/cron.d. These files also have username fields,\n# that none of the other crontabs do.\n\nSHELL=/bin/sh\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n\n# m h dom mon dow user  command\n17 *    * * *   root    cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.hourly\n25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.daily )\n47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.weekly )\n52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.monthly )\n#\n10 6    * * *   zhanglei run-parts /home/zhanglei/zlwork/script/\n\n注：\n1.注释\n    m h dom mon dow user  command\n    m 0-59的数值，*表示任何数值都执行\n    h 0-23的数值，*表示任何数值都执行\n    dom 1-31的数值，*表示任何数值都执行\n    mon 1-12的数值，*表示任何数值都执行\n    dow 0-7的数值，*表示任何数值都执行,0/7代表周日\n    user 表示以某个用户身份执行命令\n    command 需要执行的脚本或命令（直接为命令或脚本文件或者run-parts 脚本文件目录）\n\n2.或者用crontab -e 为当前用户创建cron任务   \n3.脚本文件注意PATH引用\n    由于cron是系统进程，脚本的执行经常会受到环境变量的影响，因此需要格外小心，例如我的环境变量：\n    export PATH=~/bin:$PATH:/sbin\n</code></pre><p>2.service cron restart</p>\n<p>参考文章： </p>\n<p><a href=\"http://blog.csdn.net/liu414226580/article/details/16339935\">http://blog.csdn.net/liu414226580/article/details/16339935</a> </p>\n<p><a href=\"http://blog.csdn.net/wide288/article/details/8765951\">http://blog.csdn.net/wide288/article/details/8765951</a></p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/8/24 13:58:32 [原文链接](http://blog.csdn.net/weiniluo/article/details/52299236)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：90 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52299236#comments)\n&lt;/div&gt;\n</code></pre>"},{"title":"[原]ubuntu下添加用户","date":"2016-02-25T22:30:18.000Z","_content":"\n    1.$sudo useradd -m -s /bin/bash [username]  //创建登入目录和指定用户的shell\n    2.$sudo passwd [username]   //创建登入密码\n    3.$sudo uermod -g [groupname] [username] //将username加入groupname组\n    例：$sudo usermod -a -G admin username \n    4.$sudo visudo  /etc/sudoers  //为username添加sudo权限（不安全方式）\n    root   ALL=&lt;ALL:ALL&gt; ALL\n    username  ALL=&lt;ALL:ALL&gt; ALL\n    :wq!\n    5.$sudo vi /etc/group     //为username添加sudo权限（安全方式）\n    sudo:x:27:username1,username2,username3\n    :wq\n\n            \n                作者：WEINILUO 发表于2016/2/25 17:30:18 [原文链接](http://blog.csdn.net/weiniluo/article/details/50739367)\n            \n            \n            阅读：85 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/50739367#comments)\n            \n","source":"_posts/原-ubuntu下添加用户.md","raw":"---\ntitle: '[原]ubuntu下添加用户'\ntags: []\ndate: 2016-02-25 17:30:18\n---\n\n    1.$sudo useradd -m -s /bin/bash [username]  //创建登入目录和指定用户的shell\n    2.$sudo passwd [username]   //创建登入密码\n    3.$sudo uermod -g [groupname] [username] //将username加入groupname组\n    例：$sudo usermod -a -G admin username \n    4.$sudo visudo  /etc/sudoers  //为username添加sudo权限（不安全方式）\n    root   ALL=&lt;ALL:ALL&gt; ALL\n    username  ALL=&lt;ALL:ALL&gt; ALL\n    :wq!\n    5.$sudo vi /etc/group     //为username添加sudo权限（安全方式）\n    sudo:x:27:username1,username2,username3\n    :wq\n\n            \n                作者：WEINILUO 发表于2016/2/25 17:30:18 [原文链接](http://blog.csdn.net/weiniluo/article/details/50739367)\n            \n            \n            阅读：85 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/50739367#comments)\n            \n","slug":"原-ubuntu下添加用户","published":1,"updated":"2016-10-20T09:38:37.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnocy000avzs6exzoomsb","content":"<pre><code>1.$sudo useradd -m -s /bin/bash [username]  //创建登入目录和指定用户的shell\n2.$sudo passwd [username]   //创建登入密码\n3.$sudo uermod -g [groupname] [username] //将username加入groupname组\n例：$sudo usermod -a -G admin username \n4.$sudo visudo  /etc/sudoers  //为username添加sudo权限（不安全方式）\nroot   ALL=&amp;lt;ALL:ALL&amp;gt; ALL\nusername  ALL=&amp;lt;ALL:ALL&amp;gt; ALL\n:wq!\n5.$sudo vi /etc/group     //为username添加sudo权限（安全方式）\nsudo:x:27:username1,username2,username3\n:wq\n\n\n            作者：WEINILUO 发表于2016/2/25 17:30:18 [原文链接](http://blog.csdn.net/weiniluo/article/details/50739367)\n\n\n        阅读：85 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/50739367#comments)\n</code></pre>","excerpt":"","more":"<pre><code>1.$sudo useradd -m -s /bin/bash [username]  //创建登入目录和指定用户的shell\n2.$sudo passwd [username]   //创建登入密码\n3.$sudo uermod -g [groupname] [username] //将username加入groupname组\n例：$sudo usermod -a -G admin username \n4.$sudo visudo  /etc/sudoers  //为username添加sudo权限（不安全方式）\nroot   ALL=&amp;lt;ALL:ALL&amp;gt; ALL\nusername  ALL=&amp;lt;ALL:ALL&amp;gt; ALL\n:wq!\n5.$sudo vi /etc/group     //为username添加sudo权限（安全方式）\nsudo:x:27:username1,username2,username3\n:wq\n\n\n            作者：WEINILUO 发表于2016/2/25 17:30:18 [原文链接](http://blog.csdn.net/weiniluo/article/details/50739367)\n\n\n        阅读：85 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/50739367#comments)\n</code></pre>"},{"title":"[原]windows下的adb连接调试","date":"2016-02-26T15:18:38.000Z","_content":"\n1.若输入adb shell出现：\n\n    adb server is out of date.  killing...\n    * daemon started successfully *\n    error: device offline`</pre>\n\n    可能是adb版本较低，请换用较新的adb \n\n    2.若输入adb shell出现：\n\n    <pre class=\"prettyprint\">`error: device unauthorized. Please check the confirmation dialog on your device.\n\n因为手机端没有允许adb调试，需要在手机端确认\n\n            <div>\n                作者：WEINILUO 发表于2016/2/26 10:18:38 [原文链接](http://blog.csdn.net/weiniluo/article/details/50747737)\n            </div>\n            <div>\n            阅读：106 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/50747737#comments)\n            </div>\n","source":"_posts/原-windows下的adb连接调试.md","raw":"---\ntitle: '[原]windows下的adb连接调试'\ntags: []\ndate: 2016-02-26 10:18:38\n---\n\n1.若输入adb shell出现：\n\n    adb server is out of date.  killing...\n    * daemon started successfully *\n    error: device offline`</pre>\n\n    可能是adb版本较低，请换用较新的adb \n\n    2.若输入adb shell出现：\n\n    <pre class=\"prettyprint\">`error: device unauthorized. Please check the confirmation dialog on your device.\n\n因为手机端没有允许adb调试，需要在手机端确认\n\n            <div>\n                作者：WEINILUO 发表于2016/2/26 10:18:38 [原文链接](http://blog.csdn.net/weiniluo/article/details/50747737)\n            </div>\n            <div>\n            阅读：106 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/50747737#comments)\n            </div>\n","slug":"原-windows下的adb连接调试","published":1,"updated":"2016-10-20T09:49:33.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnod1000bvzs6v48kygyd","content":"<p>1.若输入adb shell出现：</p>\n<pre><code>adb server is out of date.  killing...\n* daemon started successfully *\nerror: device offline`&lt;/pre&gt;\n\n可能是adb版本较低，请换用较新的adb \n\n2.若输入adb shell出现：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`error: device unauthorized. Please check the confirmation dialog on your device.\n</code></pre><p>因为手机端没有允许adb调试，需要在手机端确认</p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/2/26 10:18:38 [原文链接](http://blog.csdn.net/weiniluo/article/details/50747737)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：106 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/50747737#comments)\n&lt;/div&gt;\n</code></pre>","excerpt":"","more":"<p>1.若输入adb shell出现：</p>\n<pre><code>adb server is out of date.  killing...\n* daemon started successfully *\nerror: device offline`&lt;/pre&gt;\n\n可能是adb版本较低，请换用较新的adb \n\n2.若输入adb shell出现：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`error: device unauthorized. Please check the confirmation dialog on your device.\n</code></pre><p>因为手机端没有允许adb调试，需要在手机端确认</p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/2/26 10:18:38 [原文链接](http://blog.csdn.net/weiniluo/article/details/50747737)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：106 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/50747737#comments)\n&lt;/div&gt;\n</code></pre>"},{"title":"[原]中断处理","date":"2016-09-29T21:30:10.000Z","_content":"\n### 1 注册中断处理例程\n\n许多设备的内部工作通常是在和处理器完全不同的时间周期里完成的，并且总要比处理器慢，为了不让cpu一直等待外部设备的时间处理，必须引入中断概念。中断，当设备处理完内部工作后需要获取cpu资源时，向cpu发出的信号。该信号的发送依赖于中断信号线，不同的设备需要不同的中断信号线（当然也会有共享中断信号）。内核维护了一个中断信号线的注册表，驱动程序在使用中断前要请求一个中断通道（或IRQ中断请求），在使用结束后释放该通道。下面是请求和释放中断通道的相应接口：\n\n    #include &lt;linux/sched.h&gt;\n    int request_irq(unsigned int irq,\n                    irqreturn_t (*handler)(int, void *, struct pt_regs *),\n                    unsigned long flags,\n                    const char *dev_name,\n                    void *dev_id);\n    参数：\n    unsigned int irq：\n    请求的中断号\n\n    irqreturn_t (*handler)：\n    安装的处理函数指针. 我们在本章后面讨论给这个函数的参数以及它的返回值.\n\n    unsigned long flags：\n    如你会希望的, 一个与中断管理相关的选项的位掩码(后面描述).\n\n    const char *dev_name：\n    这个传递给 request_irq 的字串用在 /proc/interrupts 来显示中断的拥有者(下一节看到)\n\n    void *dev_id：\n    用作共享中断线的指针. 它是一个独特的标识, 用在当释放中断线时以及可能还被驱动用来指向它自己的私有数据区(来标识哪个设备在中断). 如果中断没有被共享, dev_id 可以设置为 NULL, 但是使用这个项指向设备结构不管如何是个好主意. 我们将在\"实现一个处理\"一节中看到 dev_id 的一个实际应用.\n\n    flags 中可以设置的位如下:\n    SA_INTERRUPT\n    当置位了, 这表示一个\"快速\"中断处理. 快速处理在当前处理器上禁止中断来执行(这个主题在\"快速和慢速处理\"一节涉及).\n    SA_SHIRQ\n    这个位表示中断可以在设备间共享. 共享的概念在\"中断共享\"一节中略述.\n    SA_SAMPLE_RANDOM\n    这个位表示产生的中断能够有贡献给 /dev/random 和 /dev/urandom 使用的加密池. 这些设备在读取时返回真正的随机数并且设计来帮助应用程序软件为加密选择安全钥. 这样的随机数从一个由各种随机事件贡献的加密池中提取的. 如果你的设备以真正随机的时间产生中断, 你应当设置这个标志. 如果, 另一方面, 你的中断是可预测的( 例如, 一个帧抓取器的场消隐), 这个标志不值得设置 -- 它无论如何不会对系统加密有贡献. 可能被攻击者影响的设备不应当设置这个标志; 例如, 网络驱动易遭受从外部计时的可预测报文并且不应当对加密池有贡献. 更多信息看 drivers/char/random.c 的注释。\n    返回值：\n    0:成功\n    负数：错误码\n\n    void free_irq(unsigned int irq, void *dev_id);\n    参数同上。`</pre>\n\n    #### /proc接口\n\n    当有多个硬件产生中断时，内核需要生成一份表格已记录中断和中断设备的情况，这个表格显示在/proc/interrupts中。\n\n    <pre class=\"prettyprint\">`username@ubuntu:~$ cat /proc/interrupts\n               CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7\n      0:       4384          0          0          0          0          0          0          0   IO-APIC-edge      timer\n      1:        950          2          0          1          0          0          0          0   IO-APIC-edge      i8042\n      6:          0          0          0          0          0          0          3          0   IO-APIC-edge      floppy\n      7:          0          0          0          0          0          0          0          0   IO-APIC-edge      parport0\n      8:          1          0          0          0          0          0          0          0   IO-APIC-edge      rtc0\n      9:          0          0          0          0          0          0          0          0   IO-APIC-fasteoi   acpi\n     12:       3573          0          0          3          0          0          0          0   IO-APIC-edge      i8042\n     14:          0          0          0          0          0          0          0          0   IO-APIC-edge      ata_piix\n    NMI:          0          0          0          0          0          0          0          0   Non-maskable interrupts\n    LOC:   34453497   34673929   33285941   33955988   26748072   26296607   25414863   26528495   Local timer interrupts\n    SPU:          0          0          0          0          0          0          0          0   Spurious interrupts\n    PMI:          0          0          0          0          0          0          0          0   Performance monitoring interrupts\n    IWI:          0          0          0          0          0          0          0          0   IRQ work interrupts\n    RES:   12987795   17430673   15115152   14059807   12072005   15228434   13090966   12469424   Rescheduling interrupts\n    CAL:       2382       2842       2895       2903    6002589       2717       2709       2523   Function call interrupts\n    TLB:    3183761    3010846    2658535    2572622    3065747    3268356    2652696    2713237   TLB shootdowns\n    TRM:          0          0          0          0          0          0          0          0   Thermal event interrupts\n    THR:          0          0          0          0          0          0          0          0   Threshold APIC interrupts\n    MCE:          0          0          0          0          0          0          0          0   Machine check exceptions\n    MCP:       4340       4340       4340       4340       4340       4340       4340       4340   Machine check polls\n    ERR:          0\n    MIS:          0\n\n    第一列是已经安装的中断处理例程的中断号；\n    第二至九列分别是每个cpu收到的中断数量；\n    第十列是处理中断的可编程中断控制器信息；\n    第十一列是注册中断处理例程的设备信息。`</pre>\n\n    还有一个和中断相关的文件：/proc/stat \n\n    stat文件每行第一个字符串为该行的关键字，其中intr表示的正是中断相关的信息。 \n\n    intr后的第一列为接收的中断总数，之后为每个IRQ信号线接收的中断数量。\n\n    #### 自动探测IRQ号\n\n    驱动程序初始化时，通常需要确定设备将要使用哪条IRQ信号线以便正确的安装处理例程。自动探测IRQ号需要完成的功能是：通知设备产生一个中断信号并观察会发生什么。通常通过两种方法来实现这样的功能：调用内核提供的辅助函数，或者自己实现该功能。\n\n    ##### **在内核帮助下探测**\n\n    内核提供了一些底层函数来探测中断号。它只能在非共享中断的情境下工作，但是大部分设备能够在共享中断状态工作，并且提供了更好的方法来尽量发现配置的中断号。\n\n    <pre class=\"prettyprint\">`unsigned long probe_irq_on(void);\n    这个函数返回一个未安排的中断的位掩码. 驱动必须保留返回的位掩码, 并且在后面传递给 probe_irq_off。 在这个调用之后, 驱动应当安排它的设备产生至少一次中断。\n\n    int probe_irq_off(unsigned long);\n    在设备已请求一个中断后, 驱动调用这个函数, 作为参数传递之前由 probe_irq_on 返回的位掩码。probe_irq_off 返回在\"probe_on\"之后发出的中断号。如果没有中断发生, 返回 0 (因此, IRQ 0 不能探测, 但是没有用户设备能够在任何支持的体系上使用它). 如果多于一个中断发生( 模糊的探测 ), probe_irq_off 返回一个负值。\n    注意小心使能设备上的中断, 在调用 probe_irq_on 之后启用设备上的中断以及在调用 probe_irq_off 后禁止它们。另外, 在 probe_irq_off 之后需要处理设备上待处理的中断。`</pre>\n\n    ##### **实现自己的探测功能**\n\n    主要实现功能同上：通知设备产生一个中断信号并观察会发生什么。但实现自己的探测功能一般是启用所有未被占用的中断，然后观察会发生什么。\n\n    ### 2 实现中断处理例程\n\n    类比定时器，实现中断处理例程的注意事项： \n\n    1.不能向用户空间发送和接收数据，因为它不是在任何进程的上下文中执行的； \n\n    2.不能做任何可能引发休眠的动作； \n\n    3.不能调用schule函数； \n\n    中断例程的功能：将有关中断接收的信息反馈给设备，并根据正在服务的中断的不同含义对数据进行相应的读和写。 \n\n    中断例程的典型任务：如果中断通知进程所等待的时间已经发生，就会唤醒在该设备上的休眠的进程。\n\n    #### 处理例程的参数及返回值\n\n    中断处理例程常用的三个参数： \n\n    int irq：中断号，用于调试信息输出； \n\n    void *dev_id：客户数据类型，一般是驱动程序的私有信息； \n\n    struct pt_regs *regs：保存处理器进入中断代码前的处理器上下文快照（很少使用）； \n\n    例：\n\n    <pre class=\"prettyprint\">`//中断处理例程\n    static irqreturn_t sample_interrupt(int irq, void *dev_id, struct pt_regs *regs)\n    {\n            struct sample_dev *dev = dev_id;\n            /* now `dev' points to the right hardware item */\n            /* .... */\n    }\n    //和中断处理例程相关联的open代码\n    static void sample_open(struct inode *inode, struct file *filp)\n    {\n            struct sample_dev *dev = hwinfo + MINOR(inode-&gt;i_rdev);\n            request_irq(dev-&gt;irq, sample_interrupt,\n                        0 /* flags */, \"sample\", dev /* dev_id */);\n            /*....*/\n            return 0;\n\n    }`</pre>\n\n    返回值： \n\n    用于指明是否真正处理了一个中断，是则返回IRQ_HANDLED,否则返回IRQ_NONE；同时也可同过下面宏来产生返回值：IRQ_RETVAL(handled)。\n\n    #### 启用和禁用中断\n\n    禁止和启用单个中断：\n\n    <pre class=\"prettyprint\">` &lt;asm/irq.h&gt;\n     void disable_irq(int irq);\n    void disable_irq_nosync(int irq);\n    void enable_irq(int irq);`</pre>\n\n    禁止和启用所有中断：\n\n    <pre class=\"prettyprint\">`&lt;asm/system.h&gt;\n    void local_irq_save(unsigned long flags);\n    void local_irq_disable(void);\n    void local_irq_restore(unsigned long flags); \n    void local_irq_enable(void);\n\n### 3 中断的顶半部和下半部\n\n中断处理的一个主要问题是如何处理耗时任务。 \n\nLinux (许多其他系统一起)通过将中断处理分为 2 部分解决这个问题。实际响应中断的例程，称为顶半部，也就是用request_irq注册的终端例程。底半部，被顶半部调度，并在稍后安全时间内执行的例程。 \n\nlinux有两种机制来实现底半部的处理：tasklet和工作队列。tasklet非常快，但是它的代码必须是原子的；工作队列具有更高的延迟，但允许休眠。这两种机制都在《时间、延迟和延缓操作》中讲到，这里略过。\n\n### 4 中断共享\n\n#### 安装共享处理例程\n\n共享中断通过 request_irq 来安装就像不共享的一样, 但是有 2 个不同: \n\n1.当请求中断时，必须在 flags 参数中指定,SA_SHIRQ 位。 \n\n2.dev_id 参数必须是唯一的。任何模块地址空间的指针都行, 但是 dev_id 明确地不能设置为 NULL。 \n\n内核保持着一个与中断相关联的共享处理者列表, 并且 dev_id 可认为是区别它们的签名. 如果 2 个驱动要在同一个中断上注册 NULL 作为它们的签名, 在卸载时事情可能就乱了, 在中断到的时候引发内核 oops. 由于这个理由, 如果在注册共享中断时传给了一个 NULL dev_id , 现代内核会大声抱怨. 当请求一个共享的中断, request_irq 成功, 如果下列之一是真: \n\n1.中断线空闲。 \n\n2.所有这条线的已经注册的处理者也指定共享这个 IRQ。 \n\n释放处理例程：free_irq。 \n\n注意：不能使用enable_irq和disable_irq。如果使用了，共享中断信号线的其他设备就无法正常工作了。\n\n### 中断驱动的I/O\n\n如果与驱动程序管理的硬件之间的数据传输因为某种原因而延迟, 驱动编写者应当实现缓冲。数据缓存有助于将数据的传送和接收与系统调用read和write分离开来，从而提高系统的性能。\n\n一个好的缓存机制需采用中断驱动的 I/O，一个输入缓冲在中断时填充并且被读取设备的进程清空; 一个输出缓存由写设备的进程填充并且在中断时清空。 \n\n为使中断驱动的数据传送成功发生, 硬件应当使用下列语义产生中断 : \n\n1.对于输入, 当新数据到达时, 并且准备好被系统处理器获取时，设备中断处理器。实际动作依赖设备使用的是I/O 端口, 内存映射, 还是 DMA。 \n\n2.对于输出, 或者当它准备好接受新数据, 或者确认一个成功的数据传送时，设备递交一个中断。 内存映射的和能DMA的设备常常产生中断来告诉系统它们完成了这个缓存。\n\n            <div>\n                作者：WEINILUO 发表于2016/9/29 17:30:10 [原文链接](http://blog.csdn.net/weiniluo/article/details/52625432)\n            </div>\n            <div>\n            阅读：483 评论：1 [查看评论](http://blog.csdn.net/weiniluo/article/details/52625432#comments)\n            </div>\n","source":"_posts/原-中断处理.md","raw":"---\ntitle: '[原]中断处理'\ntags: []\ndate: 2016-09-29 17:30:10\n---\n\n### 1 注册中断处理例程\n\n许多设备的内部工作通常是在和处理器完全不同的时间周期里完成的，并且总要比处理器慢，为了不让cpu一直等待外部设备的时间处理，必须引入中断概念。中断，当设备处理完内部工作后需要获取cpu资源时，向cpu发出的信号。该信号的发送依赖于中断信号线，不同的设备需要不同的中断信号线（当然也会有共享中断信号）。内核维护了一个中断信号线的注册表，驱动程序在使用中断前要请求一个中断通道（或IRQ中断请求），在使用结束后释放该通道。下面是请求和释放中断通道的相应接口：\n\n    #include &lt;linux/sched.h&gt;\n    int request_irq(unsigned int irq,\n                    irqreturn_t (*handler)(int, void *, struct pt_regs *),\n                    unsigned long flags,\n                    const char *dev_name,\n                    void *dev_id);\n    参数：\n    unsigned int irq：\n    请求的中断号\n\n    irqreturn_t (*handler)：\n    安装的处理函数指针. 我们在本章后面讨论给这个函数的参数以及它的返回值.\n\n    unsigned long flags：\n    如你会希望的, 一个与中断管理相关的选项的位掩码(后面描述).\n\n    const char *dev_name：\n    这个传递给 request_irq 的字串用在 /proc/interrupts 来显示中断的拥有者(下一节看到)\n\n    void *dev_id：\n    用作共享中断线的指针. 它是一个独特的标识, 用在当释放中断线时以及可能还被驱动用来指向它自己的私有数据区(来标识哪个设备在中断). 如果中断没有被共享, dev_id 可以设置为 NULL, 但是使用这个项指向设备结构不管如何是个好主意. 我们将在\"实现一个处理\"一节中看到 dev_id 的一个实际应用.\n\n    flags 中可以设置的位如下:\n    SA_INTERRUPT\n    当置位了, 这表示一个\"快速\"中断处理. 快速处理在当前处理器上禁止中断来执行(这个主题在\"快速和慢速处理\"一节涉及).\n    SA_SHIRQ\n    这个位表示中断可以在设备间共享. 共享的概念在\"中断共享\"一节中略述.\n    SA_SAMPLE_RANDOM\n    这个位表示产生的中断能够有贡献给 /dev/random 和 /dev/urandom 使用的加密池. 这些设备在读取时返回真正的随机数并且设计来帮助应用程序软件为加密选择安全钥. 这样的随机数从一个由各种随机事件贡献的加密池中提取的. 如果你的设备以真正随机的时间产生中断, 你应当设置这个标志. 如果, 另一方面, 你的中断是可预测的( 例如, 一个帧抓取器的场消隐), 这个标志不值得设置 -- 它无论如何不会对系统加密有贡献. 可能被攻击者影响的设备不应当设置这个标志; 例如, 网络驱动易遭受从外部计时的可预测报文并且不应当对加密池有贡献. 更多信息看 drivers/char/random.c 的注释。\n    返回值：\n    0:成功\n    负数：错误码\n\n    void free_irq(unsigned int irq, void *dev_id);\n    参数同上。`</pre>\n\n    #### /proc接口\n\n    当有多个硬件产生中断时，内核需要生成一份表格已记录中断和中断设备的情况，这个表格显示在/proc/interrupts中。\n\n    <pre class=\"prettyprint\">`username@ubuntu:~$ cat /proc/interrupts\n               CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7\n      0:       4384          0          0          0          0          0          0          0   IO-APIC-edge      timer\n      1:        950          2          0          1          0          0          0          0   IO-APIC-edge      i8042\n      6:          0          0          0          0          0          0          3          0   IO-APIC-edge      floppy\n      7:          0          0          0          0          0          0          0          0   IO-APIC-edge      parport0\n      8:          1          0          0          0          0          0          0          0   IO-APIC-edge      rtc0\n      9:          0          0          0          0          0          0          0          0   IO-APIC-fasteoi   acpi\n     12:       3573          0          0          3          0          0          0          0   IO-APIC-edge      i8042\n     14:          0          0          0          0          0          0          0          0   IO-APIC-edge      ata_piix\n    NMI:          0          0          0          0          0          0          0          0   Non-maskable interrupts\n    LOC:   34453497   34673929   33285941   33955988   26748072   26296607   25414863   26528495   Local timer interrupts\n    SPU:          0          0          0          0          0          0          0          0   Spurious interrupts\n    PMI:          0          0          0          0          0          0          0          0   Performance monitoring interrupts\n    IWI:          0          0          0          0          0          0          0          0   IRQ work interrupts\n    RES:   12987795   17430673   15115152   14059807   12072005   15228434   13090966   12469424   Rescheduling interrupts\n    CAL:       2382       2842       2895       2903    6002589       2717       2709       2523   Function call interrupts\n    TLB:    3183761    3010846    2658535    2572622    3065747    3268356    2652696    2713237   TLB shootdowns\n    TRM:          0          0          0          0          0          0          0          0   Thermal event interrupts\n    THR:          0          0          0          0          0          0          0          0   Threshold APIC interrupts\n    MCE:          0          0          0          0          0          0          0          0   Machine check exceptions\n    MCP:       4340       4340       4340       4340       4340       4340       4340       4340   Machine check polls\n    ERR:          0\n    MIS:          0\n\n    第一列是已经安装的中断处理例程的中断号；\n    第二至九列分别是每个cpu收到的中断数量；\n    第十列是处理中断的可编程中断控制器信息；\n    第十一列是注册中断处理例程的设备信息。`</pre>\n\n    还有一个和中断相关的文件：/proc/stat \n\n    stat文件每行第一个字符串为该行的关键字，其中intr表示的正是中断相关的信息。 \n\n    intr后的第一列为接收的中断总数，之后为每个IRQ信号线接收的中断数量。\n\n    #### 自动探测IRQ号\n\n    驱动程序初始化时，通常需要确定设备将要使用哪条IRQ信号线以便正确的安装处理例程。自动探测IRQ号需要完成的功能是：通知设备产生一个中断信号并观察会发生什么。通常通过两种方法来实现这样的功能：调用内核提供的辅助函数，或者自己实现该功能。\n\n    ##### **在内核帮助下探测**\n\n    内核提供了一些底层函数来探测中断号。它只能在非共享中断的情境下工作，但是大部分设备能够在共享中断状态工作，并且提供了更好的方法来尽量发现配置的中断号。\n\n    <pre class=\"prettyprint\">`unsigned long probe_irq_on(void);\n    这个函数返回一个未安排的中断的位掩码. 驱动必须保留返回的位掩码, 并且在后面传递给 probe_irq_off。 在这个调用之后, 驱动应当安排它的设备产生至少一次中断。\n\n    int probe_irq_off(unsigned long);\n    在设备已请求一个中断后, 驱动调用这个函数, 作为参数传递之前由 probe_irq_on 返回的位掩码。probe_irq_off 返回在\"probe_on\"之后发出的中断号。如果没有中断发生, 返回 0 (因此, IRQ 0 不能探测, 但是没有用户设备能够在任何支持的体系上使用它). 如果多于一个中断发生( 模糊的探测 ), probe_irq_off 返回一个负值。\n    注意小心使能设备上的中断, 在调用 probe_irq_on 之后启用设备上的中断以及在调用 probe_irq_off 后禁止它们。另外, 在 probe_irq_off 之后需要处理设备上待处理的中断。`</pre>\n\n    ##### **实现自己的探测功能**\n\n    主要实现功能同上：通知设备产生一个中断信号并观察会发生什么。但实现自己的探测功能一般是启用所有未被占用的中断，然后观察会发生什么。\n\n    ### 2 实现中断处理例程\n\n    类比定时器，实现中断处理例程的注意事项： \n\n    1.不能向用户空间发送和接收数据，因为它不是在任何进程的上下文中执行的； \n\n    2.不能做任何可能引发休眠的动作； \n\n    3.不能调用schule函数； \n\n    中断例程的功能：将有关中断接收的信息反馈给设备，并根据正在服务的中断的不同含义对数据进行相应的读和写。 \n\n    中断例程的典型任务：如果中断通知进程所等待的时间已经发生，就会唤醒在该设备上的休眠的进程。\n\n    #### 处理例程的参数及返回值\n\n    中断处理例程常用的三个参数： \n\n    int irq：中断号，用于调试信息输出； \n\n    void *dev_id：客户数据类型，一般是驱动程序的私有信息； \n\n    struct pt_regs *regs：保存处理器进入中断代码前的处理器上下文快照（很少使用）； \n\n    例：\n\n    <pre class=\"prettyprint\">`//中断处理例程\n    static irqreturn_t sample_interrupt(int irq, void *dev_id, struct pt_regs *regs)\n    {\n            struct sample_dev *dev = dev_id;\n            /* now `dev' points to the right hardware item */\n            /* .... */\n    }\n    //和中断处理例程相关联的open代码\n    static void sample_open(struct inode *inode, struct file *filp)\n    {\n            struct sample_dev *dev = hwinfo + MINOR(inode-&gt;i_rdev);\n            request_irq(dev-&gt;irq, sample_interrupt,\n                        0 /* flags */, \"sample\", dev /* dev_id */);\n            /*....*/\n            return 0;\n\n    }`</pre>\n\n    返回值： \n\n    用于指明是否真正处理了一个中断，是则返回IRQ_HANDLED,否则返回IRQ_NONE；同时也可同过下面宏来产生返回值：IRQ_RETVAL(handled)。\n\n    #### 启用和禁用中断\n\n    禁止和启用单个中断：\n\n    <pre class=\"prettyprint\">` &lt;asm/irq.h&gt;\n     void disable_irq(int irq);\n    void disable_irq_nosync(int irq);\n    void enable_irq(int irq);`</pre>\n\n    禁止和启用所有中断：\n\n    <pre class=\"prettyprint\">`&lt;asm/system.h&gt;\n    void local_irq_save(unsigned long flags);\n    void local_irq_disable(void);\n    void local_irq_restore(unsigned long flags); \n    void local_irq_enable(void);\n\n### 3 中断的顶半部和下半部\n\n中断处理的一个主要问题是如何处理耗时任务。 \n\nLinux (许多其他系统一起)通过将中断处理分为 2 部分解决这个问题。实际响应中断的例程，称为顶半部，也就是用request_irq注册的终端例程。底半部，被顶半部调度，并在稍后安全时间内执行的例程。 \n\nlinux有两种机制来实现底半部的处理：tasklet和工作队列。tasklet非常快，但是它的代码必须是原子的；工作队列具有更高的延迟，但允许休眠。这两种机制都在《时间、延迟和延缓操作》中讲到，这里略过。\n\n### 4 中断共享\n\n#### 安装共享处理例程\n\n共享中断通过 request_irq 来安装就像不共享的一样, 但是有 2 个不同: \n\n1.当请求中断时，必须在 flags 参数中指定,SA_SHIRQ 位。 \n\n2.dev_id 参数必须是唯一的。任何模块地址空间的指针都行, 但是 dev_id 明确地不能设置为 NULL。 \n\n内核保持着一个与中断相关联的共享处理者列表, 并且 dev_id 可认为是区别它们的签名. 如果 2 个驱动要在同一个中断上注册 NULL 作为它们的签名, 在卸载时事情可能就乱了, 在中断到的时候引发内核 oops. 由于这个理由, 如果在注册共享中断时传给了一个 NULL dev_id , 现代内核会大声抱怨. 当请求一个共享的中断, request_irq 成功, 如果下列之一是真: \n\n1.中断线空闲。 \n\n2.所有这条线的已经注册的处理者也指定共享这个 IRQ。 \n\n释放处理例程：free_irq。 \n\n注意：不能使用enable_irq和disable_irq。如果使用了，共享中断信号线的其他设备就无法正常工作了。\n\n### 中断驱动的I/O\n\n如果与驱动程序管理的硬件之间的数据传输因为某种原因而延迟, 驱动编写者应当实现缓冲。数据缓存有助于将数据的传送和接收与系统调用read和write分离开来，从而提高系统的性能。\n\n一个好的缓存机制需采用中断驱动的 I/O，一个输入缓冲在中断时填充并且被读取设备的进程清空; 一个输出缓存由写设备的进程填充并且在中断时清空。 \n\n为使中断驱动的数据传送成功发生, 硬件应当使用下列语义产生中断 : \n\n1.对于输入, 当新数据到达时, 并且准备好被系统处理器获取时，设备中断处理器。实际动作依赖设备使用的是I/O 端口, 内存映射, 还是 DMA。 \n\n2.对于输出, 或者当它准备好接受新数据, 或者确认一个成功的数据传送时，设备递交一个中断。 内存映射的和能DMA的设备常常产生中断来告诉系统它们完成了这个缓存。\n\n            <div>\n                作者：WEINILUO 发表于2016/9/29 17:30:10 [原文链接](http://blog.csdn.net/weiniluo/article/details/52625432)\n            </div>\n            <div>\n            阅读：483 评论：1 [查看评论](http://blog.csdn.net/weiniluo/article/details/52625432#comments)\n            </div>\n","slug":"原-中断处理","published":1,"updated":"2016-10-20T09:50:22.265Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnod3000cvzs6bc6knngq","content":"<h3 id=\"1-注册中断处理例程\"><a href=\"#1-注册中断处理例程\" class=\"headerlink\" title=\"1 注册中断处理例程\"></a>1 注册中断处理例程</h3><p>许多设备的内部工作通常是在和处理器完全不同的时间周期里完成的，并且总要比处理器慢，为了不让cpu一直等待外部设备的时间处理，必须引入中断概念。中断，当设备处理完内部工作后需要获取cpu资源时，向cpu发出的信号。该信号的发送依赖于中断信号线，不同的设备需要不同的中断信号线（当然也会有共享中断信号）。内核维护了一个中断信号线的注册表，驱动程序在使用中断前要请求一个中断通道（或IRQ中断请求），在使用结束后释放该通道。下面是请求和释放中断通道的相应接口：</p>\n<pre><code>#include &amp;lt;linux/sched.h&amp;gt;\nint request_irq(unsigned int irq,\n                irqreturn_t (*handler)(int, void *, struct pt_regs *),\n                unsigned long flags,\n                const char *dev_name,\n                void *dev_id);\n参数：\nunsigned int irq：\n请求的中断号\n\nirqreturn_t (*handler)：\n安装的处理函数指针. 我们在本章后面讨论给这个函数的参数以及它的返回值.\n\nunsigned long flags：\n如你会希望的, 一个与中断管理相关的选项的位掩码(后面描述).\n\nconst char *dev_name：\n这个传递给 request_irq 的字串用在 /proc/interrupts 来显示中断的拥有者(下一节看到)\n\nvoid *dev_id：\n用作共享中断线的指针. 它是一个独特的标识, 用在当释放中断线时以及可能还被驱动用来指向它自己的私有数据区(来标识哪个设备在中断). 如果中断没有被共享, dev_id 可以设置为 NULL, 但是使用这个项指向设备结构不管如何是个好主意. 我们将在&quot;实现一个处理&quot;一节中看到 dev_id 的一个实际应用.\n\nflags 中可以设置的位如下:\nSA_INTERRUPT\n当置位了, 这表示一个&quot;快速&quot;中断处理. 快速处理在当前处理器上禁止中断来执行(这个主题在&quot;快速和慢速处理&quot;一节涉及).\nSA_SHIRQ\n这个位表示中断可以在设备间共享. 共享的概念在&quot;中断共享&quot;一节中略述.\nSA_SAMPLE_RANDOM\n这个位表示产生的中断能够有贡献给 /dev/random 和 /dev/urandom 使用的加密池. 这些设备在读取时返回真正的随机数并且设计来帮助应用程序软件为加密选择安全钥. 这样的随机数从一个由各种随机事件贡献的加密池中提取的. 如果你的设备以真正随机的时间产生中断, 你应当设置这个标志. 如果, 另一方面, 你的中断是可预测的( 例如, 一个帧抓取器的场消隐), 这个标志不值得设置 -- 它无论如何不会对系统加密有贡献. 可能被攻击者影响的设备不应当设置这个标志; 例如, 网络驱动易遭受从外部计时的可预测报文并且不应当对加密池有贡献. 更多信息看 drivers/char/random.c 的注释。\n返回值：\n0:成功\n负数：错误码\n\nvoid free_irq(unsigned int irq, void *dev_id);\n参数同上。`&lt;/pre&gt;\n\n#### /proc接口\n\n当有多个硬件产生中断时，内核需要生成一份表格已记录中断和中断设备的情况，这个表格显示在/proc/interrupts中。\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`username@ubuntu:~$ cat /proc/interrupts\n           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7\n  0:       4384          0          0          0          0          0          0          0   IO-APIC-edge      timer\n  1:        950          2          0          1          0          0          0          0   IO-APIC-edge      i8042\n  6:          0          0          0          0          0          0          3          0   IO-APIC-edge      floppy\n  7:          0          0          0          0          0          0          0          0   IO-APIC-edge      parport0\n  8:          1          0          0          0          0          0          0          0   IO-APIC-edge      rtc0\n  9:          0          0          0          0          0          0          0          0   IO-APIC-fasteoi   acpi\n 12:       3573          0          0          3          0          0          0          0   IO-APIC-edge      i8042\n 14:          0          0          0          0          0          0          0          0   IO-APIC-edge      ata_piix\nNMI:          0          0          0          0          0          0          0          0   Non-maskable interrupts\nLOC:   34453497   34673929   33285941   33955988   26748072   26296607   25414863   26528495   Local timer interrupts\nSPU:          0          0          0          0          0          0          0          0   Spurious interrupts\nPMI:          0          0          0          0          0          0          0          0   Performance monitoring interrupts\nIWI:          0          0          0          0          0          0          0          0   IRQ work interrupts\nRES:   12987795   17430673   15115152   14059807   12072005   15228434   13090966   12469424   Rescheduling interrupts\nCAL:       2382       2842       2895       2903    6002589       2717       2709       2523   Function call interrupts\nTLB:    3183761    3010846    2658535    2572622    3065747    3268356    2652696    2713237   TLB shootdowns\nTRM:          0          0          0          0          0          0          0          0   Thermal event interrupts\nTHR:          0          0          0          0          0          0          0          0   Threshold APIC interrupts\nMCE:          0          0          0          0          0          0          0          0   Machine check exceptions\nMCP:       4340       4340       4340       4340       4340       4340       4340       4340   Machine check polls\nERR:          0\nMIS:          0\n\n第一列是已经安装的中断处理例程的中断号；\n第二至九列分别是每个cpu收到的中断数量；\n第十列是处理中断的可编程中断控制器信息；\n第十一列是注册中断处理例程的设备信息。`&lt;/pre&gt;\n\n还有一个和中断相关的文件：/proc/stat \n\nstat文件每行第一个字符串为该行的关键字，其中intr表示的正是中断相关的信息。 \n\nintr后的第一列为接收的中断总数，之后为每个IRQ信号线接收的中断数量。\n\n#### 自动探测IRQ号\n\n驱动程序初始化时，通常需要确定设备将要使用哪条IRQ信号线以便正确的安装处理例程。自动探测IRQ号需要完成的功能是：通知设备产生一个中断信号并观察会发生什么。通常通过两种方法来实现这样的功能：调用内核提供的辅助函数，或者自己实现该功能。\n\n##### **在内核帮助下探测**\n\n内核提供了一些底层函数来探测中断号。它只能在非共享中断的情境下工作，但是大部分设备能够在共享中断状态工作，并且提供了更好的方法来尽量发现配置的中断号。\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`unsigned long probe_irq_on(void);\n这个函数返回一个未安排的中断的位掩码. 驱动必须保留返回的位掩码, 并且在后面传递给 probe_irq_off。 在这个调用之后, 驱动应当安排它的设备产生至少一次中断。\n\nint probe_irq_off(unsigned long);\n在设备已请求一个中断后, 驱动调用这个函数, 作为参数传递之前由 probe_irq_on 返回的位掩码。probe_irq_off 返回在&quot;probe_on&quot;之后发出的中断号。如果没有中断发生, 返回 0 (因此, IRQ 0 不能探测, 但是没有用户设备能够在任何支持的体系上使用它). 如果多于一个中断发生( 模糊的探测 ), probe_irq_off 返回一个负值。\n注意小心使能设备上的中断, 在调用 probe_irq_on 之后启用设备上的中断以及在调用 probe_irq_off 后禁止它们。另外, 在 probe_irq_off 之后需要处理设备上待处理的中断。`&lt;/pre&gt;\n\n##### **实现自己的探测功能**\n\n主要实现功能同上：通知设备产生一个中断信号并观察会发生什么。但实现自己的探测功能一般是启用所有未被占用的中断，然后观察会发生什么。\n\n### 2 实现中断处理例程\n\n类比定时器，实现中断处理例程的注意事项： \n\n1.不能向用户空间发送和接收数据，因为它不是在任何进程的上下文中执行的； \n\n2.不能做任何可能引发休眠的动作； \n\n3.不能调用schule函数； \n\n中断例程的功能：将有关中断接收的信息反馈给设备，并根据正在服务的中断的不同含义对数据进行相应的读和写。 \n\n中断例程的典型任务：如果中断通知进程所等待的时间已经发生，就会唤醒在该设备上的休眠的进程。\n\n#### 处理例程的参数及返回值\n\n中断处理例程常用的三个参数： \n\nint irq：中断号，用于调试信息输出； \n\nvoid *dev_id：客户数据类型，一般是驱动程序的私有信息； \n\nstruct pt_regs *regs：保存处理器进入中断代码前的处理器上下文快照（很少使用）； \n\n例：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`//中断处理例程\nstatic irqreturn_t sample_interrupt(int irq, void *dev_id, struct pt_regs *regs)\n{\n        struct sample_dev *dev = dev_id;\n        /* now `dev&apos; points to the right hardware item */\n        /* .... */\n}\n//和中断处理例程相关联的open代码\nstatic void sample_open(struct inode *inode, struct file *filp)\n{\n        struct sample_dev *dev = hwinfo + MINOR(inode-&amp;gt;i_rdev);\n        request_irq(dev-&amp;gt;irq, sample_interrupt,\n                    0 /* flags */, &quot;sample&quot;, dev /* dev_id */);\n        /*....*/\n        return 0;\n\n}`&lt;/pre&gt;\n\n返回值： \n\n用于指明是否真正处理了一个中断，是则返回IRQ_HANDLED,否则返回IRQ_NONE；同时也可同过下面宏来产生返回值：IRQ_RETVAL(handled)。\n\n#### 启用和禁用中断\n\n禁止和启用单个中断：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;` &amp;lt;asm/irq.h&amp;gt;\n void disable_irq(int irq);\nvoid disable_irq_nosync(int irq);\nvoid enable_irq(int irq);`&lt;/pre&gt;\n\n禁止和启用所有中断：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`&amp;lt;asm/system.h&amp;gt;\nvoid local_irq_save(unsigned long flags);\nvoid local_irq_disable(void);\nvoid local_irq_restore(unsigned long flags); \nvoid local_irq_enable(void);\n</code></pre><h3 id=\"3-中断的顶半部和下半部\"><a href=\"#3-中断的顶半部和下半部\" class=\"headerlink\" title=\"3 中断的顶半部和下半部\"></a>3 中断的顶半部和下半部</h3><p>中断处理的一个主要问题是如何处理耗时任务。 </p>\n<p>Linux (许多其他系统一起)通过将中断处理分为 2 部分解决这个问题。实际响应中断的例程，称为顶半部，也就是用request_irq注册的终端例程。底半部，被顶半部调度，并在稍后安全时间内执行的例程。 </p>\n<p>linux有两种机制来实现底半部的处理：tasklet和工作队列。tasklet非常快，但是它的代码必须是原子的；工作队列具有更高的延迟，但允许休眠。这两种机制都在《时间、延迟和延缓操作》中讲到，这里略过。</p>\n<h3 id=\"4-中断共享\"><a href=\"#4-中断共享\" class=\"headerlink\" title=\"4 中断共享\"></a>4 中断共享</h3><h4 id=\"安装共享处理例程\"><a href=\"#安装共享处理例程\" class=\"headerlink\" title=\"安装共享处理例程\"></a>安装共享处理例程</h4><p>共享中断通过 request_irq 来安装就像不共享的一样, 但是有 2 个不同: </p>\n<p>1.当请求中断时，必须在 flags 参数中指定,SA_SHIRQ 位。 </p>\n<p>2.dev_id 参数必须是唯一的。任何模块地址空间的指针都行, 但是 dev_id 明确地不能设置为 NULL。 </p>\n<p>内核保持着一个与中断相关联的共享处理者列表, 并且 dev_id 可认为是区别它们的签名. 如果 2 个驱动要在同一个中断上注册 NULL 作为它们的签名, 在卸载时事情可能就乱了, 在中断到的时候引发内核 oops. 由于这个理由, 如果在注册共享中断时传给了一个 NULL dev_id , 现代内核会大声抱怨. 当请求一个共享的中断, request_irq 成功, 如果下列之一是真: </p>\n<p>1.中断线空闲。 </p>\n<p>2.所有这条线的已经注册的处理者也指定共享这个 IRQ。 </p>\n<p>释放处理例程：free_irq。 </p>\n<p>注意：不能使用enable_irq和disable_irq。如果使用了，共享中断信号线的其他设备就无法正常工作了。</p>\n<h3 id=\"中断驱动的I-O\"><a href=\"#中断驱动的I-O\" class=\"headerlink\" title=\"中断驱动的I/O\"></a>中断驱动的I/O</h3><p>如果与驱动程序管理的硬件之间的数据传输因为某种原因而延迟, 驱动编写者应当实现缓冲。数据缓存有助于将数据的传送和接收与系统调用read和write分离开来，从而提高系统的性能。</p>\n<p>一个好的缓存机制需采用中断驱动的 I/O，一个输入缓冲在中断时填充并且被读取设备的进程清空; 一个输出缓存由写设备的进程填充并且在中断时清空。 </p>\n<p>为使中断驱动的数据传送成功发生, 硬件应当使用下列语义产生中断 : </p>\n<p>1.对于输入, 当新数据到达时, 并且准备好被系统处理器获取时，设备中断处理器。实际动作依赖设备使用的是I/O 端口, 内存映射, 还是 DMA。 </p>\n<p>2.对于输出, 或者当它准备好接受新数据, 或者确认一个成功的数据传送时，设备递交一个中断。 内存映射的和能DMA的设备常常产生中断来告诉系统它们完成了这个缓存。</p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/9/29 17:30:10 [原文链接](http://blog.csdn.net/weiniluo/article/details/52625432)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：483 评论：1 [查看评论](http://blog.csdn.net/weiniluo/article/details/52625432#comments)\n&lt;/div&gt;\n</code></pre>","excerpt":"","more":"<h3 id=\"1-注册中断处理例程\"><a href=\"#1-注册中断处理例程\" class=\"headerlink\" title=\"1 注册中断处理例程\"></a>1 注册中断处理例程</h3><p>许多设备的内部工作通常是在和处理器完全不同的时间周期里完成的，并且总要比处理器慢，为了不让cpu一直等待外部设备的时间处理，必须引入中断概念。中断，当设备处理完内部工作后需要获取cpu资源时，向cpu发出的信号。该信号的发送依赖于中断信号线，不同的设备需要不同的中断信号线（当然也会有共享中断信号）。内核维护了一个中断信号线的注册表，驱动程序在使用中断前要请求一个中断通道（或IRQ中断请求），在使用结束后释放该通道。下面是请求和释放中断通道的相应接口：</p>\n<pre><code>#include &amp;lt;linux/sched.h&amp;gt;\nint request_irq(unsigned int irq,\n                irqreturn_t (*handler)(int, void *, struct pt_regs *),\n                unsigned long flags,\n                const char *dev_name,\n                void *dev_id);\n参数：\nunsigned int irq：\n请求的中断号\n\nirqreturn_t (*handler)：\n安装的处理函数指针. 我们在本章后面讨论给这个函数的参数以及它的返回值.\n\nunsigned long flags：\n如你会希望的, 一个与中断管理相关的选项的位掩码(后面描述).\n\nconst char *dev_name：\n这个传递给 request_irq 的字串用在 /proc/interrupts 来显示中断的拥有者(下一节看到)\n\nvoid *dev_id：\n用作共享中断线的指针. 它是一个独特的标识, 用在当释放中断线时以及可能还被驱动用来指向它自己的私有数据区(来标识哪个设备在中断). 如果中断没有被共享, dev_id 可以设置为 NULL, 但是使用这个项指向设备结构不管如何是个好主意. 我们将在&quot;实现一个处理&quot;一节中看到 dev_id 的一个实际应用.\n\nflags 中可以设置的位如下:\nSA_INTERRUPT\n当置位了, 这表示一个&quot;快速&quot;中断处理. 快速处理在当前处理器上禁止中断来执行(这个主题在&quot;快速和慢速处理&quot;一节涉及).\nSA_SHIRQ\n这个位表示中断可以在设备间共享. 共享的概念在&quot;中断共享&quot;一节中略述.\nSA_SAMPLE_RANDOM\n这个位表示产生的中断能够有贡献给 /dev/random 和 /dev/urandom 使用的加密池. 这些设备在读取时返回真正的随机数并且设计来帮助应用程序软件为加密选择安全钥. 这样的随机数从一个由各种随机事件贡献的加密池中提取的. 如果你的设备以真正随机的时间产生中断, 你应当设置这个标志. 如果, 另一方面, 你的中断是可预测的( 例如, 一个帧抓取器的场消隐), 这个标志不值得设置 -- 它无论如何不会对系统加密有贡献. 可能被攻击者影响的设备不应当设置这个标志; 例如, 网络驱动易遭受从外部计时的可预测报文并且不应当对加密池有贡献. 更多信息看 drivers/char/random.c 的注释。\n返回值：\n0:成功\n负数：错误码\n\nvoid free_irq(unsigned int irq, void *dev_id);\n参数同上。`&lt;/pre&gt;\n\n#### /proc接口\n\n当有多个硬件产生中断时，内核需要生成一份表格已记录中断和中断设备的情况，这个表格显示在/proc/interrupts中。\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`username@ubuntu:~$ cat /proc/interrupts\n           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7\n  0:       4384          0          0          0          0          0          0          0   IO-APIC-edge      timer\n  1:        950          2          0          1          0          0          0          0   IO-APIC-edge      i8042\n  6:          0          0          0          0          0          0          3          0   IO-APIC-edge      floppy\n  7:          0          0          0          0          0          0          0          0   IO-APIC-edge      parport0\n  8:          1          0          0          0          0          0          0          0   IO-APIC-edge      rtc0\n  9:          0          0          0          0          0          0          0          0   IO-APIC-fasteoi   acpi\n 12:       3573          0          0          3          0          0          0          0   IO-APIC-edge      i8042\n 14:          0          0          0          0          0          0          0          0   IO-APIC-edge      ata_piix\nNMI:          0          0          0          0          0          0          0          0   Non-maskable interrupts\nLOC:   34453497   34673929   33285941   33955988   26748072   26296607   25414863   26528495   Local timer interrupts\nSPU:          0          0          0          0          0          0          0          0   Spurious interrupts\nPMI:          0          0          0          0          0          0          0          0   Performance monitoring interrupts\nIWI:          0          0          0          0          0          0          0          0   IRQ work interrupts\nRES:   12987795   17430673   15115152   14059807   12072005   15228434   13090966   12469424   Rescheduling interrupts\nCAL:       2382       2842       2895       2903    6002589       2717       2709       2523   Function call interrupts\nTLB:    3183761    3010846    2658535    2572622    3065747    3268356    2652696    2713237   TLB shootdowns\nTRM:          0          0          0          0          0          0          0          0   Thermal event interrupts\nTHR:          0          0          0          0          0          0          0          0   Threshold APIC interrupts\nMCE:          0          0          0          0          0          0          0          0   Machine check exceptions\nMCP:       4340       4340       4340       4340       4340       4340       4340       4340   Machine check polls\nERR:          0\nMIS:          0\n\n第一列是已经安装的中断处理例程的中断号；\n第二至九列分别是每个cpu收到的中断数量；\n第十列是处理中断的可编程中断控制器信息；\n第十一列是注册中断处理例程的设备信息。`&lt;/pre&gt;\n\n还有一个和中断相关的文件：/proc/stat \n\nstat文件每行第一个字符串为该行的关键字，其中intr表示的正是中断相关的信息。 \n\nintr后的第一列为接收的中断总数，之后为每个IRQ信号线接收的中断数量。\n\n#### 自动探测IRQ号\n\n驱动程序初始化时，通常需要确定设备将要使用哪条IRQ信号线以便正确的安装处理例程。自动探测IRQ号需要完成的功能是：通知设备产生一个中断信号并观察会发生什么。通常通过两种方法来实现这样的功能：调用内核提供的辅助函数，或者自己实现该功能。\n\n##### **在内核帮助下探测**\n\n内核提供了一些底层函数来探测中断号。它只能在非共享中断的情境下工作，但是大部分设备能够在共享中断状态工作，并且提供了更好的方法来尽量发现配置的中断号。\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`unsigned long probe_irq_on(void);\n这个函数返回一个未安排的中断的位掩码. 驱动必须保留返回的位掩码, 并且在后面传递给 probe_irq_off。 在这个调用之后, 驱动应当安排它的设备产生至少一次中断。\n\nint probe_irq_off(unsigned long);\n在设备已请求一个中断后, 驱动调用这个函数, 作为参数传递之前由 probe_irq_on 返回的位掩码。probe_irq_off 返回在&quot;probe_on&quot;之后发出的中断号。如果没有中断发生, 返回 0 (因此, IRQ 0 不能探测, 但是没有用户设备能够在任何支持的体系上使用它). 如果多于一个中断发生( 模糊的探测 ), probe_irq_off 返回一个负值。\n注意小心使能设备上的中断, 在调用 probe_irq_on 之后启用设备上的中断以及在调用 probe_irq_off 后禁止它们。另外, 在 probe_irq_off 之后需要处理设备上待处理的中断。`&lt;/pre&gt;\n\n##### **实现自己的探测功能**\n\n主要实现功能同上：通知设备产生一个中断信号并观察会发生什么。但实现自己的探测功能一般是启用所有未被占用的中断，然后观察会发生什么。\n\n### 2 实现中断处理例程\n\n类比定时器，实现中断处理例程的注意事项： \n\n1.不能向用户空间发送和接收数据，因为它不是在任何进程的上下文中执行的； \n\n2.不能做任何可能引发休眠的动作； \n\n3.不能调用schule函数； \n\n中断例程的功能：将有关中断接收的信息反馈给设备，并根据正在服务的中断的不同含义对数据进行相应的读和写。 \n\n中断例程的典型任务：如果中断通知进程所等待的时间已经发生，就会唤醒在该设备上的休眠的进程。\n\n#### 处理例程的参数及返回值\n\n中断处理例程常用的三个参数： \n\nint irq：中断号，用于调试信息输出； \n\nvoid *dev_id：客户数据类型，一般是驱动程序的私有信息； \n\nstruct pt_regs *regs：保存处理器进入中断代码前的处理器上下文快照（很少使用）； \n\n例：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`//中断处理例程\nstatic irqreturn_t sample_interrupt(int irq, void *dev_id, struct pt_regs *regs)\n{\n        struct sample_dev *dev = dev_id;\n        /* now `dev&apos; points to the right hardware item */\n        /* .... */\n}\n//和中断处理例程相关联的open代码\nstatic void sample_open(struct inode *inode, struct file *filp)\n{\n        struct sample_dev *dev = hwinfo + MINOR(inode-&amp;gt;i_rdev);\n        request_irq(dev-&amp;gt;irq, sample_interrupt,\n                    0 /* flags */, &quot;sample&quot;, dev /* dev_id */);\n        /*....*/\n        return 0;\n\n}`&lt;/pre&gt;\n\n返回值： \n\n用于指明是否真正处理了一个中断，是则返回IRQ_HANDLED,否则返回IRQ_NONE；同时也可同过下面宏来产生返回值：IRQ_RETVAL(handled)。\n\n#### 启用和禁用中断\n\n禁止和启用单个中断：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;` &amp;lt;asm/irq.h&amp;gt;\n void disable_irq(int irq);\nvoid disable_irq_nosync(int irq);\nvoid enable_irq(int irq);`&lt;/pre&gt;\n\n禁止和启用所有中断：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`&amp;lt;asm/system.h&amp;gt;\nvoid local_irq_save(unsigned long flags);\nvoid local_irq_disable(void);\nvoid local_irq_restore(unsigned long flags); \nvoid local_irq_enable(void);\n</code></pre><h3 id=\"3-中断的顶半部和下半部\"><a href=\"#3-中断的顶半部和下半部\" class=\"headerlink\" title=\"3 中断的顶半部和下半部\"></a>3 中断的顶半部和下半部</h3><p>中断处理的一个主要问题是如何处理耗时任务。 </p>\n<p>Linux (许多其他系统一起)通过将中断处理分为 2 部分解决这个问题。实际响应中断的例程，称为顶半部，也就是用request_irq注册的终端例程。底半部，被顶半部调度，并在稍后安全时间内执行的例程。 </p>\n<p>linux有两种机制来实现底半部的处理：tasklet和工作队列。tasklet非常快，但是它的代码必须是原子的；工作队列具有更高的延迟，但允许休眠。这两种机制都在《时间、延迟和延缓操作》中讲到，这里略过。</p>\n<h3 id=\"4-中断共享\"><a href=\"#4-中断共享\" class=\"headerlink\" title=\"4 中断共享\"></a>4 中断共享</h3><h4 id=\"安装共享处理例程\"><a href=\"#安装共享处理例程\" class=\"headerlink\" title=\"安装共享处理例程\"></a>安装共享处理例程</h4><p>共享中断通过 request_irq 来安装就像不共享的一样, 但是有 2 个不同: </p>\n<p>1.当请求中断时，必须在 flags 参数中指定,SA_SHIRQ 位。 </p>\n<p>2.dev_id 参数必须是唯一的。任何模块地址空间的指针都行, 但是 dev_id 明确地不能设置为 NULL。 </p>\n<p>内核保持着一个与中断相关联的共享处理者列表, 并且 dev_id 可认为是区别它们的签名. 如果 2 个驱动要在同一个中断上注册 NULL 作为它们的签名, 在卸载时事情可能就乱了, 在中断到的时候引发内核 oops. 由于这个理由, 如果在注册共享中断时传给了一个 NULL dev_id , 现代内核会大声抱怨. 当请求一个共享的中断, request_irq 成功, 如果下列之一是真: </p>\n<p>1.中断线空闲。 </p>\n<p>2.所有这条线的已经注册的处理者也指定共享这个 IRQ。 </p>\n<p>释放处理例程：free_irq。 </p>\n<p>注意：不能使用enable_irq和disable_irq。如果使用了，共享中断信号线的其他设备就无法正常工作了。</p>\n<h3 id=\"中断驱动的I-O\"><a href=\"#中断驱动的I-O\" class=\"headerlink\" title=\"中断驱动的I/O\"></a>中断驱动的I/O</h3><p>如果与驱动程序管理的硬件之间的数据传输因为某种原因而延迟, 驱动编写者应当实现缓冲。数据缓存有助于将数据的传送和接收与系统调用read和write分离开来，从而提高系统的性能。</p>\n<p>一个好的缓存机制需采用中断驱动的 I/O，一个输入缓冲在中断时填充并且被读取设备的进程清空; 一个输出缓存由写设备的进程填充并且在中断时清空。 </p>\n<p>为使中断驱动的数据传送成功发生, 硬件应当使用下列语义产生中断 : </p>\n<p>1.对于输入, 当新数据到达时, 并且准备好被系统处理器获取时，设备中断处理器。实际动作依赖设备使用的是I/O 端口, 内存映射, 还是 DMA。 </p>\n<p>2.对于输出, 或者当它准备好接受新数据, 或者确认一个成功的数据传送时，设备递交一个中断。 内存映射的和能DMA的设备常常产生中断来告诉系统它们完成了这个缓存。</p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/9/29 17:30:10 [原文链接](http://blog.csdn.net/weiniluo/article/details/52625432)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：483 评论：1 [查看评论](http://blog.csdn.net/weiniluo/article/details/52625432#comments)\n&lt;/div&gt;\n</code></pre>"},{"title":"[原]并发与竞态","date":"2016-04-27T19:40:50.000Z","_content":"\n### 1 中断屏蔽\n\n    #include &lt;linux/irqflags.h&gt;\n    local_irq_disable();\n    local_irq_enable();\n    local_irq_save(flags);\n    local_irq_restore(flags);\n    `</pre>\n\n    ### 2 原子操作\n\n    <pre class=\"prettyprint\">`#include &lt;asm/atomic.h&gt;\n    atomic_t v;\n    //讲原子变量的值初始化为i\n    v=ATOMIC_INIT(i);\n    atomic_set(&amp;v, i);\n\n    atomic_read(v);//读取原子变量的值\n    void atomic_add(int i, atomic_t *v);\n    void atomic_sub(int i, atomic_t *v);\n    void atomic_inc(atomic_t *v);\n    void atomic_dec(atomic_t *v);\n    atomic_sub_and_test(i, v);\n    atomic_dec_and_test(v);\n    atomic_inc_and_test(v);\n    atomic_dec_return(v);\n    atomic_inc_return(v);\n     int atomic_add_negative(int i, atomic_t *v)`</pre>\n\n    ### 3 自旋锁\n\n    <pre class=\"prettyprint\">`自旋锁在获取锁之前一直进入忙循环并重复检查锁是否被解锁，可用于不能休眠的流程中，例如中断处理等。\n    拥有自旋锁时禁止中断；\n    自旋锁拥有时间尽可能短；\n    自旋锁下的执行函数不能休眠；\n    1.普通自旋锁\n    #include &lt;linux/spinlock.h&gt;\n    #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)\n    spinlock_t  lock=SPIN_LOCK_UNLOCK;\n    #else\n    DEFINE_SPINLOCK(lock);\n    #endif\n\n    spin_lock_init(&amp;lock);\n\n    void spin_lock(&amp;lock);\n    void  spin_lock_bh(&amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\n    void spin_lock_irq(&amp;lock);//获取自旋锁之前禁止中断\n    spin_lock_irqsave(&amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\n    void spin_unlock(&amp;lock);\n    void spin_unlock_bh(&amp;lock);//释放自旋锁，并恢复软件中断\n    void spin_unlock_irq(&amp;lock);//释放自旋锁，并打开中断\n    void spin_unlock_irqrestore(&amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\n    非阻塞自旋锁获取：\n    成功返回非零值，否则返回零\n    int spin_trylock(&amp;lock);\n    int spin_trylock_bh(&amp;lock);\n    int spin_trylock_irq(&amp;lock);\n\n    2.读写自旋锁\n    #include &lt;linux/rwlock.h&gt;\n    #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)\n    rwlock_t lock=RW_LOCK_UNLOCK;\n    #else\n    DEFINE_RWLOCK(lock);\n    #endif\n\n    rwlock_init(&amp;lock);\n\n    read_lock(&amp;lock);\n    read_lock_bh(&amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\n    read_lock_irq(&amp;lock);//获取自旋锁之前禁止中断\n    read_lock_irqsave(&amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\n    read_unlock(&amp;lock);\n    read_unlock_bh(&amp;lock);//释放自旋锁，并恢复软件中断\n    read_unlock_irq(&amp;lock);//释放自旋锁，并打开中断\n    read_unlock_irqrestore(&amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\n    write_lock(&amp;lock);\n    write_lock_bh(&amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\n    write_lock_irq(&amp;lock);//获取自旋锁之前禁止中断\n    write_lock_irqsave(&amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\n    write_unlock(&amp;lock);\n    write_unlock_bh(&amp;lock);//释放自旋锁，并恢复软件中断\n    write_unlock_irq(&amp;lock);//释放自旋锁，并打开中断\n    write_unlock_irqrestore(&amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\n    非阻塞自旋锁获取：\n    成功返回非零值，否则返回零\n    read_trylock(&amp;lock);\n    read_unlock_irqrestore(&amp;lock, flags);\n    write_trylock(&amp;lock);\n    `</pre>\n\n    ### 4 信号量\n\n    <pre class=\"prettyprint\">`信号量在获取过程中会休眠，所以不能用于不能休眠的流程中，例如中断处理等。\n    1.普通信号量\n    #include &lt;asm/semaphore.h&gt;\n    struct semaphore sem;\n    初始化方式一：\n    void sema_init(&amp;sem,val);\n    初始化方式二：\n    #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,36)\n    DECLARE_MUTEX(sem);\n    #else\n    DEFINE_SEMAPHORE(sem);\n    #endif\n    初始化方式三：\n    //在2.6.25后该函数已被废除。请用sema_init(&amp;sem,1);替代\n    void init_MUTEX(&amp;sem);\n    void init_MUTEX_LOCKED(&amp;sem);\n\n    void down(&amp;sem);//获取信号量\n    int down_interruptible(&amp;sem);//获取信号量，可被中断\n    int down_trylock(&amp;sem);//获取信号量，永不休眠\n    void up(&amp;sem);释放信号量\n    2.读写信号量\n    #include &lt;linux/rwsem.h&gt;\n    struct rw_semaphore rw_sem;\n    void init_rwsem(&amp;rw_sem);\n\n    void down_read(&amp;rw_sem);//获取信号量\n    int down_read_trylock(&amp;rw_sem);//获取信号量，永不休眠\n    void up_read(&amp;rw_sem);释放信号量\n\n    void down_write(&amp;rw_sem);//获取信号量\n    int down_write_trylock(&amp;rw_sem);//获取信号量，永不休眠\n    void up_write(&amp;rw_sem);释放信号量\n    void downgrade_write(&amp;rw_sem);`</pre>\n\n    ### 5 互斥体\n\n    <pre class=\"prettyprint\">`互斥体的使用方法和场景与信号量完全一样。\n    #include &lt;linux/mutex.h&gt;\n    struct mutex mux;\n    mutex_init(mutex);\n\n    void mutex_lock(struct mutex *lock);\n    int __must_check mutex_lock_interruptible(struct mutex *lock);\n    int mutex_trylock(struct mutex *lock);\n\n    void mutex_unlock(struct mutex *lock);`</pre>\n\n    ### 6 completion\n\n    <pre class=\"prettyprint\">`常用于进程、线程间同步\n    #include &lt;linux/completion.h&gt;\n    //不用声明，详细请查看头文件定义\n    DECLARE_COMPLETION(comp);\n    //动态创建和初始化\n    struct completion comp;\n    void init_completion(&amp;comp);\n    //等待完成\n    void wait_for_completion(&amp;comp);\n    //触发完成\n    void complete(&amp;comp)；\n    void complete_all(&amp;comp)；`</pre>\n\n    ### 7 位操作\n\n    <pre class=\"prettyprint\">`//定义：include/asm-generic/bitops/atomic.h\n    #include &lt;asm/bitops.h&gt;\n    //设置addr地址的第nr位\n    void set_bit(int nr, volatile unsigned long *addr);\n    //清除addr地址的第nr位\n    void clear_bit(int nr, volatile unsigned long *addr);\n    //切换addr地址的第nr位\n    void change_bit(int nr, volatile unsigned long *addr);\n    //设置addr地址的第nr位并返回这个位的先前值\n    int test_and_set_bit(int nr, volatile unsigned long *addr);\n    //清除addr地址的第nr位并返回这个位的先前值\n    int test_and_clear_bit(int nr, volatile unsigned long *addr);\n    //切换addr地址的第nr位并返回这个位的先前值\n    int test_and_change_bit(int nr, volatile unsigned long *addr);`</pre>\n\n    ### 8 seqlock\n\n    <pre class=\"prettyprint\">`#include &lt;linux/seqlock.h&gt;\n    DEFINE_SEQLOCK(lock);\n    seqlock_init(lock);\n    //用于获取seqlock保护的资源的读取访问函数\n    unsigned read_seqbegin(const seqlock_t *sl);\n    //用于获取seqlock保护的资源的写入访问函数\n    void write_seqlock(seqlock_t *sl);\n    //用于释放seqlock保护的资源的写入访问函数\n    void write_sequnlock(seqlock_t *sl);\n    以上的读写函数还有很多变种，需要的请查看include/linux/seqlock.h文件`</pre>\n\n    ### 9 RCU（读取-复制-更新）\n\n    <pre class=\"prettyprint\">`#include &lt;linux/rcupdate.h&gt;\n    void rcu_read_unlock(void);\n    void rcu_read_lock(void);\n    void call_rcu(struct rcu_head *head,void (*func)(struct rcu_head *head));\n\n            <div>\n                作者：WEINILUO 发表于2016/4/27 15:40:50 [原文链接](http://blog.csdn.net/weiniluo/article/details/51243205)\n            </div>\n            <div>\n            阅读：97 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51243205#comments)\n            </div>\n","source":"_posts/原-并发与竞态.md","raw":"---\ntitle: '[原]并发与竞态'\ntags: []\ndate: 2016-04-27 15:40:50\n---\n\n### 1 中断屏蔽\n\n    #include &lt;linux/irqflags.h&gt;\n    local_irq_disable();\n    local_irq_enable();\n    local_irq_save(flags);\n    local_irq_restore(flags);\n    `</pre>\n\n    ### 2 原子操作\n\n    <pre class=\"prettyprint\">`#include &lt;asm/atomic.h&gt;\n    atomic_t v;\n    //讲原子变量的值初始化为i\n    v=ATOMIC_INIT(i);\n    atomic_set(&amp;v, i);\n\n    atomic_read(v);//读取原子变量的值\n    void atomic_add(int i, atomic_t *v);\n    void atomic_sub(int i, atomic_t *v);\n    void atomic_inc(atomic_t *v);\n    void atomic_dec(atomic_t *v);\n    atomic_sub_and_test(i, v);\n    atomic_dec_and_test(v);\n    atomic_inc_and_test(v);\n    atomic_dec_return(v);\n    atomic_inc_return(v);\n     int atomic_add_negative(int i, atomic_t *v)`</pre>\n\n    ### 3 自旋锁\n\n    <pre class=\"prettyprint\">`自旋锁在获取锁之前一直进入忙循环并重复检查锁是否被解锁，可用于不能休眠的流程中，例如中断处理等。\n    拥有自旋锁时禁止中断；\n    自旋锁拥有时间尽可能短；\n    自旋锁下的执行函数不能休眠；\n    1.普通自旋锁\n    #include &lt;linux/spinlock.h&gt;\n    #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)\n    spinlock_t  lock=SPIN_LOCK_UNLOCK;\n    #else\n    DEFINE_SPINLOCK(lock);\n    #endif\n\n    spin_lock_init(&amp;lock);\n\n    void spin_lock(&amp;lock);\n    void  spin_lock_bh(&amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\n    void spin_lock_irq(&amp;lock);//获取自旋锁之前禁止中断\n    spin_lock_irqsave(&amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\n    void spin_unlock(&amp;lock);\n    void spin_unlock_bh(&amp;lock);//释放自旋锁，并恢复软件中断\n    void spin_unlock_irq(&amp;lock);//释放自旋锁，并打开中断\n    void spin_unlock_irqrestore(&amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\n    非阻塞自旋锁获取：\n    成功返回非零值，否则返回零\n    int spin_trylock(&amp;lock);\n    int spin_trylock_bh(&amp;lock);\n    int spin_trylock_irq(&amp;lock);\n\n    2.读写自旋锁\n    #include &lt;linux/rwlock.h&gt;\n    #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,19)\n    rwlock_t lock=RW_LOCK_UNLOCK;\n    #else\n    DEFINE_RWLOCK(lock);\n    #endif\n\n    rwlock_init(&amp;lock);\n\n    read_lock(&amp;lock);\n    read_lock_bh(&amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\n    read_lock_irq(&amp;lock);//获取自旋锁之前禁止中断\n    read_lock_irqsave(&amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\n    read_unlock(&amp;lock);\n    read_unlock_bh(&amp;lock);//释放自旋锁，并恢复软件中断\n    read_unlock_irq(&amp;lock);//释放自旋锁，并打开中断\n    read_unlock_irqrestore(&amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\n    write_lock(&amp;lock);\n    write_lock_bh(&amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\n    write_lock_irq(&amp;lock);//获取自旋锁之前禁止中断\n    write_lock_irqsave(&amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\n    write_unlock(&amp;lock);\n    write_unlock_bh(&amp;lock);//释放自旋锁，并恢复软件中断\n    write_unlock_irq(&amp;lock);//释放自旋锁，并打开中断\n    write_unlock_irqrestore(&amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\n    非阻塞自旋锁获取：\n    成功返回非零值，否则返回零\n    read_trylock(&amp;lock);\n    read_unlock_irqrestore(&amp;lock, flags);\n    write_trylock(&amp;lock);\n    `</pre>\n\n    ### 4 信号量\n\n    <pre class=\"prettyprint\">`信号量在获取过程中会休眠，所以不能用于不能休眠的流程中，例如中断处理等。\n    1.普通信号量\n    #include &lt;asm/semaphore.h&gt;\n    struct semaphore sem;\n    初始化方式一：\n    void sema_init(&amp;sem,val);\n    初始化方式二：\n    #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,36)\n    DECLARE_MUTEX(sem);\n    #else\n    DEFINE_SEMAPHORE(sem);\n    #endif\n    初始化方式三：\n    //在2.6.25后该函数已被废除。请用sema_init(&amp;sem,1);替代\n    void init_MUTEX(&amp;sem);\n    void init_MUTEX_LOCKED(&amp;sem);\n\n    void down(&amp;sem);//获取信号量\n    int down_interruptible(&amp;sem);//获取信号量，可被中断\n    int down_trylock(&amp;sem);//获取信号量，永不休眠\n    void up(&amp;sem);释放信号量\n    2.读写信号量\n    #include &lt;linux/rwsem.h&gt;\n    struct rw_semaphore rw_sem;\n    void init_rwsem(&amp;rw_sem);\n\n    void down_read(&amp;rw_sem);//获取信号量\n    int down_read_trylock(&amp;rw_sem);//获取信号量，永不休眠\n    void up_read(&amp;rw_sem);释放信号量\n\n    void down_write(&amp;rw_sem);//获取信号量\n    int down_write_trylock(&amp;rw_sem);//获取信号量，永不休眠\n    void up_write(&amp;rw_sem);释放信号量\n    void downgrade_write(&amp;rw_sem);`</pre>\n\n    ### 5 互斥体\n\n    <pre class=\"prettyprint\">`互斥体的使用方法和场景与信号量完全一样。\n    #include &lt;linux/mutex.h&gt;\n    struct mutex mux;\n    mutex_init(mutex);\n\n    void mutex_lock(struct mutex *lock);\n    int __must_check mutex_lock_interruptible(struct mutex *lock);\n    int mutex_trylock(struct mutex *lock);\n\n    void mutex_unlock(struct mutex *lock);`</pre>\n\n    ### 6 completion\n\n    <pre class=\"prettyprint\">`常用于进程、线程间同步\n    #include &lt;linux/completion.h&gt;\n    //不用声明，详细请查看头文件定义\n    DECLARE_COMPLETION(comp);\n    //动态创建和初始化\n    struct completion comp;\n    void init_completion(&amp;comp);\n    //等待完成\n    void wait_for_completion(&amp;comp);\n    //触发完成\n    void complete(&amp;comp)；\n    void complete_all(&amp;comp)；`</pre>\n\n    ### 7 位操作\n\n    <pre class=\"prettyprint\">`//定义：include/asm-generic/bitops/atomic.h\n    #include &lt;asm/bitops.h&gt;\n    //设置addr地址的第nr位\n    void set_bit(int nr, volatile unsigned long *addr);\n    //清除addr地址的第nr位\n    void clear_bit(int nr, volatile unsigned long *addr);\n    //切换addr地址的第nr位\n    void change_bit(int nr, volatile unsigned long *addr);\n    //设置addr地址的第nr位并返回这个位的先前值\n    int test_and_set_bit(int nr, volatile unsigned long *addr);\n    //清除addr地址的第nr位并返回这个位的先前值\n    int test_and_clear_bit(int nr, volatile unsigned long *addr);\n    //切换addr地址的第nr位并返回这个位的先前值\n    int test_and_change_bit(int nr, volatile unsigned long *addr);`</pre>\n\n    ### 8 seqlock\n\n    <pre class=\"prettyprint\">`#include &lt;linux/seqlock.h&gt;\n    DEFINE_SEQLOCK(lock);\n    seqlock_init(lock);\n    //用于获取seqlock保护的资源的读取访问函数\n    unsigned read_seqbegin(const seqlock_t *sl);\n    //用于获取seqlock保护的资源的写入访问函数\n    void write_seqlock(seqlock_t *sl);\n    //用于释放seqlock保护的资源的写入访问函数\n    void write_sequnlock(seqlock_t *sl);\n    以上的读写函数还有很多变种，需要的请查看include/linux/seqlock.h文件`</pre>\n\n    ### 9 RCU（读取-复制-更新）\n\n    <pre class=\"prettyprint\">`#include &lt;linux/rcupdate.h&gt;\n    void rcu_read_unlock(void);\n    void rcu_read_lock(void);\n    void call_rcu(struct rcu_head *head,void (*func)(struct rcu_head *head));\n\n            <div>\n                作者：WEINILUO 发表于2016/4/27 15:40:50 [原文链接](http://blog.csdn.net/weiniluo/article/details/51243205)\n            </div>\n            <div>\n            阅读：97 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51243205#comments)\n            </div>\n","slug":"原-并发与竞态","published":1,"updated":"2016-10-20T09:58:08.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnod6000dvzs6h9pj9yct","content":"<h3 id=\"1-中断屏蔽\"><a href=\"#1-中断屏蔽\" class=\"headerlink\" title=\"1 中断屏蔽\"></a>1 中断屏蔽</h3><pre><code>#include &amp;lt;linux/irqflags.h&amp;gt;\nlocal_irq_disable();\nlocal_irq_enable();\nlocal_irq_save(flags);\nlocal_irq_restore(flags);\n`&lt;/pre&gt;\n\n### 2 原子操作\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;asm/atomic.h&amp;gt;\natomic_t v;\n//讲原子变量的值初始化为i\nv=ATOMIC_INIT(i);\natomic_set(&amp;amp;v, i);\n\natomic_read(v);//读取原子变量的值\nvoid atomic_add(int i, atomic_t *v);\nvoid atomic_sub(int i, atomic_t *v);\nvoid atomic_inc(atomic_t *v);\nvoid atomic_dec(atomic_t *v);\natomic_sub_and_test(i, v);\natomic_dec_and_test(v);\natomic_inc_and_test(v);\natomic_dec_return(v);\natomic_inc_return(v);\n int atomic_add_negative(int i, atomic_t *v)`&lt;/pre&gt;\n\n### 3 自旋锁\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`自旋锁在获取锁之前一直进入忙循环并重复检查锁是否被解锁，可用于不能休眠的流程中，例如中断处理等。\n拥有自旋锁时禁止中断；\n自旋锁拥有时间尽可能短；\n自旋锁下的执行函数不能休眠；\n1.普通自旋锁\n#include &amp;lt;linux/spinlock.h&amp;gt;\n#if LINUX_VERSION_CODE &amp;lt; KERNEL_VERSION(2,6,19)\nspinlock_t  lock=SPIN_LOCK_UNLOCK;\n#else\nDEFINE_SPINLOCK(lock);\n#endif\n\nspin_lock_init(&amp;amp;lock);\n\nvoid spin_lock(&amp;amp;lock);\nvoid  spin_lock_bh(&amp;amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\nvoid spin_lock_irq(&amp;amp;lock);//获取自旋锁之前禁止中断\nspin_lock_irqsave(&amp;amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\nvoid spin_unlock(&amp;amp;lock);\nvoid spin_unlock_bh(&amp;amp;lock);//释放自旋锁，并恢复软件中断\nvoid spin_unlock_irq(&amp;amp;lock);//释放自旋锁，并打开中断\nvoid spin_unlock_irqrestore(&amp;amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\n非阻塞自旋锁获取：\n成功返回非零值，否则返回零\nint spin_trylock(&amp;amp;lock);\nint spin_trylock_bh(&amp;amp;lock);\nint spin_trylock_irq(&amp;amp;lock);\n\n2.读写自旋锁\n#include &amp;lt;linux/rwlock.h&amp;gt;\n#if LINUX_VERSION_CODE &amp;lt; KERNEL_VERSION(2,6,19)\nrwlock_t lock=RW_LOCK_UNLOCK;\n#else\nDEFINE_RWLOCK(lock);\n#endif\n\nrwlock_init(&amp;amp;lock);\n\nread_lock(&amp;amp;lock);\nread_lock_bh(&amp;amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\nread_lock_irq(&amp;amp;lock);//获取自旋锁之前禁止中断\nread_lock_irqsave(&amp;amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\nread_unlock(&amp;amp;lock);\nread_unlock_bh(&amp;amp;lock);//释放自旋锁，并恢复软件中断\nread_unlock_irq(&amp;amp;lock);//释放自旋锁，并打开中断\nread_unlock_irqrestore(&amp;amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\nwrite_lock(&amp;amp;lock);\nwrite_lock_bh(&amp;amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\nwrite_lock_irq(&amp;amp;lock);//获取自旋锁之前禁止中断\nwrite_lock_irqsave(&amp;amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\nwrite_unlock(&amp;amp;lock);\nwrite_unlock_bh(&amp;amp;lock);//释放自旋锁，并恢复软件中断\nwrite_unlock_irq(&amp;amp;lock);//释放自旋锁，并打开中断\nwrite_unlock_irqrestore(&amp;amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\n非阻塞自旋锁获取：\n成功返回非零值，否则返回零\nread_trylock(&amp;amp;lock);\nread_unlock_irqrestore(&amp;amp;lock, flags);\nwrite_trylock(&amp;amp;lock);\n`&lt;/pre&gt;\n\n### 4 信号量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`信号量在获取过程中会休眠，所以不能用于不能休眠的流程中，例如中断处理等。\n1.普通信号量\n#include &amp;lt;asm/semaphore.h&amp;gt;\nstruct semaphore sem;\n初始化方式一：\nvoid sema_init(&amp;amp;sem,val);\n初始化方式二：\n#if LINUX_VERSION_CODE &amp;lt; KERNEL_VERSION(2,6,36)\nDECLARE_MUTEX(sem);\n#else\nDEFINE_SEMAPHORE(sem);\n#endif\n初始化方式三：\n//在2.6.25后该函数已被废除。请用sema_init(&amp;amp;sem,1);替代\nvoid init_MUTEX(&amp;amp;sem);\nvoid init_MUTEX_LOCKED(&amp;amp;sem);\n\nvoid down(&amp;amp;sem);//获取信号量\nint down_interruptible(&amp;amp;sem);//获取信号量，可被中断\nint down_trylock(&amp;amp;sem);//获取信号量，永不休眠\nvoid up(&amp;amp;sem);释放信号量\n2.读写信号量\n#include &amp;lt;linux/rwsem.h&amp;gt;\nstruct rw_semaphore rw_sem;\nvoid init_rwsem(&amp;amp;rw_sem);\n\nvoid down_read(&amp;amp;rw_sem);//获取信号量\nint down_read_trylock(&amp;amp;rw_sem);//获取信号量，永不休眠\nvoid up_read(&amp;amp;rw_sem);释放信号量\n\nvoid down_write(&amp;amp;rw_sem);//获取信号量\nint down_write_trylock(&amp;amp;rw_sem);//获取信号量，永不休眠\nvoid up_write(&amp;amp;rw_sem);释放信号量\nvoid downgrade_write(&amp;amp;rw_sem);`&lt;/pre&gt;\n\n### 5 互斥体\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`互斥体的使用方法和场景与信号量完全一样。\n#include &amp;lt;linux/mutex.h&amp;gt;\nstruct mutex mux;\nmutex_init(mutex);\n\nvoid mutex_lock(struct mutex *lock);\nint __must_check mutex_lock_interruptible(struct mutex *lock);\nint mutex_trylock(struct mutex *lock);\n\nvoid mutex_unlock(struct mutex *lock);`&lt;/pre&gt;\n\n### 6 completion\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`常用于进程、线程间同步\n#include &amp;lt;linux/completion.h&amp;gt;\n//不用声明，详细请查看头文件定义\nDECLARE_COMPLETION(comp);\n//动态创建和初始化\nstruct completion comp;\nvoid init_completion(&amp;amp;comp);\n//等待完成\nvoid wait_for_completion(&amp;amp;comp);\n//触发完成\nvoid complete(&amp;amp;comp)；\nvoid complete_all(&amp;amp;comp)；`&lt;/pre&gt;\n\n### 7 位操作\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`//定义：include/asm-generic/bitops/atomic.h\n#include &amp;lt;asm/bitops.h&amp;gt;\n//设置addr地址的第nr位\nvoid set_bit(int nr, volatile unsigned long *addr);\n//清除addr地址的第nr位\nvoid clear_bit(int nr, volatile unsigned long *addr);\n//切换addr地址的第nr位\nvoid change_bit(int nr, volatile unsigned long *addr);\n//设置addr地址的第nr位并返回这个位的先前值\nint test_and_set_bit(int nr, volatile unsigned long *addr);\n//清除addr地址的第nr位并返回这个位的先前值\nint test_and_clear_bit(int nr, volatile unsigned long *addr);\n//切换addr地址的第nr位并返回这个位的先前值\nint test_and_change_bit(int nr, volatile unsigned long *addr);`&lt;/pre&gt;\n\n### 8 seqlock\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;linux/seqlock.h&amp;gt;\nDEFINE_SEQLOCK(lock);\nseqlock_init(lock);\n//用于获取seqlock保护的资源的读取访问函数\nunsigned read_seqbegin(const seqlock_t *sl);\n//用于获取seqlock保护的资源的写入访问函数\nvoid write_seqlock(seqlock_t *sl);\n//用于释放seqlock保护的资源的写入访问函数\nvoid write_sequnlock(seqlock_t *sl);\n以上的读写函数还有很多变种，需要的请查看include/linux/seqlock.h文件`&lt;/pre&gt;\n\n### 9 RCU（读取-复制-更新）\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;linux/rcupdate.h&amp;gt;\nvoid rcu_read_unlock(void);\nvoid rcu_read_lock(void);\nvoid call_rcu(struct rcu_head *head,void (*func)(struct rcu_head *head));\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/4/27 15:40:50 [原文链接](http://blog.csdn.net/weiniluo/article/details/51243205)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：97 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51243205#comments)\n        &lt;/div&gt;\n</code></pre>","excerpt":"","more":"<h3 id=\"1-中断屏蔽\"><a href=\"#1-中断屏蔽\" class=\"headerlink\" title=\"1 中断屏蔽\"></a>1 中断屏蔽</h3><pre><code>#include &amp;lt;linux/irqflags.h&amp;gt;\nlocal_irq_disable();\nlocal_irq_enable();\nlocal_irq_save(flags);\nlocal_irq_restore(flags);\n`&lt;/pre&gt;\n\n### 2 原子操作\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;asm/atomic.h&amp;gt;\natomic_t v;\n//讲原子变量的值初始化为i\nv=ATOMIC_INIT(i);\natomic_set(&amp;amp;v, i);\n\natomic_read(v);//读取原子变量的值\nvoid atomic_add(int i, atomic_t *v);\nvoid atomic_sub(int i, atomic_t *v);\nvoid atomic_inc(atomic_t *v);\nvoid atomic_dec(atomic_t *v);\natomic_sub_and_test(i, v);\natomic_dec_and_test(v);\natomic_inc_and_test(v);\natomic_dec_return(v);\natomic_inc_return(v);\n int atomic_add_negative(int i, atomic_t *v)`&lt;/pre&gt;\n\n### 3 自旋锁\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`自旋锁在获取锁之前一直进入忙循环并重复检查锁是否被解锁，可用于不能休眠的流程中，例如中断处理等。\n拥有自旋锁时禁止中断；\n自旋锁拥有时间尽可能短；\n自旋锁下的执行函数不能休眠；\n1.普通自旋锁\n#include &amp;lt;linux/spinlock.h&amp;gt;\n#if LINUX_VERSION_CODE &amp;lt; KERNEL_VERSION(2,6,19)\nspinlock_t  lock=SPIN_LOCK_UNLOCK;\n#else\nDEFINE_SPINLOCK(lock);\n#endif\n\nspin_lock_init(&amp;amp;lock);\n\nvoid spin_lock(&amp;amp;lock);\nvoid  spin_lock_bh(&amp;amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\nvoid spin_lock_irq(&amp;amp;lock);//获取自旋锁之前禁止中断\nspin_lock_irqsave(&amp;amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\nvoid spin_unlock(&amp;amp;lock);\nvoid spin_unlock_bh(&amp;amp;lock);//释放自旋锁，并恢复软件中断\nvoid spin_unlock_irq(&amp;amp;lock);//释放自旋锁，并打开中断\nvoid spin_unlock_irqrestore(&amp;amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\n非阻塞自旋锁获取：\n成功返回非零值，否则返回零\nint spin_trylock(&amp;amp;lock);\nint spin_trylock_bh(&amp;amp;lock);\nint spin_trylock_irq(&amp;amp;lock);\n\n2.读写自旋锁\n#include &amp;lt;linux/rwlock.h&amp;gt;\n#if LINUX_VERSION_CODE &amp;lt; KERNEL_VERSION(2,6,19)\nrwlock_t lock=RW_LOCK_UNLOCK;\n#else\nDEFINE_RWLOCK(lock);\n#endif\n\nrwlock_init(&amp;amp;lock);\n\nread_lock(&amp;amp;lock);\nread_lock_bh(&amp;amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\nread_lock_irq(&amp;amp;lock);//获取自旋锁之前禁止中断\nread_lock_irqsave(&amp;amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\nread_unlock(&amp;amp;lock);\nread_unlock_bh(&amp;amp;lock);//释放自旋锁，并恢复软件中断\nread_unlock_irq(&amp;amp;lock);//释放自旋锁，并打开中断\nread_unlock_irqrestore(&amp;amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\nwrite_lock(&amp;amp;lock);\nwrite_lock_bh(&amp;amp;lock);//获取自旋锁之前禁止软件中断，但硬件中断保持打开\nwrite_lock_irq(&amp;amp;lock);//获取自旋锁之前禁止中断\nwrite_lock_irqsave(&amp;amp;lock, flags);//获取自旋锁之前禁止中断，并将之前的中断状态保存在flags中\n\nwrite_unlock(&amp;amp;lock);\nwrite_unlock_bh(&amp;amp;lock);//释放自旋锁，并恢复软件中断\nwrite_unlock_irq(&amp;amp;lock);//释放自旋锁，并打开中断\nwrite_unlock_irqrestore(&amp;amp;lock, flags);//释放自旋锁，并将之前的中断状态恢复后打开中断\n\n非阻塞自旋锁获取：\n成功返回非零值，否则返回零\nread_trylock(&amp;amp;lock);\nread_unlock_irqrestore(&amp;amp;lock, flags);\nwrite_trylock(&amp;amp;lock);\n`&lt;/pre&gt;\n\n### 4 信号量\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`信号量在获取过程中会休眠，所以不能用于不能休眠的流程中，例如中断处理等。\n1.普通信号量\n#include &amp;lt;asm/semaphore.h&amp;gt;\nstruct semaphore sem;\n初始化方式一：\nvoid sema_init(&amp;amp;sem,val);\n初始化方式二：\n#if LINUX_VERSION_CODE &amp;lt; KERNEL_VERSION(2,6,36)\nDECLARE_MUTEX(sem);\n#else\nDEFINE_SEMAPHORE(sem);\n#endif\n初始化方式三：\n//在2.6.25后该函数已被废除。请用sema_init(&amp;amp;sem,1);替代\nvoid init_MUTEX(&amp;amp;sem);\nvoid init_MUTEX_LOCKED(&amp;amp;sem);\n\nvoid down(&amp;amp;sem);//获取信号量\nint down_interruptible(&amp;amp;sem);//获取信号量，可被中断\nint down_trylock(&amp;amp;sem);//获取信号量，永不休眠\nvoid up(&amp;amp;sem);释放信号量\n2.读写信号量\n#include &amp;lt;linux/rwsem.h&amp;gt;\nstruct rw_semaphore rw_sem;\nvoid init_rwsem(&amp;amp;rw_sem);\n\nvoid down_read(&amp;amp;rw_sem);//获取信号量\nint down_read_trylock(&amp;amp;rw_sem);//获取信号量，永不休眠\nvoid up_read(&amp;amp;rw_sem);释放信号量\n\nvoid down_write(&amp;amp;rw_sem);//获取信号量\nint down_write_trylock(&amp;amp;rw_sem);//获取信号量，永不休眠\nvoid up_write(&amp;amp;rw_sem);释放信号量\nvoid downgrade_write(&amp;amp;rw_sem);`&lt;/pre&gt;\n\n### 5 互斥体\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`互斥体的使用方法和场景与信号量完全一样。\n#include &amp;lt;linux/mutex.h&amp;gt;\nstruct mutex mux;\nmutex_init(mutex);\n\nvoid mutex_lock(struct mutex *lock);\nint __must_check mutex_lock_interruptible(struct mutex *lock);\nint mutex_trylock(struct mutex *lock);\n\nvoid mutex_unlock(struct mutex *lock);`&lt;/pre&gt;\n\n### 6 completion\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`常用于进程、线程间同步\n#include &amp;lt;linux/completion.h&amp;gt;\n//不用声明，详细请查看头文件定义\nDECLARE_COMPLETION(comp);\n//动态创建和初始化\nstruct completion comp;\nvoid init_completion(&amp;amp;comp);\n//等待完成\nvoid wait_for_completion(&amp;amp;comp);\n//触发完成\nvoid complete(&amp;amp;comp)；\nvoid complete_all(&amp;amp;comp)；`&lt;/pre&gt;\n\n### 7 位操作\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`//定义：include/asm-generic/bitops/atomic.h\n#include &amp;lt;asm/bitops.h&amp;gt;\n//设置addr地址的第nr位\nvoid set_bit(int nr, volatile unsigned long *addr);\n//清除addr地址的第nr位\nvoid clear_bit(int nr, volatile unsigned long *addr);\n//切换addr地址的第nr位\nvoid change_bit(int nr, volatile unsigned long *addr);\n//设置addr地址的第nr位并返回这个位的先前值\nint test_and_set_bit(int nr, volatile unsigned long *addr);\n//清除addr地址的第nr位并返回这个位的先前值\nint test_and_clear_bit(int nr, volatile unsigned long *addr);\n//切换addr地址的第nr位并返回这个位的先前值\nint test_and_change_bit(int nr, volatile unsigned long *addr);`&lt;/pre&gt;\n\n### 8 seqlock\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;linux/seqlock.h&amp;gt;\nDEFINE_SEQLOCK(lock);\nseqlock_init(lock);\n//用于获取seqlock保护的资源的读取访问函数\nunsigned read_seqbegin(const seqlock_t *sl);\n//用于获取seqlock保护的资源的写入访问函数\nvoid write_seqlock(seqlock_t *sl);\n//用于释放seqlock保护的资源的写入访问函数\nvoid write_sequnlock(seqlock_t *sl);\n以上的读写函数还有很多变种，需要的请查看include/linux/seqlock.h文件`&lt;/pre&gt;\n\n### 9 RCU（读取-复制-更新）\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;linux/rcupdate.h&amp;gt;\nvoid rcu_read_unlock(void);\nvoid rcu_read_lock(void);\nvoid call_rcu(struct rcu_head *head,void (*func)(struct rcu_head *head));\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/4/27 15:40:50 [原文链接](http://blog.csdn.net/weiniluo/article/details/51243205)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：97 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51243205#comments)\n        &lt;/div&gt;\n</code></pre>"},{"title":"[原]时间、延迟及延缓操作","date":"2016-09-21T21:15:35.000Z","_content":"\n### 1.度量时间差\n\n    内核通过定时器中断来跟踪时间流，时钟中断有系统定时硬件以周期性的间隔产生，这个间隔有内核根据HZ的值设定，HZ是一个与体系结构有关的常量，定义在&lt;asm-generic/param.h&gt;中。常用值为100或1000.每发生一次时钟中断，内核内部计数器的值增1，该值在系统引导时被初始化为0。该计数器是一个64位的变量（即使是32位架构也是这样），称为jiffies_64。但是驱动开发人员通常访问jiffies变量，它是unsigned long变量，通常是jiffies_64或者jiffies_64的低32位值。除了jiffy机制，某些cpu平台还有一个软件可读取的高分辨路计数器，以适用于特殊需求。\n    `</pre>\n\n    #### 1.1 使用jiffies计数器\n\n    <pre class=\"prettyprint\">`&lt;linux/jiffies.h&gt;\n    unsigned long j, stamp_1, stamp_half, stamp_n;\n\n    j = jiffies; /* read the current value */\n    stamp_1 = j + HZ; /* 1 second in the future */\n    stamp_half = j + HZ/2; /* half a second */\n    stamp_n = j + n * HZ / 1000; /* n milliseconds */\n\n    //当条件为真，返回真；\n    int time_after(unsigned long a, unsigned long b);//a&gt;b\n    int time_before(unsigned long a, unsigned long b);//a&lt;b\n    int time_after_eq(unsigned long a, unsigned long b);//a&gt;=b\n    int time_before_eq(unsigned long a, unsigned long b);//a&lt;=b\n    //计算时间差\n    diff = (long)t2 - (long)t1;\n    msec = diff * 1000 / HZ; \n    //timespec、timeval与jiffies格式的转换\n    #include &lt;linux/time.h&gt; \n    unsigned long timespec_to_jiffies(struct timespec *value);\n    void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);\n    unsigned long timeval_to_jiffies(struct timeval *value);\n    void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);\n    //在32位平台上原子的获取jiffies_64的值\n    #include &lt;linux/jiffies.h&gt; \n    u64 get_jiffies_64(void);`</pre>\n\n    #### 1.2 处理器特定的计数器\n\n    <pre class=\"prettyprint\">`1.x86平台常用的TSC计数器寄存器：\n    它是一个 64-位 寄存器计数 CPU 的时钟周期; 它可从内核和用户空间读取.\n    &lt;asm/msr.h&gt;\n    rdtsc(low32,high32);\n    rdtscl(low32);\n    rdtscll(var64);\n    第一个宏自动读取 64位 值到 2 个 32位 变量;下一个读取寄存器的低半部到一个32位变量;最后一个读64位值到一个long long变量. 所有这些宏存储数值到它们的参数中.\n    2.体系无关函数get_cycles:\n    #include &lt;linux/timex.h&gt;\n    cycles_t get_cycles(void); \n    在无时钟计数器的平台，返回0。\n    3.通过内嵌汇编实现：\n    #define rdtscl(dest) \\\n    __asm__ __volatile__(\"mfc0 %0,$9; nop\" : \"=r\" (dest))`</pre>\n\n    ### 2.获取当前时间\n\n    内核通常通过查看 jifies 的值来获取当前时间，该数值表示最近一次系统启动到当前的时间间隔，他和设备驱动程序无关，因为他的生命周期只限于系统的运行周期。 \n\n    驱动程序一般不需要知道墙钟时间（日常时间，年月日的表达），只有cron、syslogd类似程序才需要知道。 \n\n    常用的时间相关函数：\n\n    <pre class=\"prettyprint\">`#include &lt;linux/time.h&gt; \n    unsigned long mktime (unsigned int year, unsigned int mon, unsigned int day, unsigned int hour, unsigned int min, unsigned int sec); //将墙钟时间转化为jiffies值\n    void do_gettimeofday(struct timeval *tv);//返回当前时间，但很难原子获取timeval的两个变量\n    struct timespec current_kernel_time(void);//原子的获取当前时间`</pre>\n\n    ### 3.延迟执行\n\n    #### 3.1 长延迟\n\n    <pre class=\"prettyprint\">`1.忙等待\n    如果想执行若干个时钟嘀嗒的延迟，或者对延迟的精度要求不高，可通过一下方法实现：\n    &lt;linux/jiffies.h&gt;\n    unsigned long j, j1;\n    j = jiffies;\n    j1=j+HZ;\n    while (time_before(jiffies, j1))\n        cpu_relax();\n    注意: cpu_relax函数在许多系统上不会做任何事情，而在对称多线程系统上，它可能让出处理器。但是通常情况下我们都应避免这种方式，因为这会严重降低系统性能。在非抢占系统上，在延迟过程中会锁住处理器；如果在进入忙等待前禁止了中断，jiffies值变得不到更新，系统就会死掉！\n    2.让出处理器\n    上面忙等待的方法会增加系统的负担，但延迟的实现有多种方法。延迟的另一种实现方式如下：\n    &lt;linux/jiffies.h&gt;\n    unsigned long j, j1;\n    j = jiffies;\n    j1=j+HZ;\n    while (time_before(jiffies, j1))\n        schedule();\n    注意：这种方式释放了cpu而不做任何事情，但他仍在运行队列中。若系统中只有当前进程运行，这当前进程会立即执行，因此，系统一直处于运行中，空闲任务不会运行，cpu并没有空闲下来。从cpu的角度看，这种方式和忙等待类似。\n    3.超时\n    上面两种方式都会给cpu带来负担，目前最好的方式是让内核完成我们的任务。当前有两种构造基于jiffies超时的途径，这主要取决于驱动程序是否在等待其他事件。\n    第一种途径，驱动程序使用等待队列等待其他一些事件：\n    #include &lt;linux/wait.h&gt;\n    long wait_event_timeout(wait_queue_head_t q, condition, long timeout);\n    long wait_event_interruptible_timeout(wait_queue_head_t q, condition, long timeout);\n    参数：\n    q:队列头\n    condition：条件\n    timeout：返回要等待的事件的jiffies值\n    返回：\n    若是被其他时间唤醒，返回剩余的jiffies值；若是超时到期，返回0。\n    例：\n    #include &lt;linux/wait.h&gt;\n    wait_queue_head_t wait; \n    init_waitqueue_head (&amp;wait); \n    wait_event_interruptible_timeout(wait, 0, delay); \n    第二种途径，驱动程序无需等待其他事件：\n    #include &lt;linux/sched.h&gt;\n    signed long schedule_timeout(signed long timeout);\n    参数：\n    timeout：延迟时间的jiffies值；\n    返回：\n    正常返回0；\n    注意：使用schedule_timeout前需要设置当前进程的状态\n    例：\n    set_current_state(TASK_INTERRUPTIBLE);\n    schedule_timeout (delay);`</pre>\n\n    #### 3.2 短延迟\n\n    <pre class=\"prettyprint\">`如果驱动程序需要处理硬件的延迟，这种延迟通常最多涉及到几十个毫秒。这是通常用ndelay、udelay,以及 mdelay来完成延迟任务。\n    #include &lt;linux/delay.h&gt;\n    void ndelay(unsigned long nsecs);\n    void udelay(unsigned long usecs);\n    void mdelay(unsigned long msecs);\n    这三个方法都是忙等待函数，当然不涉及忙等待的方法也有相应的实现：\n    void msleep(unsigned int millisecs);\n    unsigned long msleep_interruptible(unsigned int millisecs);\n    void ssleep(unsigned int seconds);`</pre>\n\n    ### 4.内核定时器\n\n    内核定时器使用场景：在将来的某个时间点调度执行某个函数，同时在该时间点到达之前不会阻塞当前进程。 \n\n    内核定时器常常作为软件中断的结果而运行的，被调度运行的函数几乎不会再注册这些函数的进程正在执行是运行。在这种原子性的上下文中运行时，定时器函数必须以原子的方式运行（请参照自旋锁和原子上下文相关内容）。定时器函数通常需要遵循以下规则： \n\n    1.不允许访问用户空间，因为没有进程上下文，无法将任何特定进程和用户空间关联。 \n\n    2.current指针在原子模式下无任何意义，因为相关的代码和被中断的进程没有任何关联。 \n\n    3.不能执行休眠和调度，原子代码不能调用 schedule 或者某种 wait_event, 也不能调用任何其他可能睡眠的函数.。例如, 调用 kmalloc(…, GFP_KERNEL) 是违犯规则的. 旗标也必须不能使用因为它们可能睡眠。 \n\n    in_interrupt()和in_atomic(): \n\n    包含在&lt; asm/hardirq.h&gt;中；都是用于内核代码判断自己是否处于中断上下文的函数，但是后者可以用在调度不被允许的情况下，包括硬件中断和软件中断上下文以及拥有自旋锁的任何时间点。 \n\n    注意：任何定时器函数访问的数据结构都应该针对并发访问进行保护。\n\n    #### 4.1 定时器API\n\n    <pre class=\"prettyprint\">`内核提供给驱动许多函数来声明, 注册, 以及去除内核定时器. 下列的引用展示了基本的代码块:\n    #include &lt;linux/timer.h&gt;\n    struct timer_list\n    {\n            /* ... */\n            unsigned long expires;\n            void (*function)(unsigned long);\n            unsigned long data;\n    };\n    void init_timer(struct timer_list *timer);\n    struct timer_list TIMER_INITIALIZER(_function, _expires, _data);\n\n    void add_timer(struct timer_list * timer);\n    int del_timer(struct timer_list * timer);\n\n    //更新某个定时器的到期时间\n    int mod_timer(struct timer_list *timer, unsigned long expires);\n    //和del_timer类似，但是del_timer_sync确保返回时没有任何CPU在运行定时器函数\n    int del_timer_sync(struct timer_list *timer);\n    //返回定时器是否正在被调度运行\n    int timer_pending(const struct timer_list * timer);`</pre>\n\n    #### 4.2 内核定时器的实现\n\n    <pre class=\"prettyprint\">`内核定时器的实现要求：\n    1.定时器的管理必须做到轻量级；\n    2.其设计必须在活动定时器大量增加时具有良好的伸缩性；\n    3.大部分定时器会在最多几秒或者几分钟内到期，很少存在长期延迟的定时器；\n    4.定时器应该在注册他的当前cpu上运行。\n\n    目前的解决方案是利用per-CPU数据结构。\n    无论何时内核代码注册一个定时器( 通过 add_timer 或者 mod_timer), 最终由 internal_add_timer ( 在kernel/timer.c)执行, 它依次添加新定时器到一个双向定时器链表在一个关联到当前 CPU 的\"级联表\" 中。\n    级联表的工作工作方式: 如果定时器在下一个 0 到 255 jiffies 内到期, 则它会被添加到专供短时定时器 256 列表中的一个（这取决于expires 成员的低8位）。如果它在将来更久时间到期（但是在 16,384 jiffies 之前), 它会被添加到基于 expires 成员的 9 - 14 位的 64 个列表中一个. 对于更长的定时器, 同样的技巧用在 15 - 20 位, 21 - 26 位, 和 27 - 31 位. 带有一个指向将来还长时间的 expires 成员的定时器（一些只可能发生在 64-位 平台上的事情）被使用一个延时值 0xffffffff 进行哈希处理, 而在过去时间内到期的定时器将在下一个时钟嘀哒被调度（如果在高负荷情况，有可能注册一个已经到期的定时器，尤其在运行抢占式内核时）。\n    当触发 __run_timers, 它为当前定时器嘀哒执行所有挂起的定时器。如果当前jiffies是256的倍数, 这个函数还会将下一级定时器链表重新散列到256个短期列表中, 同时还可能根据上面jiffies的位划分对其他级别的定时器做级联处理。`</pre>\n\n    ### 5.tasklet\n\n    另一个有关于定时问题的内核设施是 tasklet 机制. 它大部分用在中断管理。\n\n    #### 5.1 tasklet 与内核定时器的异同\n\n    1.它们一直在中断时间运行； \n\n    2.它们一直运行在调度它们的同一个 CPU 上； \n\n    3.它们接收一个 unsigned long 参数； \n\n    4.它们都在“软件中断”上下文原子性执行； \n\n    5.tasklet无法请求在一个指定的时间执行函数，调度tasklet，表示我们只希望内核在其后的某个时间执行指定的函数（因此适用于中断管理）。\n\n    #### 5.2 tasklet 的特色\n\n    1.tasklet 能够被禁止之后能被重新使能; 它不会执行直到它被使能与被禁止相同的次数； \n\n    2.tasklet 可以注册它自己； \n\n    3.tasklet 能以正常的优先级或者高优先级被调度执行，后一组一直是首先执行； \n\n    4.如果系统负荷不重，taslet 能立刻运行,  但是不会晚于下一个时钟嘀哒； \n\n    5.tasklet 可能和其他 tasklet 并发, 但是对它自己是严格地串行的，因为它始终会在地调度自己的同一cpu上运行，从不运行在不同的处理器上。\n\n    #### 5.3 tasklet使用\n\n    <pre class=\"prettyprint\">`#include &lt;linux/interrupt.h&gt; \n    struct tasklet_struct {\n     /* ... */\n\n    void (*func)(unsigned long);\n     unsigned long data;\n    };\n\n    void tasklet_init(struct tasklet_struct *t,\n    void (*func)(unsigned long), unsigned long data);\n    DECLARE_TASKLET(name, func, data);\n    DECLARE_TASKLET_DISABLED(name, func, data);\n    //禁用指定的tasklet\n    void tasklet_disable(struct tasklet_struct *t);\n    //禁用指定的tasklet，但不会等待任何正在运行的tasklet退出\n    void tasklet_disable_nosync(struct tasklet_struct *t);\n    //启用之前被禁用的tasklet\n    void tasklet_enable(struct tasklet_struct *t);\n    //调度指定的tasklet\n    void tasklet_schedule(struct tasklet_struct *t);\n    //禁用指定的tasklet以高优先级执行\n    void tasklet_hi_schedule(struct tasklet_struct *t);\n    //禁止指定的tasklet的再次调度，通用用于设备关闭和模块移除\n    void tasklet_kill(struct tasklet_struct *t);`</pre>\n\n    ### 6.工作队列\n\n    工作队列类似于tasklet，他们都允许内核代码请求某个函数在将来的时间被调用，当时两者之间还是有一些非常重要的区别： \n\n    1.tasklet 在软件中断上下文中运行的结果是所有的 tasklet 代码必须是原子的；相反, 工作队列函数在一个特殊内核进程上下文运行，所以它们有更多的灵活性。注意, 工作队列函数能够睡眠。 \n\n    2.tasklet 常常在它们最初被提交的处理器上运行。但这只是工作队列默认的工作方式。 \n\n    3.内核代码可以请求工作队列函数被延后指定的时间间隔后执行。 \n\n    4.tasklet会在很短的会时间内很快的执行, 并且在原子态, 而工作队列函数可能有更长的延迟而且不需要是原子的。\n\n    #### 6.1 工作队列的使用\n\n    <pre class=\"prettyprint\">`&lt;linux/workqueue.h&gt;\n    //创建工作队列\n    struct workqueue_struct *create_workqueue(const char *name);\n    struct workqueue_struct *create_singlethread_workqueue(const char *name);\n    //编译时向工作队列递交任务\n    DECLARE_WORK(name, void (*function)(void *), void *data);\n    //运行时构造work_struct 结构\n    //INIT_WORK完成所有初始化工作\n    INIT_WORK(struct work_struct *work, void (*function)(void *), void *data); \n    //同INIT_WORK，但不会初始化用来将work_struct结构连接到工作队列的指针\n    PREPARE_WORK(struct work_struct *work, void (*function)(void *), void *data); \n    //将工作递交到工作队列\n    int queue_work(struct workqueue_struct *queue, struct work_struct *work);\n    int queue_delayed_work(struct workqueue_struct *queue, struct work_struct *work, unsigned long delay);\n    //取消某个挂起的工作队列入口项\n    int cancel_delayed_work(struct work_struct *work); \n    //禁止运行被调用之前所有被递交的工作\n    void flush_workqueue(struct workqueue_struct *queue); \n    //释放工作队列\n    void destroy_workqueue(struct workqueue_struct *queue); `</pre>\n\n    #### 6.2 共享队列\n\n    设备驱动, 在许多情况下, 不需要有它自己的工作队列。如果你只偶尔需要提交任务给队列, 简单地使用内核提供的共享的默认工作队列可能更有效。如果你需要使用这个队列，你必须明白你将和别的在共享它，这意味着你不应当长时间独占队列(无长睡眠), 并且可能要更长时间我们的任务才能获得处理器。 \n\n    1.共享队列使用：\n\n    <pre class=\"prettyprint\">`//递交工作任务\n    int schedule_work(struct work_struct *work); \n    //以延迟模式递交工作任务\n    int schedule_delayed_work(struct work_struct *work, unsigned long delay); \n    //刷新共享队列\n    void flush_scheduled_work(void); \n    例：\n    static struct work_struct jiq_work;\n    /* this line is in jiq_init() */\n    INIT_WORK(&amp;jiq_work, jiq_print_wq, &amp;jiq_data);\n    prepare_to_wait(&amp;jiq_wait, &amp;wait, TASK_INTERRUPTIBLE);\n    schedule_work(&amp;jiq_work);\n    schedule();\n    finish_wait(&amp;jiq_wait, &amp;wait);\n\n            <div>\n                作者：WEINILUO 发表于2016/9/21 17:15:35 [原文链接](http://blog.csdn.net/weiniluo/article/details/52540396)\n            </div>\n            <div>\n            阅读：99 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52540396#comments)\n            </div>\n","source":"_posts/原-时间、延迟及延缓操作.md","raw":"---\ntitle: '[原]时间、延迟及延缓操作'\ntags: []\ndate: 2016-09-21 17:15:35\n---\n\n### 1.度量时间差\n\n    内核通过定时器中断来跟踪时间流，时钟中断有系统定时硬件以周期性的间隔产生，这个间隔有内核根据HZ的值设定，HZ是一个与体系结构有关的常量，定义在&lt;asm-generic/param.h&gt;中。常用值为100或1000.每发生一次时钟中断，内核内部计数器的值增1，该值在系统引导时被初始化为0。该计数器是一个64位的变量（即使是32位架构也是这样），称为jiffies_64。但是驱动开发人员通常访问jiffies变量，它是unsigned long变量，通常是jiffies_64或者jiffies_64的低32位值。除了jiffy机制，某些cpu平台还有一个软件可读取的高分辨路计数器，以适用于特殊需求。\n    `</pre>\n\n    #### 1.1 使用jiffies计数器\n\n    <pre class=\"prettyprint\">`&lt;linux/jiffies.h&gt;\n    unsigned long j, stamp_1, stamp_half, stamp_n;\n\n    j = jiffies; /* read the current value */\n    stamp_1 = j + HZ; /* 1 second in the future */\n    stamp_half = j + HZ/2; /* half a second */\n    stamp_n = j + n * HZ / 1000; /* n milliseconds */\n\n    //当条件为真，返回真；\n    int time_after(unsigned long a, unsigned long b);//a&gt;b\n    int time_before(unsigned long a, unsigned long b);//a&lt;b\n    int time_after_eq(unsigned long a, unsigned long b);//a&gt;=b\n    int time_before_eq(unsigned long a, unsigned long b);//a&lt;=b\n    //计算时间差\n    diff = (long)t2 - (long)t1;\n    msec = diff * 1000 / HZ; \n    //timespec、timeval与jiffies格式的转换\n    #include &lt;linux/time.h&gt; \n    unsigned long timespec_to_jiffies(struct timespec *value);\n    void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);\n    unsigned long timeval_to_jiffies(struct timeval *value);\n    void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);\n    //在32位平台上原子的获取jiffies_64的值\n    #include &lt;linux/jiffies.h&gt; \n    u64 get_jiffies_64(void);`</pre>\n\n    #### 1.2 处理器特定的计数器\n\n    <pre class=\"prettyprint\">`1.x86平台常用的TSC计数器寄存器：\n    它是一个 64-位 寄存器计数 CPU 的时钟周期; 它可从内核和用户空间读取.\n    &lt;asm/msr.h&gt;\n    rdtsc(low32,high32);\n    rdtscl(low32);\n    rdtscll(var64);\n    第一个宏自动读取 64位 值到 2 个 32位 变量;下一个读取寄存器的低半部到一个32位变量;最后一个读64位值到一个long long变量. 所有这些宏存储数值到它们的参数中.\n    2.体系无关函数get_cycles:\n    #include &lt;linux/timex.h&gt;\n    cycles_t get_cycles(void); \n    在无时钟计数器的平台，返回0。\n    3.通过内嵌汇编实现：\n    #define rdtscl(dest) \\\n    __asm__ __volatile__(\"mfc0 %0,$9; nop\" : \"=r\" (dest))`</pre>\n\n    ### 2.获取当前时间\n\n    内核通常通过查看 jifies 的值来获取当前时间，该数值表示最近一次系统启动到当前的时间间隔，他和设备驱动程序无关，因为他的生命周期只限于系统的运行周期。 \n\n    驱动程序一般不需要知道墙钟时间（日常时间，年月日的表达），只有cron、syslogd类似程序才需要知道。 \n\n    常用的时间相关函数：\n\n    <pre class=\"prettyprint\">`#include &lt;linux/time.h&gt; \n    unsigned long mktime (unsigned int year, unsigned int mon, unsigned int day, unsigned int hour, unsigned int min, unsigned int sec); //将墙钟时间转化为jiffies值\n    void do_gettimeofday(struct timeval *tv);//返回当前时间，但很难原子获取timeval的两个变量\n    struct timespec current_kernel_time(void);//原子的获取当前时间`</pre>\n\n    ### 3.延迟执行\n\n    #### 3.1 长延迟\n\n    <pre class=\"prettyprint\">`1.忙等待\n    如果想执行若干个时钟嘀嗒的延迟，或者对延迟的精度要求不高，可通过一下方法实现：\n    &lt;linux/jiffies.h&gt;\n    unsigned long j, j1;\n    j = jiffies;\n    j1=j+HZ;\n    while (time_before(jiffies, j1))\n        cpu_relax();\n    注意: cpu_relax函数在许多系统上不会做任何事情，而在对称多线程系统上，它可能让出处理器。但是通常情况下我们都应避免这种方式，因为这会严重降低系统性能。在非抢占系统上，在延迟过程中会锁住处理器；如果在进入忙等待前禁止了中断，jiffies值变得不到更新，系统就会死掉！\n    2.让出处理器\n    上面忙等待的方法会增加系统的负担，但延迟的实现有多种方法。延迟的另一种实现方式如下：\n    &lt;linux/jiffies.h&gt;\n    unsigned long j, j1;\n    j = jiffies;\n    j1=j+HZ;\n    while (time_before(jiffies, j1))\n        schedule();\n    注意：这种方式释放了cpu而不做任何事情，但他仍在运行队列中。若系统中只有当前进程运行，这当前进程会立即执行，因此，系统一直处于运行中，空闲任务不会运行，cpu并没有空闲下来。从cpu的角度看，这种方式和忙等待类似。\n    3.超时\n    上面两种方式都会给cpu带来负担，目前最好的方式是让内核完成我们的任务。当前有两种构造基于jiffies超时的途径，这主要取决于驱动程序是否在等待其他事件。\n    第一种途径，驱动程序使用等待队列等待其他一些事件：\n    #include &lt;linux/wait.h&gt;\n    long wait_event_timeout(wait_queue_head_t q, condition, long timeout);\n    long wait_event_interruptible_timeout(wait_queue_head_t q, condition, long timeout);\n    参数：\n    q:队列头\n    condition：条件\n    timeout：返回要等待的事件的jiffies值\n    返回：\n    若是被其他时间唤醒，返回剩余的jiffies值；若是超时到期，返回0。\n    例：\n    #include &lt;linux/wait.h&gt;\n    wait_queue_head_t wait; \n    init_waitqueue_head (&amp;wait); \n    wait_event_interruptible_timeout(wait, 0, delay); \n    第二种途径，驱动程序无需等待其他事件：\n    #include &lt;linux/sched.h&gt;\n    signed long schedule_timeout(signed long timeout);\n    参数：\n    timeout：延迟时间的jiffies值；\n    返回：\n    正常返回0；\n    注意：使用schedule_timeout前需要设置当前进程的状态\n    例：\n    set_current_state(TASK_INTERRUPTIBLE);\n    schedule_timeout (delay);`</pre>\n\n    #### 3.2 短延迟\n\n    <pre class=\"prettyprint\">`如果驱动程序需要处理硬件的延迟，这种延迟通常最多涉及到几十个毫秒。这是通常用ndelay、udelay,以及 mdelay来完成延迟任务。\n    #include &lt;linux/delay.h&gt;\n    void ndelay(unsigned long nsecs);\n    void udelay(unsigned long usecs);\n    void mdelay(unsigned long msecs);\n    这三个方法都是忙等待函数，当然不涉及忙等待的方法也有相应的实现：\n    void msleep(unsigned int millisecs);\n    unsigned long msleep_interruptible(unsigned int millisecs);\n    void ssleep(unsigned int seconds);`</pre>\n\n    ### 4.内核定时器\n\n    内核定时器使用场景：在将来的某个时间点调度执行某个函数，同时在该时间点到达之前不会阻塞当前进程。 \n\n    内核定时器常常作为软件中断的结果而运行的，被调度运行的函数几乎不会再注册这些函数的进程正在执行是运行。在这种原子性的上下文中运行时，定时器函数必须以原子的方式运行（请参照自旋锁和原子上下文相关内容）。定时器函数通常需要遵循以下规则： \n\n    1.不允许访问用户空间，因为没有进程上下文，无法将任何特定进程和用户空间关联。 \n\n    2.current指针在原子模式下无任何意义，因为相关的代码和被中断的进程没有任何关联。 \n\n    3.不能执行休眠和调度，原子代码不能调用 schedule 或者某种 wait_event, 也不能调用任何其他可能睡眠的函数.。例如, 调用 kmalloc(…, GFP_KERNEL) 是违犯规则的. 旗标也必须不能使用因为它们可能睡眠。 \n\n    in_interrupt()和in_atomic(): \n\n    包含在&lt; asm/hardirq.h&gt;中；都是用于内核代码判断自己是否处于中断上下文的函数，但是后者可以用在调度不被允许的情况下，包括硬件中断和软件中断上下文以及拥有自旋锁的任何时间点。 \n\n    注意：任何定时器函数访问的数据结构都应该针对并发访问进行保护。\n\n    #### 4.1 定时器API\n\n    <pre class=\"prettyprint\">`内核提供给驱动许多函数来声明, 注册, 以及去除内核定时器. 下列的引用展示了基本的代码块:\n    #include &lt;linux/timer.h&gt;\n    struct timer_list\n    {\n            /* ... */\n            unsigned long expires;\n            void (*function)(unsigned long);\n            unsigned long data;\n    };\n    void init_timer(struct timer_list *timer);\n    struct timer_list TIMER_INITIALIZER(_function, _expires, _data);\n\n    void add_timer(struct timer_list * timer);\n    int del_timer(struct timer_list * timer);\n\n    //更新某个定时器的到期时间\n    int mod_timer(struct timer_list *timer, unsigned long expires);\n    //和del_timer类似，但是del_timer_sync确保返回时没有任何CPU在运行定时器函数\n    int del_timer_sync(struct timer_list *timer);\n    //返回定时器是否正在被调度运行\n    int timer_pending(const struct timer_list * timer);`</pre>\n\n    #### 4.2 内核定时器的实现\n\n    <pre class=\"prettyprint\">`内核定时器的实现要求：\n    1.定时器的管理必须做到轻量级；\n    2.其设计必须在活动定时器大量增加时具有良好的伸缩性；\n    3.大部分定时器会在最多几秒或者几分钟内到期，很少存在长期延迟的定时器；\n    4.定时器应该在注册他的当前cpu上运行。\n\n    目前的解决方案是利用per-CPU数据结构。\n    无论何时内核代码注册一个定时器( 通过 add_timer 或者 mod_timer), 最终由 internal_add_timer ( 在kernel/timer.c)执行, 它依次添加新定时器到一个双向定时器链表在一个关联到当前 CPU 的\"级联表\" 中。\n    级联表的工作工作方式: 如果定时器在下一个 0 到 255 jiffies 内到期, 则它会被添加到专供短时定时器 256 列表中的一个（这取决于expires 成员的低8位）。如果它在将来更久时间到期（但是在 16,384 jiffies 之前), 它会被添加到基于 expires 成员的 9 - 14 位的 64 个列表中一个. 对于更长的定时器, 同样的技巧用在 15 - 20 位, 21 - 26 位, 和 27 - 31 位. 带有一个指向将来还长时间的 expires 成员的定时器（一些只可能发生在 64-位 平台上的事情）被使用一个延时值 0xffffffff 进行哈希处理, 而在过去时间内到期的定时器将在下一个时钟嘀哒被调度（如果在高负荷情况，有可能注册一个已经到期的定时器，尤其在运行抢占式内核时）。\n    当触发 __run_timers, 它为当前定时器嘀哒执行所有挂起的定时器。如果当前jiffies是256的倍数, 这个函数还会将下一级定时器链表重新散列到256个短期列表中, 同时还可能根据上面jiffies的位划分对其他级别的定时器做级联处理。`</pre>\n\n    ### 5.tasklet\n\n    另一个有关于定时问题的内核设施是 tasklet 机制. 它大部分用在中断管理。\n\n    #### 5.1 tasklet 与内核定时器的异同\n\n    1.它们一直在中断时间运行； \n\n    2.它们一直运行在调度它们的同一个 CPU 上； \n\n    3.它们接收一个 unsigned long 参数； \n\n    4.它们都在“软件中断”上下文原子性执行； \n\n    5.tasklet无法请求在一个指定的时间执行函数，调度tasklet，表示我们只希望内核在其后的某个时间执行指定的函数（因此适用于中断管理）。\n\n    #### 5.2 tasklet 的特色\n\n    1.tasklet 能够被禁止之后能被重新使能; 它不会执行直到它被使能与被禁止相同的次数； \n\n    2.tasklet 可以注册它自己； \n\n    3.tasklet 能以正常的优先级或者高优先级被调度执行，后一组一直是首先执行； \n\n    4.如果系统负荷不重，taslet 能立刻运行,  但是不会晚于下一个时钟嘀哒； \n\n    5.tasklet 可能和其他 tasklet 并发, 但是对它自己是严格地串行的，因为它始终会在地调度自己的同一cpu上运行，从不运行在不同的处理器上。\n\n    #### 5.3 tasklet使用\n\n    <pre class=\"prettyprint\">`#include &lt;linux/interrupt.h&gt; \n    struct tasklet_struct {\n     /* ... */\n\n    void (*func)(unsigned long);\n     unsigned long data;\n    };\n\n    void tasklet_init(struct tasklet_struct *t,\n    void (*func)(unsigned long), unsigned long data);\n    DECLARE_TASKLET(name, func, data);\n    DECLARE_TASKLET_DISABLED(name, func, data);\n    //禁用指定的tasklet\n    void tasklet_disable(struct tasklet_struct *t);\n    //禁用指定的tasklet，但不会等待任何正在运行的tasklet退出\n    void tasklet_disable_nosync(struct tasklet_struct *t);\n    //启用之前被禁用的tasklet\n    void tasklet_enable(struct tasklet_struct *t);\n    //调度指定的tasklet\n    void tasklet_schedule(struct tasklet_struct *t);\n    //禁用指定的tasklet以高优先级执行\n    void tasklet_hi_schedule(struct tasklet_struct *t);\n    //禁止指定的tasklet的再次调度，通用用于设备关闭和模块移除\n    void tasklet_kill(struct tasklet_struct *t);`</pre>\n\n    ### 6.工作队列\n\n    工作队列类似于tasklet，他们都允许内核代码请求某个函数在将来的时间被调用，当时两者之间还是有一些非常重要的区别： \n\n    1.tasklet 在软件中断上下文中运行的结果是所有的 tasklet 代码必须是原子的；相反, 工作队列函数在一个特殊内核进程上下文运行，所以它们有更多的灵活性。注意, 工作队列函数能够睡眠。 \n\n    2.tasklet 常常在它们最初被提交的处理器上运行。但这只是工作队列默认的工作方式。 \n\n    3.内核代码可以请求工作队列函数被延后指定的时间间隔后执行。 \n\n    4.tasklet会在很短的会时间内很快的执行, 并且在原子态, 而工作队列函数可能有更长的延迟而且不需要是原子的。\n\n    #### 6.1 工作队列的使用\n\n    <pre class=\"prettyprint\">`&lt;linux/workqueue.h&gt;\n    //创建工作队列\n    struct workqueue_struct *create_workqueue(const char *name);\n    struct workqueue_struct *create_singlethread_workqueue(const char *name);\n    //编译时向工作队列递交任务\n    DECLARE_WORK(name, void (*function)(void *), void *data);\n    //运行时构造work_struct 结构\n    //INIT_WORK完成所有初始化工作\n    INIT_WORK(struct work_struct *work, void (*function)(void *), void *data); \n    //同INIT_WORK，但不会初始化用来将work_struct结构连接到工作队列的指针\n    PREPARE_WORK(struct work_struct *work, void (*function)(void *), void *data); \n    //将工作递交到工作队列\n    int queue_work(struct workqueue_struct *queue, struct work_struct *work);\n    int queue_delayed_work(struct workqueue_struct *queue, struct work_struct *work, unsigned long delay);\n    //取消某个挂起的工作队列入口项\n    int cancel_delayed_work(struct work_struct *work); \n    //禁止运行被调用之前所有被递交的工作\n    void flush_workqueue(struct workqueue_struct *queue); \n    //释放工作队列\n    void destroy_workqueue(struct workqueue_struct *queue); `</pre>\n\n    #### 6.2 共享队列\n\n    设备驱动, 在许多情况下, 不需要有它自己的工作队列。如果你只偶尔需要提交任务给队列, 简单地使用内核提供的共享的默认工作队列可能更有效。如果你需要使用这个队列，你必须明白你将和别的在共享它，这意味着你不应当长时间独占队列(无长睡眠), 并且可能要更长时间我们的任务才能获得处理器。 \n\n    1.共享队列使用：\n\n    <pre class=\"prettyprint\">`//递交工作任务\n    int schedule_work(struct work_struct *work); \n    //以延迟模式递交工作任务\n    int schedule_delayed_work(struct work_struct *work, unsigned long delay); \n    //刷新共享队列\n    void flush_scheduled_work(void); \n    例：\n    static struct work_struct jiq_work;\n    /* this line is in jiq_init() */\n    INIT_WORK(&amp;jiq_work, jiq_print_wq, &amp;jiq_data);\n    prepare_to_wait(&amp;jiq_wait, &amp;wait, TASK_INTERRUPTIBLE);\n    schedule_work(&amp;jiq_work);\n    schedule();\n    finish_wait(&amp;jiq_wait, &amp;wait);\n\n            <div>\n                作者：WEINILUO 发表于2016/9/21 17:15:35 [原文链接](http://blog.csdn.net/weiniluo/article/details/52540396)\n            </div>\n            <div>\n            阅读：99 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52540396#comments)\n            </div>\n","slug":"原-时间、延迟及延缓操作","published":1,"updated":"2016-10-20T10:00:50.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnod8000evzs6iawlnxt1","content":"<h3 id=\"1-度量时间差\"><a href=\"#1-度量时间差\" class=\"headerlink\" title=\"1.度量时间差\"></a>1.度量时间差</h3><pre><code>内核通过定时器中断来跟踪时间流，时钟中断有系统定时硬件以周期性的间隔产生，这个间隔有内核根据HZ的值设定，HZ是一个与体系结构有关的常量，定义在&amp;lt;asm-generic/param.h&amp;gt;中。常用值为100或1000.每发生一次时钟中断，内核内部计数器的值增1，该值在系统引导时被初始化为0。该计数器是一个64位的变量（即使是32位架构也是这样），称为jiffies_64。但是驱动开发人员通常访问jiffies变量，它是unsigned long变量，通常是jiffies_64或者jiffies_64的低32位值。除了jiffy机制，某些cpu平台还有一个软件可读取的高分辨路计数器，以适用于特殊需求。\n`&lt;/pre&gt;\n\n#### 1.1 使用jiffies计数器\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`&amp;lt;linux/jiffies.h&amp;gt;\nunsigned long j, stamp_1, stamp_half, stamp_n;\n\nj = jiffies; /* read the current value */\nstamp_1 = j + HZ; /* 1 second in the future */\nstamp_half = j + HZ/2; /* half a second */\nstamp_n = j + n * HZ / 1000; /* n milliseconds */\n\n//当条件为真，返回真；\nint time_after(unsigned long a, unsigned long b);//a&amp;gt;b\nint time_before(unsigned long a, unsigned long b);//a&amp;lt;b\nint time_after_eq(unsigned long a, unsigned long b);//a&amp;gt;=b\nint time_before_eq(unsigned long a, unsigned long b);//a&amp;lt;=b\n//计算时间差\ndiff = (long)t2 - (long)t1;\nmsec = diff * 1000 / HZ; \n//timespec、timeval与jiffies格式的转换\n#include &amp;lt;linux/time.h&amp;gt; \nunsigned long timespec_to_jiffies(struct timespec *value);\nvoid jiffies_to_timespec(unsigned long jiffies, struct timespec *value);\nunsigned long timeval_to_jiffies(struct timeval *value);\nvoid jiffies_to_timeval(unsigned long jiffies, struct timeval *value);\n//在32位平台上原子的获取jiffies_64的值\n#include &amp;lt;linux/jiffies.h&amp;gt; \nu64 get_jiffies_64(void);`&lt;/pre&gt;\n\n#### 1.2 处理器特定的计数器\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.x86平台常用的TSC计数器寄存器：\n它是一个 64-位 寄存器计数 CPU 的时钟周期; 它可从内核和用户空间读取.\n&amp;lt;asm/msr.h&amp;gt;\nrdtsc(low32,high32);\nrdtscl(low32);\nrdtscll(var64);\n第一个宏自动读取 64位 值到 2 个 32位 变量;下一个读取寄存器的低半部到一个32位变量;最后一个读64位值到一个long long变量. 所有这些宏存储数值到它们的参数中.\n2.体系无关函数get_cycles:\n#include &amp;lt;linux/timex.h&amp;gt;\ncycles_t get_cycles(void); \n在无时钟计数器的平台，返回0。\n3.通过内嵌汇编实现：\n#define rdtscl(dest) \\\n__asm__ __volatile__(&quot;mfc0 %0,$9; nop&quot; : &quot;=r&quot; (dest))`&lt;/pre&gt;\n\n### 2.获取当前时间\n\n内核通常通过查看 jifies 的值来获取当前时间，该数值表示最近一次系统启动到当前的时间间隔，他和设备驱动程序无关，因为他的生命周期只限于系统的运行周期。 \n\n驱动程序一般不需要知道墙钟时间（日常时间，年月日的表达），只有cron、syslogd类似程序才需要知道。 \n\n常用的时间相关函数：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;linux/time.h&amp;gt; \nunsigned long mktime (unsigned int year, unsigned int mon, unsigned int day, unsigned int hour, unsigned int min, unsigned int sec); //将墙钟时间转化为jiffies值\nvoid do_gettimeofday(struct timeval *tv);//返回当前时间，但很难原子获取timeval的两个变量\nstruct timespec current_kernel_time(void);//原子的获取当前时间`&lt;/pre&gt;\n\n### 3.延迟执行\n\n#### 3.1 长延迟\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.忙等待\n如果想执行若干个时钟嘀嗒的延迟，或者对延迟的精度要求不高，可通过一下方法实现：\n&amp;lt;linux/jiffies.h&amp;gt;\nunsigned long j, j1;\nj = jiffies;\nj1=j+HZ;\nwhile (time_before(jiffies, j1))\n    cpu_relax();\n注意: cpu_relax函数在许多系统上不会做任何事情，而在对称多线程系统上，它可能让出处理器。但是通常情况下我们都应避免这种方式，因为这会严重降低系统性能。在非抢占系统上，在延迟过程中会锁住处理器；如果在进入忙等待前禁止了中断，jiffies值变得不到更新，系统就会死掉！\n2.让出处理器\n上面忙等待的方法会增加系统的负担，但延迟的实现有多种方法。延迟的另一种实现方式如下：\n&amp;lt;linux/jiffies.h&amp;gt;\nunsigned long j, j1;\nj = jiffies;\nj1=j+HZ;\nwhile (time_before(jiffies, j1))\n    schedule();\n注意：这种方式释放了cpu而不做任何事情，但他仍在运行队列中。若系统中只有当前进程运行，这当前进程会立即执行，因此，系统一直处于运行中，空闲任务不会运行，cpu并没有空闲下来。从cpu的角度看，这种方式和忙等待类似。\n3.超时\n上面两种方式都会给cpu带来负担，目前最好的方式是让内核完成我们的任务。当前有两种构造基于jiffies超时的途径，这主要取决于驱动程序是否在等待其他事件。\n第一种途径，驱动程序使用等待队列等待其他一些事件：\n#include &amp;lt;linux/wait.h&amp;gt;\nlong wait_event_timeout(wait_queue_head_t q, condition, long timeout);\nlong wait_event_interruptible_timeout(wait_queue_head_t q, condition, long timeout);\n参数：\nq:队列头\ncondition：条件\ntimeout：返回要等待的事件的jiffies值\n返回：\n若是被其他时间唤醒，返回剩余的jiffies值；若是超时到期，返回0。\n例：\n#include &amp;lt;linux/wait.h&amp;gt;\nwait_queue_head_t wait; \ninit_waitqueue_head (&amp;amp;wait); \nwait_event_interruptible_timeout(wait, 0, delay); \n第二种途径，驱动程序无需等待其他事件：\n#include &amp;lt;linux/sched.h&amp;gt;\nsigned long schedule_timeout(signed long timeout);\n参数：\ntimeout：延迟时间的jiffies值；\n返回：\n正常返回0；\n注意：使用schedule_timeout前需要设置当前进程的状态\n例：\nset_current_state(TASK_INTERRUPTIBLE);\nschedule_timeout (delay);`&lt;/pre&gt;\n\n#### 3.2 短延迟\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`如果驱动程序需要处理硬件的延迟，这种延迟通常最多涉及到几十个毫秒。这是通常用ndelay、udelay,以及 mdelay来完成延迟任务。\n#include &amp;lt;linux/delay.h&amp;gt;\nvoid ndelay(unsigned long nsecs);\nvoid udelay(unsigned long usecs);\nvoid mdelay(unsigned long msecs);\n这三个方法都是忙等待函数，当然不涉及忙等待的方法也有相应的实现：\nvoid msleep(unsigned int millisecs);\nunsigned long msleep_interruptible(unsigned int millisecs);\nvoid ssleep(unsigned int seconds);`&lt;/pre&gt;\n\n### 4.内核定时器\n\n内核定时器使用场景：在将来的某个时间点调度执行某个函数，同时在该时间点到达之前不会阻塞当前进程。 \n\n内核定时器常常作为软件中断的结果而运行的，被调度运行的函数几乎不会再注册这些函数的进程正在执行是运行。在这种原子性的上下文中运行时，定时器函数必须以原子的方式运行（请参照自旋锁和原子上下文相关内容）。定时器函数通常需要遵循以下规则： \n\n1.不允许访问用户空间，因为没有进程上下文，无法将任何特定进程和用户空间关联。 \n\n2.current指针在原子模式下无任何意义，因为相关的代码和被中断的进程没有任何关联。 \n\n3.不能执行休眠和调度，原子代码不能调用 schedule 或者某种 wait_event, 也不能调用任何其他可能睡眠的函数.。例如, 调用 kmalloc(…, GFP_KERNEL) 是违犯规则的. 旗标也必须不能使用因为它们可能睡眠。 \n\nin_interrupt()和in_atomic(): \n\n包含在&amp;lt; asm/hardirq.h&amp;gt;中；都是用于内核代码判断自己是否处于中断上下文的函数，但是后者可以用在调度不被允许的情况下，包括硬件中断和软件中断上下文以及拥有自旋锁的任何时间点。 \n\n注意：任何定时器函数访问的数据结构都应该针对并发访问进行保护。\n\n#### 4.1 定时器API\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`内核提供给驱动许多函数来声明, 注册, 以及去除内核定时器. 下列的引用展示了基本的代码块:\n#include &amp;lt;linux/timer.h&amp;gt;\nstruct timer_list\n{\n        /* ... */\n        unsigned long expires;\n        void (*function)(unsigned long);\n        unsigned long data;\n};\nvoid init_timer(struct timer_list *timer);\nstruct timer_list TIMER_INITIALIZER(_function, _expires, _data);\n\nvoid add_timer(struct timer_list * timer);\nint del_timer(struct timer_list * timer);\n\n//更新某个定时器的到期时间\nint mod_timer(struct timer_list *timer, unsigned long expires);\n//和del_timer类似，但是del_timer_sync确保返回时没有任何CPU在运行定时器函数\nint del_timer_sync(struct timer_list *timer);\n//返回定时器是否正在被调度运行\nint timer_pending(const struct timer_list * timer);`&lt;/pre&gt;\n\n#### 4.2 内核定时器的实现\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`内核定时器的实现要求：\n1.定时器的管理必须做到轻量级；\n2.其设计必须在活动定时器大量增加时具有良好的伸缩性；\n3.大部分定时器会在最多几秒或者几分钟内到期，很少存在长期延迟的定时器；\n4.定时器应该在注册他的当前cpu上运行。\n\n目前的解决方案是利用per-CPU数据结构。\n无论何时内核代码注册一个定时器( 通过 add_timer 或者 mod_timer), 最终由 internal_add_timer ( 在kernel/timer.c)执行, 它依次添加新定时器到一个双向定时器链表在一个关联到当前 CPU 的&quot;级联表&quot; 中。\n级联表的工作工作方式: 如果定时器在下一个 0 到 255 jiffies 内到期, 则它会被添加到专供短时定时器 256 列表中的一个（这取决于expires 成员的低8位）。如果它在将来更久时间到期（但是在 16,384 jiffies 之前), 它会被添加到基于 expires 成员的 9 - 14 位的 64 个列表中一个. 对于更长的定时器, 同样的技巧用在 15 - 20 位, 21 - 26 位, 和 27 - 31 位. 带有一个指向将来还长时间的 expires 成员的定时器（一些只可能发生在 64-位 平台上的事情）被使用一个延时值 0xffffffff 进行哈希处理, 而在过去时间内到期的定时器将在下一个时钟嘀哒被调度（如果在高负荷情况，有可能注册一个已经到期的定时器，尤其在运行抢占式内核时）。\n当触发 __run_timers, 它为当前定时器嘀哒执行所有挂起的定时器。如果当前jiffies是256的倍数, 这个函数还会将下一级定时器链表重新散列到256个短期列表中, 同时还可能根据上面jiffies的位划分对其他级别的定时器做级联处理。`&lt;/pre&gt;\n\n### 5.tasklet\n\n另一个有关于定时问题的内核设施是 tasklet 机制. 它大部分用在中断管理。\n\n#### 5.1 tasklet 与内核定时器的异同\n\n1.它们一直在中断时间运行； \n\n2.它们一直运行在调度它们的同一个 CPU 上； \n\n3.它们接收一个 unsigned long 参数； \n\n4.它们都在“软件中断”上下文原子性执行； \n\n5.tasklet无法请求在一个指定的时间执行函数，调度tasklet，表示我们只希望内核在其后的某个时间执行指定的函数（因此适用于中断管理）。\n\n#### 5.2 tasklet 的特色\n\n1.tasklet 能够被禁止之后能被重新使能; 它不会执行直到它被使能与被禁止相同的次数； \n\n2.tasklet 可以注册它自己； \n\n3.tasklet 能以正常的优先级或者高优先级被调度执行，后一组一直是首先执行； \n\n4.如果系统负荷不重，taslet 能立刻运行,  但是不会晚于下一个时钟嘀哒； \n\n5.tasklet 可能和其他 tasklet 并发, 但是对它自己是严格地串行的，因为它始终会在地调度自己的同一cpu上运行，从不运行在不同的处理器上。\n\n#### 5.3 tasklet使用\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;linux/interrupt.h&amp;gt; \nstruct tasklet_struct {\n /* ... */\n\nvoid (*func)(unsigned long);\n unsigned long data;\n};\n\nvoid tasklet_init(struct tasklet_struct *t,\nvoid (*func)(unsigned long), unsigned long data);\nDECLARE_TASKLET(name, func, data);\nDECLARE_TASKLET_DISABLED(name, func, data);\n//禁用指定的tasklet\nvoid tasklet_disable(struct tasklet_struct *t);\n//禁用指定的tasklet，但不会等待任何正在运行的tasklet退出\nvoid tasklet_disable_nosync(struct tasklet_struct *t);\n//启用之前被禁用的tasklet\nvoid tasklet_enable(struct tasklet_struct *t);\n//调度指定的tasklet\nvoid tasklet_schedule(struct tasklet_struct *t);\n//禁用指定的tasklet以高优先级执行\nvoid tasklet_hi_schedule(struct tasklet_struct *t);\n//禁止指定的tasklet的再次调度，通用用于设备关闭和模块移除\nvoid tasklet_kill(struct tasklet_struct *t);`&lt;/pre&gt;\n\n### 6.工作队列\n\n工作队列类似于tasklet，他们都允许内核代码请求某个函数在将来的时间被调用，当时两者之间还是有一些非常重要的区别： \n\n1.tasklet 在软件中断上下文中运行的结果是所有的 tasklet 代码必须是原子的；相反, 工作队列函数在一个特殊内核进程上下文运行，所以它们有更多的灵活性。注意, 工作队列函数能够睡眠。 \n\n2.tasklet 常常在它们最初被提交的处理器上运行。但这只是工作队列默认的工作方式。 \n\n3.内核代码可以请求工作队列函数被延后指定的时间间隔后执行。 \n\n4.tasklet会在很短的会时间内很快的执行, 并且在原子态, 而工作队列函数可能有更长的延迟而且不需要是原子的。\n\n#### 6.1 工作队列的使用\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`&amp;lt;linux/workqueue.h&amp;gt;\n//创建工作队列\nstruct workqueue_struct *create_workqueue(const char *name);\nstruct workqueue_struct *create_singlethread_workqueue(const char *name);\n//编译时向工作队列递交任务\nDECLARE_WORK(name, void (*function)(void *), void *data);\n//运行时构造work_struct 结构\n//INIT_WORK完成所有初始化工作\nINIT_WORK(struct work_struct *work, void (*function)(void *), void *data); \n//同INIT_WORK，但不会初始化用来将work_struct结构连接到工作队列的指针\nPREPARE_WORK(struct work_struct *work, void (*function)(void *), void *data); \n//将工作递交到工作队列\nint queue_work(struct workqueue_struct *queue, struct work_struct *work);\nint queue_delayed_work(struct workqueue_struct *queue, struct work_struct *work, unsigned long delay);\n//取消某个挂起的工作队列入口项\nint cancel_delayed_work(struct work_struct *work); \n//禁止运行被调用之前所有被递交的工作\nvoid flush_workqueue(struct workqueue_struct *queue); \n//释放工作队列\nvoid destroy_workqueue(struct workqueue_struct *queue); `&lt;/pre&gt;\n\n#### 6.2 共享队列\n\n设备驱动, 在许多情况下, 不需要有它自己的工作队列。如果你只偶尔需要提交任务给队列, 简单地使用内核提供的共享的默认工作队列可能更有效。如果你需要使用这个队列，你必须明白你将和别的在共享它，这意味着你不应当长时间独占队列(无长睡眠), 并且可能要更长时间我们的任务才能获得处理器。 \n\n1.共享队列使用：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`//递交工作任务\nint schedule_work(struct work_struct *work); \n//以延迟模式递交工作任务\nint schedule_delayed_work(struct work_struct *work, unsigned long delay); \n//刷新共享队列\nvoid flush_scheduled_work(void); \n例：\nstatic struct work_struct jiq_work;\n/* this line is in jiq_init() */\nINIT_WORK(&amp;amp;jiq_work, jiq_print_wq, &amp;amp;jiq_data);\nprepare_to_wait(&amp;amp;jiq_wait, &amp;amp;wait, TASK_INTERRUPTIBLE);\nschedule_work(&amp;amp;jiq_work);\nschedule();\nfinish_wait(&amp;amp;jiq_wait, &amp;amp;wait);\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/9/21 17:15:35 [原文链接](http://blog.csdn.net/weiniluo/article/details/52540396)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：99 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52540396#comments)\n        &lt;/div&gt;\n</code></pre>","excerpt":"","more":"<h3 id=\"1-度量时间差\"><a href=\"#1-度量时间差\" class=\"headerlink\" title=\"1.度量时间差\"></a>1.度量时间差</h3><pre><code>内核通过定时器中断来跟踪时间流，时钟中断有系统定时硬件以周期性的间隔产生，这个间隔有内核根据HZ的值设定，HZ是一个与体系结构有关的常量，定义在&amp;lt;asm-generic/param.h&amp;gt;中。常用值为100或1000.每发生一次时钟中断，内核内部计数器的值增1，该值在系统引导时被初始化为0。该计数器是一个64位的变量（即使是32位架构也是这样），称为jiffies_64。但是驱动开发人员通常访问jiffies变量，它是unsigned long变量，通常是jiffies_64或者jiffies_64的低32位值。除了jiffy机制，某些cpu平台还有一个软件可读取的高分辨路计数器，以适用于特殊需求。\n`&lt;/pre&gt;\n\n#### 1.1 使用jiffies计数器\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`&amp;lt;linux/jiffies.h&amp;gt;\nunsigned long j, stamp_1, stamp_half, stamp_n;\n\nj = jiffies; /* read the current value */\nstamp_1 = j + HZ; /* 1 second in the future */\nstamp_half = j + HZ/2; /* half a second */\nstamp_n = j + n * HZ / 1000; /* n milliseconds */\n\n//当条件为真，返回真；\nint time_after(unsigned long a, unsigned long b);//a&amp;gt;b\nint time_before(unsigned long a, unsigned long b);//a&amp;lt;b\nint time_after_eq(unsigned long a, unsigned long b);//a&amp;gt;=b\nint time_before_eq(unsigned long a, unsigned long b);//a&amp;lt;=b\n//计算时间差\ndiff = (long)t2 - (long)t1;\nmsec = diff * 1000 / HZ; \n//timespec、timeval与jiffies格式的转换\n#include &amp;lt;linux/time.h&amp;gt; \nunsigned long timespec_to_jiffies(struct timespec *value);\nvoid jiffies_to_timespec(unsigned long jiffies, struct timespec *value);\nunsigned long timeval_to_jiffies(struct timeval *value);\nvoid jiffies_to_timeval(unsigned long jiffies, struct timeval *value);\n//在32位平台上原子的获取jiffies_64的值\n#include &amp;lt;linux/jiffies.h&amp;gt; \nu64 get_jiffies_64(void);`&lt;/pre&gt;\n\n#### 1.2 处理器特定的计数器\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.x86平台常用的TSC计数器寄存器：\n它是一个 64-位 寄存器计数 CPU 的时钟周期; 它可从内核和用户空间读取.\n&amp;lt;asm/msr.h&amp;gt;\nrdtsc(low32,high32);\nrdtscl(low32);\nrdtscll(var64);\n第一个宏自动读取 64位 值到 2 个 32位 变量;下一个读取寄存器的低半部到一个32位变量;最后一个读64位值到一个long long变量. 所有这些宏存储数值到它们的参数中.\n2.体系无关函数get_cycles:\n#include &amp;lt;linux/timex.h&amp;gt;\ncycles_t get_cycles(void); \n在无时钟计数器的平台，返回0。\n3.通过内嵌汇编实现：\n#define rdtscl(dest) \\\n__asm__ __volatile__(&quot;mfc0 %0,$9; nop&quot; : &quot;=r&quot; (dest))`&lt;/pre&gt;\n\n### 2.获取当前时间\n\n内核通常通过查看 jifies 的值来获取当前时间，该数值表示最近一次系统启动到当前的时间间隔，他和设备驱动程序无关，因为他的生命周期只限于系统的运行周期。 \n\n驱动程序一般不需要知道墙钟时间（日常时间，年月日的表达），只有cron、syslogd类似程序才需要知道。 \n\n常用的时间相关函数：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;linux/time.h&amp;gt; \nunsigned long mktime (unsigned int year, unsigned int mon, unsigned int day, unsigned int hour, unsigned int min, unsigned int sec); //将墙钟时间转化为jiffies值\nvoid do_gettimeofday(struct timeval *tv);//返回当前时间，但很难原子获取timeval的两个变量\nstruct timespec current_kernel_time(void);//原子的获取当前时间`&lt;/pre&gt;\n\n### 3.延迟执行\n\n#### 3.1 长延迟\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`1.忙等待\n如果想执行若干个时钟嘀嗒的延迟，或者对延迟的精度要求不高，可通过一下方法实现：\n&amp;lt;linux/jiffies.h&amp;gt;\nunsigned long j, j1;\nj = jiffies;\nj1=j+HZ;\nwhile (time_before(jiffies, j1))\n    cpu_relax();\n注意: cpu_relax函数在许多系统上不会做任何事情，而在对称多线程系统上，它可能让出处理器。但是通常情况下我们都应避免这种方式，因为这会严重降低系统性能。在非抢占系统上，在延迟过程中会锁住处理器；如果在进入忙等待前禁止了中断，jiffies值变得不到更新，系统就会死掉！\n2.让出处理器\n上面忙等待的方法会增加系统的负担，但延迟的实现有多种方法。延迟的另一种实现方式如下：\n&amp;lt;linux/jiffies.h&amp;gt;\nunsigned long j, j1;\nj = jiffies;\nj1=j+HZ;\nwhile (time_before(jiffies, j1))\n    schedule();\n注意：这种方式释放了cpu而不做任何事情，但他仍在运行队列中。若系统中只有当前进程运行，这当前进程会立即执行，因此，系统一直处于运行中，空闲任务不会运行，cpu并没有空闲下来。从cpu的角度看，这种方式和忙等待类似。\n3.超时\n上面两种方式都会给cpu带来负担，目前最好的方式是让内核完成我们的任务。当前有两种构造基于jiffies超时的途径，这主要取决于驱动程序是否在等待其他事件。\n第一种途径，驱动程序使用等待队列等待其他一些事件：\n#include &amp;lt;linux/wait.h&amp;gt;\nlong wait_event_timeout(wait_queue_head_t q, condition, long timeout);\nlong wait_event_interruptible_timeout(wait_queue_head_t q, condition, long timeout);\n参数：\nq:队列头\ncondition：条件\ntimeout：返回要等待的事件的jiffies值\n返回：\n若是被其他时间唤醒，返回剩余的jiffies值；若是超时到期，返回0。\n例：\n#include &amp;lt;linux/wait.h&amp;gt;\nwait_queue_head_t wait; \ninit_waitqueue_head (&amp;amp;wait); \nwait_event_interruptible_timeout(wait, 0, delay); \n第二种途径，驱动程序无需等待其他事件：\n#include &amp;lt;linux/sched.h&amp;gt;\nsigned long schedule_timeout(signed long timeout);\n参数：\ntimeout：延迟时间的jiffies值；\n返回：\n正常返回0；\n注意：使用schedule_timeout前需要设置当前进程的状态\n例：\nset_current_state(TASK_INTERRUPTIBLE);\nschedule_timeout (delay);`&lt;/pre&gt;\n\n#### 3.2 短延迟\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`如果驱动程序需要处理硬件的延迟，这种延迟通常最多涉及到几十个毫秒。这是通常用ndelay、udelay,以及 mdelay来完成延迟任务。\n#include &amp;lt;linux/delay.h&amp;gt;\nvoid ndelay(unsigned long nsecs);\nvoid udelay(unsigned long usecs);\nvoid mdelay(unsigned long msecs);\n这三个方法都是忙等待函数，当然不涉及忙等待的方法也有相应的实现：\nvoid msleep(unsigned int millisecs);\nunsigned long msleep_interruptible(unsigned int millisecs);\nvoid ssleep(unsigned int seconds);`&lt;/pre&gt;\n\n### 4.内核定时器\n\n内核定时器使用场景：在将来的某个时间点调度执行某个函数，同时在该时间点到达之前不会阻塞当前进程。 \n\n内核定时器常常作为软件中断的结果而运行的，被调度运行的函数几乎不会再注册这些函数的进程正在执行是运行。在这种原子性的上下文中运行时，定时器函数必须以原子的方式运行（请参照自旋锁和原子上下文相关内容）。定时器函数通常需要遵循以下规则： \n\n1.不允许访问用户空间，因为没有进程上下文，无法将任何特定进程和用户空间关联。 \n\n2.current指针在原子模式下无任何意义，因为相关的代码和被中断的进程没有任何关联。 \n\n3.不能执行休眠和调度，原子代码不能调用 schedule 或者某种 wait_event, 也不能调用任何其他可能睡眠的函数.。例如, 调用 kmalloc(…, GFP_KERNEL) 是违犯规则的. 旗标也必须不能使用因为它们可能睡眠。 \n\nin_interrupt()和in_atomic(): \n\n包含在&amp;lt; asm/hardirq.h&amp;gt;中；都是用于内核代码判断自己是否处于中断上下文的函数，但是后者可以用在调度不被允许的情况下，包括硬件中断和软件中断上下文以及拥有自旋锁的任何时间点。 \n\n注意：任何定时器函数访问的数据结构都应该针对并发访问进行保护。\n\n#### 4.1 定时器API\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`内核提供给驱动许多函数来声明, 注册, 以及去除内核定时器. 下列的引用展示了基本的代码块:\n#include &amp;lt;linux/timer.h&amp;gt;\nstruct timer_list\n{\n        /* ... */\n        unsigned long expires;\n        void (*function)(unsigned long);\n        unsigned long data;\n};\nvoid init_timer(struct timer_list *timer);\nstruct timer_list TIMER_INITIALIZER(_function, _expires, _data);\n\nvoid add_timer(struct timer_list * timer);\nint del_timer(struct timer_list * timer);\n\n//更新某个定时器的到期时间\nint mod_timer(struct timer_list *timer, unsigned long expires);\n//和del_timer类似，但是del_timer_sync确保返回时没有任何CPU在运行定时器函数\nint del_timer_sync(struct timer_list *timer);\n//返回定时器是否正在被调度运行\nint timer_pending(const struct timer_list * timer);`&lt;/pre&gt;\n\n#### 4.2 内核定时器的实现\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`内核定时器的实现要求：\n1.定时器的管理必须做到轻量级；\n2.其设计必须在活动定时器大量增加时具有良好的伸缩性；\n3.大部分定时器会在最多几秒或者几分钟内到期，很少存在长期延迟的定时器；\n4.定时器应该在注册他的当前cpu上运行。\n\n目前的解决方案是利用per-CPU数据结构。\n无论何时内核代码注册一个定时器( 通过 add_timer 或者 mod_timer), 最终由 internal_add_timer ( 在kernel/timer.c)执行, 它依次添加新定时器到一个双向定时器链表在一个关联到当前 CPU 的&quot;级联表&quot; 中。\n级联表的工作工作方式: 如果定时器在下一个 0 到 255 jiffies 内到期, 则它会被添加到专供短时定时器 256 列表中的一个（这取决于expires 成员的低8位）。如果它在将来更久时间到期（但是在 16,384 jiffies 之前), 它会被添加到基于 expires 成员的 9 - 14 位的 64 个列表中一个. 对于更长的定时器, 同样的技巧用在 15 - 20 位, 21 - 26 位, 和 27 - 31 位. 带有一个指向将来还长时间的 expires 成员的定时器（一些只可能发生在 64-位 平台上的事情）被使用一个延时值 0xffffffff 进行哈希处理, 而在过去时间内到期的定时器将在下一个时钟嘀哒被调度（如果在高负荷情况，有可能注册一个已经到期的定时器，尤其在运行抢占式内核时）。\n当触发 __run_timers, 它为当前定时器嘀哒执行所有挂起的定时器。如果当前jiffies是256的倍数, 这个函数还会将下一级定时器链表重新散列到256个短期列表中, 同时还可能根据上面jiffies的位划分对其他级别的定时器做级联处理。`&lt;/pre&gt;\n\n### 5.tasklet\n\n另一个有关于定时问题的内核设施是 tasklet 机制. 它大部分用在中断管理。\n\n#### 5.1 tasklet 与内核定时器的异同\n\n1.它们一直在中断时间运行； \n\n2.它们一直运行在调度它们的同一个 CPU 上； \n\n3.它们接收一个 unsigned long 参数； \n\n4.它们都在“软件中断”上下文原子性执行； \n\n5.tasklet无法请求在一个指定的时间执行函数，调度tasklet，表示我们只希望内核在其后的某个时间执行指定的函数（因此适用于中断管理）。\n\n#### 5.2 tasklet 的特色\n\n1.tasklet 能够被禁止之后能被重新使能; 它不会执行直到它被使能与被禁止相同的次数； \n\n2.tasklet 可以注册它自己； \n\n3.tasklet 能以正常的优先级或者高优先级被调度执行，后一组一直是首先执行； \n\n4.如果系统负荷不重，taslet 能立刻运行,  但是不会晚于下一个时钟嘀哒； \n\n5.tasklet 可能和其他 tasklet 并发, 但是对它自己是严格地串行的，因为它始终会在地调度自己的同一cpu上运行，从不运行在不同的处理器上。\n\n#### 5.3 tasklet使用\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`#include &amp;lt;linux/interrupt.h&amp;gt; \nstruct tasklet_struct {\n /* ... */\n\nvoid (*func)(unsigned long);\n unsigned long data;\n};\n\nvoid tasklet_init(struct tasklet_struct *t,\nvoid (*func)(unsigned long), unsigned long data);\nDECLARE_TASKLET(name, func, data);\nDECLARE_TASKLET_DISABLED(name, func, data);\n//禁用指定的tasklet\nvoid tasklet_disable(struct tasklet_struct *t);\n//禁用指定的tasklet，但不会等待任何正在运行的tasklet退出\nvoid tasklet_disable_nosync(struct tasklet_struct *t);\n//启用之前被禁用的tasklet\nvoid tasklet_enable(struct tasklet_struct *t);\n//调度指定的tasklet\nvoid tasklet_schedule(struct tasklet_struct *t);\n//禁用指定的tasklet以高优先级执行\nvoid tasklet_hi_schedule(struct tasklet_struct *t);\n//禁止指定的tasklet的再次调度，通用用于设备关闭和模块移除\nvoid tasklet_kill(struct tasklet_struct *t);`&lt;/pre&gt;\n\n### 6.工作队列\n\n工作队列类似于tasklet，他们都允许内核代码请求某个函数在将来的时间被调用，当时两者之间还是有一些非常重要的区别： \n\n1.tasklet 在软件中断上下文中运行的结果是所有的 tasklet 代码必须是原子的；相反, 工作队列函数在一个特殊内核进程上下文运行，所以它们有更多的灵活性。注意, 工作队列函数能够睡眠。 \n\n2.tasklet 常常在它们最初被提交的处理器上运行。但这只是工作队列默认的工作方式。 \n\n3.内核代码可以请求工作队列函数被延后指定的时间间隔后执行。 \n\n4.tasklet会在很短的会时间内很快的执行, 并且在原子态, 而工作队列函数可能有更长的延迟而且不需要是原子的。\n\n#### 6.1 工作队列的使用\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`&amp;lt;linux/workqueue.h&amp;gt;\n//创建工作队列\nstruct workqueue_struct *create_workqueue(const char *name);\nstruct workqueue_struct *create_singlethread_workqueue(const char *name);\n//编译时向工作队列递交任务\nDECLARE_WORK(name, void (*function)(void *), void *data);\n//运行时构造work_struct 结构\n//INIT_WORK完成所有初始化工作\nINIT_WORK(struct work_struct *work, void (*function)(void *), void *data); \n//同INIT_WORK，但不会初始化用来将work_struct结构连接到工作队列的指针\nPREPARE_WORK(struct work_struct *work, void (*function)(void *), void *data); \n//将工作递交到工作队列\nint queue_work(struct workqueue_struct *queue, struct work_struct *work);\nint queue_delayed_work(struct workqueue_struct *queue, struct work_struct *work, unsigned long delay);\n//取消某个挂起的工作队列入口项\nint cancel_delayed_work(struct work_struct *work); \n//禁止运行被调用之前所有被递交的工作\nvoid flush_workqueue(struct workqueue_struct *queue); \n//释放工作队列\nvoid destroy_workqueue(struct workqueue_struct *queue); `&lt;/pre&gt;\n\n#### 6.2 共享队列\n\n设备驱动, 在许多情况下, 不需要有它自己的工作队列。如果你只偶尔需要提交任务给队列, 简单地使用内核提供的共享的默认工作队列可能更有效。如果你需要使用这个队列，你必须明白你将和别的在共享它，这意味着你不应当长时间独占队列(无长睡眠), 并且可能要更长时间我们的任务才能获得处理器。 \n\n1.共享队列使用：\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`//递交工作任务\nint schedule_work(struct work_struct *work); \n//以延迟模式递交工作任务\nint schedule_delayed_work(struct work_struct *work, unsigned long delay); \n//刷新共享队列\nvoid flush_scheduled_work(void); \n例：\nstatic struct work_struct jiq_work;\n/* this line is in jiq_init() */\nINIT_WORK(&amp;amp;jiq_work, jiq_print_wq, &amp;amp;jiq_data);\nprepare_to_wait(&amp;amp;jiq_wait, &amp;amp;wait, TASK_INTERRUPTIBLE);\nschedule_work(&amp;amp;jiq_work);\nschedule();\nfinish_wait(&amp;amp;jiq_wait, &amp;amp;wait);\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/9/21 17:15:35 [原文链接](http://blog.csdn.net/weiniluo/article/details/52540396)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：99 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52540396#comments)\n        &lt;/div&gt;\n</code></pre>"},{"title":"[原]网络驱动接口笔记","date":"2016-06-30T14:36:37.000Z","_content":"\n### 1.OSI七层模型和TCP/IP四层模型\n\n#### 1.1 OSI七层模型和TCP/IP四层模型对应表\n\n\n\n<tr>\n  <th align=\"center\">OSI七层网络模型</th>\n  <th align=\"center\">TCP/IP四层模型</th>\n  <th align=\"center\">对应网络协议</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td align=\"center\">应用层</td>\n  <td align=\"center\"></td>\n  <td align=\"center\">TFTP, FTP, NFS, WAIS</td>\n</tr>\n<tr>\n  <td align=\"center\">表示层</td>\n  <td align=\"center\">应用层</td>\n  <td align=\"center\">Telnet, Rlogin, SNMP, Gopher</td>\n</tr>\n<tr>\n  <td align=\"center\">会话层</td>\n  <td align=\"center\"></td>\n  <td align=\"center\">SMTP, DNS</td>\n</tr>\n<tr>\n  <td align=\"center\">传输层</td>\n  <td align=\"center\">传输层</td>\n  <td align=\"center\">TCP,UDP</td>\n</tr>\n<tr>\n  <td align=\"center\">网络层</td>\n  <td align=\"center\">网际层</td>\n  <td align=\"center\">IP, ICMP, ARP, RARP, AKP, UUCP</td>\n</tr>\n<tr>\n  <td align=\"center\">数据链路层</td>\n  <td align=\"center\"></td>\n  <td align=\"center\">FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td>\n</tr>\n<tr>\n  <td align=\"center\">物理层</td>\n  <td align=\"center\">网络接口层</td>\n  <td align=\"center\">IEEE 802.1A, IEEE 802.2到IEEE 802.11</td>\n</tr>\n</tbody></table>\n\n#### 1.2 OSI七层模型各层的定义\n\n    1.应用层：\n        实现应用进程（如用户程序、终端操作员等）之间的信息交换；\n    2.表示层：\n        为异种机通信提供一种公共语言；\n    3.会话层(RPC)：\n        通过传输层建立数据传输的通路，发起会话或接受会话请求；\n    4.传输层(TCP/UDP)：\n        定义了一些传输数据的协议和端口号（WWW端口80等）；\n    5.网络层(IP)：\n        在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择；\n    6.数据链路层(MAC)：\n        如何格式化数据以进行传输，以及如何控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输；\n    7.物理层(PHY)：\n        主要定义物理设备标准。`</pre>\n\n    ### 2.网络接口结构\n\n    <pre class=\"prettyprint\">`      DMA\n    CPU&lt;=======&gt;MAC&lt;======&gt;PHY\n    网络驱动主要处理MAC层和PHY层的工作。\n    MAC层和PHY层的通信由数据通信总线和控制总线组成。`</pre>\n\n    ### 3.MAC层和PHY层的通信方式\n\n    #### 3.1控制总线MIIM(MII management)\n\n    <pre class=\"prettyprint\">`主要完成对PHY设备的寄存器信息配置。读写命令具有MAC设备发起，由两根线组成：\n    MDC:MIIM data clock\n    MDIO:MIIM data I/O`</pre>\n\n    #### 3.2数据总线\n\n    <pre class=\"prettyprint\">`数据总线有很多类型，有MII,RMII,GMII,RGMII,SMII,SSMII,SSSMII,TBI,RTBI,XGMII,XAUI等，以下主要分析常用的总线。\n    1\\. MII(Media Independant Interface)\n        媒体独立接口：一种用于将不同类型的PHY与相同网络控制器(MAC)相连接的通用总线。\n        PIN脚定义(共18脚，包括MIIM)：\n        TXD[0:3]:TX data\n        TXER:TX error\n        TXEN:TX enable\n        TXCLK:TX clk\n        RXD[0:3]:RX data\n        RXER:RX error\n        RXEN:RX enable\n        RXCLK:RX clk\n        CRS：Carrier Sense\n        COL：Collision Detectd\n    2\\. RMII(Reduced Media Independant Interface)\n        简化媒体独立接口：\n        PIN脚定义(共8脚):\n        REF_CLK:是由外部时钟源提供的50MHz参考时钟\n        CRS_DV:此信号是由MII接口中的RX_DV和CRS两个信号合并而成\n        TX_EN:TX enable\n        RX_ER:RX error\n        RXD[0:1]:RX data\n        TXD[0:1]:TX data\n    3\\. SMII(Serial MII)\n        串行媒体独立接口：\n        PIN脚定义：\n        TXD：发送数据信号，位宽为1；\n        RXD：接收数据信号，位宽为1；\n        SYNC：收发数据同步信号，每10个时钟周期置1次高电平，指示同步。\n        CLK_REF：所有端口共用的一个参考时钟，频率为125MHz\n    4\\. GMII(Gigabit MII)\n        千兆媒体独立接口：\n        PIN脚定义(共26脚，包括MIIM)：\n        TXD[0:7]:TX data\n        TXER:TX error\n        TXEN:TX enable\n        TXCLK:TX clk\n        RXD[0:7]:RX data\n        RXER:RX error\n        RXEN:RX enable\n        RXCLK:RX clk\n        CRS：Carrier Sense\n        COL：Collision Detectd\n    5\\. RGMII(Reduced GMII)\n        简化千兆媒体独立接口：\n        PIN脚定义(共8脚):\n        TX_EN:TX enable\n        RX_ER:RX error\n        RX_EN:RX enable\n        RXCLK:125MHz，在上升沿和下降沿都采样\n        TXCLK:125MHz，在上升沿和下降沿都采样\n        RXD[0:3]:RX data\n        TXD[0:3]:TX data\n\n            <div>\n                作者：WEINILUO 发表于2016/6/30 10:36:37 [原文链接](http://blog.csdn.net/weiniluo/article/details/51788068)\n            </div>\n            <div>\n            阅读：169 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51788068#comments)\n            </div>\n","source":"_posts/原-网络驱动接口笔记.md","raw":"---\ntitle: '[原]网络驱动接口笔记'\ntags: []\ndate: 2016-06-30 10:36:37\n---\n\n### 1.OSI七层模型和TCP/IP四层模型\n\n#### 1.1 OSI七层模型和TCP/IP四层模型对应表\n\n\n\n<tr>\n  <th align=\"center\">OSI七层网络模型</th>\n  <th align=\"center\">TCP/IP四层模型</th>\n  <th align=\"center\">对应网络协议</th>\n</tr>\n</thead>\n<tbody><tr>\n  <td align=\"center\">应用层</td>\n  <td align=\"center\"></td>\n  <td align=\"center\">TFTP, FTP, NFS, WAIS</td>\n</tr>\n<tr>\n  <td align=\"center\">表示层</td>\n  <td align=\"center\">应用层</td>\n  <td align=\"center\">Telnet, Rlogin, SNMP, Gopher</td>\n</tr>\n<tr>\n  <td align=\"center\">会话层</td>\n  <td align=\"center\"></td>\n  <td align=\"center\">SMTP, DNS</td>\n</tr>\n<tr>\n  <td align=\"center\">传输层</td>\n  <td align=\"center\">传输层</td>\n  <td align=\"center\">TCP,UDP</td>\n</tr>\n<tr>\n  <td align=\"center\">网络层</td>\n  <td align=\"center\">网际层</td>\n  <td align=\"center\">IP, ICMP, ARP, RARP, AKP, UUCP</td>\n</tr>\n<tr>\n  <td align=\"center\">数据链路层</td>\n  <td align=\"center\"></td>\n  <td align=\"center\">FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td>\n</tr>\n<tr>\n  <td align=\"center\">物理层</td>\n  <td align=\"center\">网络接口层</td>\n  <td align=\"center\">IEEE 802.1A, IEEE 802.2到IEEE 802.11</td>\n</tr>\n</tbody></table>\n\n#### 1.2 OSI七层模型各层的定义\n\n    1.应用层：\n        实现应用进程（如用户程序、终端操作员等）之间的信息交换；\n    2.表示层：\n        为异种机通信提供一种公共语言；\n    3.会话层(RPC)：\n        通过传输层建立数据传输的通路，发起会话或接受会话请求；\n    4.传输层(TCP/UDP)：\n        定义了一些传输数据的协议和端口号（WWW端口80等）；\n    5.网络层(IP)：\n        在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择；\n    6.数据链路层(MAC)：\n        如何格式化数据以进行传输，以及如何控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输；\n    7.物理层(PHY)：\n        主要定义物理设备标准。`</pre>\n\n    ### 2.网络接口结构\n\n    <pre class=\"prettyprint\">`      DMA\n    CPU&lt;=======&gt;MAC&lt;======&gt;PHY\n    网络驱动主要处理MAC层和PHY层的工作。\n    MAC层和PHY层的通信由数据通信总线和控制总线组成。`</pre>\n\n    ### 3.MAC层和PHY层的通信方式\n\n    #### 3.1控制总线MIIM(MII management)\n\n    <pre class=\"prettyprint\">`主要完成对PHY设备的寄存器信息配置。读写命令具有MAC设备发起，由两根线组成：\n    MDC:MIIM data clock\n    MDIO:MIIM data I/O`</pre>\n\n    #### 3.2数据总线\n\n    <pre class=\"prettyprint\">`数据总线有很多类型，有MII,RMII,GMII,RGMII,SMII,SSMII,SSSMII,TBI,RTBI,XGMII,XAUI等，以下主要分析常用的总线。\n    1\\. MII(Media Independant Interface)\n        媒体独立接口：一种用于将不同类型的PHY与相同网络控制器(MAC)相连接的通用总线。\n        PIN脚定义(共18脚，包括MIIM)：\n        TXD[0:3]:TX data\n        TXER:TX error\n        TXEN:TX enable\n        TXCLK:TX clk\n        RXD[0:3]:RX data\n        RXER:RX error\n        RXEN:RX enable\n        RXCLK:RX clk\n        CRS：Carrier Sense\n        COL：Collision Detectd\n    2\\. RMII(Reduced Media Independant Interface)\n        简化媒体独立接口：\n        PIN脚定义(共8脚):\n        REF_CLK:是由外部时钟源提供的50MHz参考时钟\n        CRS_DV:此信号是由MII接口中的RX_DV和CRS两个信号合并而成\n        TX_EN:TX enable\n        RX_ER:RX error\n        RXD[0:1]:RX data\n        TXD[0:1]:TX data\n    3\\. SMII(Serial MII)\n        串行媒体独立接口：\n        PIN脚定义：\n        TXD：发送数据信号，位宽为1；\n        RXD：接收数据信号，位宽为1；\n        SYNC：收发数据同步信号，每10个时钟周期置1次高电平，指示同步。\n        CLK_REF：所有端口共用的一个参考时钟，频率为125MHz\n    4\\. GMII(Gigabit MII)\n        千兆媒体独立接口：\n        PIN脚定义(共26脚，包括MIIM)：\n        TXD[0:7]:TX data\n        TXER:TX error\n        TXEN:TX enable\n        TXCLK:TX clk\n        RXD[0:7]:RX data\n        RXER:RX error\n        RXEN:RX enable\n        RXCLK:RX clk\n        CRS：Carrier Sense\n        COL：Collision Detectd\n    5\\. RGMII(Reduced GMII)\n        简化千兆媒体独立接口：\n        PIN脚定义(共8脚):\n        TX_EN:TX enable\n        RX_ER:RX error\n        RX_EN:RX enable\n        RXCLK:125MHz，在上升沿和下降沿都采样\n        TXCLK:125MHz，在上升沿和下降沿都采样\n        RXD[0:3]:RX data\n        TXD[0:3]:TX data\n\n            <div>\n                作者：WEINILUO 发表于2016/6/30 10:36:37 [原文链接](http://blog.csdn.net/weiniluo/article/details/51788068)\n            </div>\n            <div>\n            阅读：169 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51788068#comments)\n            </div>\n","slug":"原-网络驱动接口笔记","published":1,"updated":"2016-10-20T09:47:23.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnodb000fvzs6f2hx5wqr","content":"<h3 id=\"1-OSI七层模型和TCP-IP四层模型\"><a href=\"#1-OSI七层模型和TCP-IP四层模型\" class=\"headerlink\" title=\"1.OSI七层模型和TCP/IP四层模型\"></a>1.OSI七层模型和TCP/IP四层模型</h3><h4 id=\"1-1-OSI七层模型和TCP-IP四层模型对应表\"><a href=\"#1-1-OSI七层模型和TCP-IP四层模型对应表\" class=\"headerlink\" title=\"1.1 OSI七层模型和TCP/IP四层模型对应表\"></a>1.1 OSI七层模型和TCP/IP四层模型对应表</h4><p><tr><br>  <th align=\"center\">OSI七层网络模型</th><br>  <th align=\"center\">TCP/IP四层模型</th><br>  <th align=\"center\">对应网络协议</th><br></tr><br></p>\n<p><tbody><tr><br>  <td align=\"center\">应用层</td><br>  <td align=\"center\"></td><br>  <td align=\"center\">TFTP, FTP, NFS, WAIS</td><br></tr></tbody></p>\n<p><tr><br>  <td align=\"center\">表示层</td><br>  <td align=\"center\">应用层</td><br>  <td align=\"center\">Telnet, Rlogin, SNMP, Gopher</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">会话层</td><br>  <td align=\"center\"></td><br>  <td align=\"center\">SMTP, DNS</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">传输层</td><br>  <td align=\"center\">传输层</td><br>  <td align=\"center\">TCP,UDP</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">网络层</td><br>  <td align=\"center\">网际层</td><br>  <td align=\"center\">IP, ICMP, ARP, RARP, AKP, UUCP</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">数据链路层</td><br>  <td align=\"center\"></td><br>  <td align=\"center\">FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">物理层</td><br>  <td align=\"center\">网络接口层</td><br>  <td align=\"center\">IEEE 802.1A, IEEE 802.2到IEEE 802.11</td><br></tr><br></p>\n<h4 id=\"1-2-OSI七层模型各层的定义\"><a href=\"#1-2-OSI七层模型各层的定义\" class=\"headerlink\" title=\"1.2 OSI七层模型各层的定义\"></a>1.2 OSI七层模型各层的定义</h4><pre><code>1.应用层：\n    实现应用进程（如用户程序、终端操作员等）之间的信息交换；\n2.表示层：\n    为异种机通信提供一种公共语言；\n3.会话层(RPC)：\n    通过传输层建立数据传输的通路，发起会话或接受会话请求；\n4.传输层(TCP/UDP)：\n    定义了一些传输数据的协议和端口号（WWW端口80等）；\n5.网络层(IP)：\n    在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择；\n6.数据链路层(MAC)：\n    如何格式化数据以进行传输，以及如何控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输；\n7.物理层(PHY)：\n    主要定义物理设备标准。`&lt;/pre&gt;\n\n### 2.网络接口结构\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`      DMA\nCPU&amp;lt;=======&amp;gt;MAC&amp;lt;======&amp;gt;PHY\n网络驱动主要处理MAC层和PHY层的工作。\nMAC层和PHY层的通信由数据通信总线和控制总线组成。`&lt;/pre&gt;\n\n### 3.MAC层和PHY层的通信方式\n\n#### 3.1控制总线MIIM(MII management)\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`主要完成对PHY设备的寄存器信息配置。读写命令具有MAC设备发起，由两根线组成：\nMDC:MIIM data clock\nMDIO:MIIM data I/O`&lt;/pre&gt;\n\n#### 3.2数据总线\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`数据总线有很多类型，有MII,RMII,GMII,RGMII,SMII,SSMII,SSSMII,TBI,RTBI,XGMII,XAUI等，以下主要分析常用的总线。\n1\\. MII(Media Independant Interface)\n    媒体独立接口：一种用于将不同类型的PHY与相同网络控制器(MAC)相连接的通用总线。\n    PIN脚定义(共18脚，包括MIIM)：\n    TXD[0:3]:TX data\n    TXER:TX error\n    TXEN:TX enable\n    TXCLK:TX clk\n    RXD[0:3]:RX data\n    RXER:RX error\n    RXEN:RX enable\n    RXCLK:RX clk\n    CRS：Carrier Sense\n    COL：Collision Detectd\n2\\. RMII(Reduced Media Independant Interface)\n    简化媒体独立接口：\n    PIN脚定义(共8脚):\n    REF_CLK:是由外部时钟源提供的50MHz参考时钟\n    CRS_DV:此信号是由MII接口中的RX_DV和CRS两个信号合并而成\n    TX_EN:TX enable\n    RX_ER:RX error\n    RXD[0:1]:RX data\n    TXD[0:1]:TX data\n3\\. SMII(Serial MII)\n    串行媒体独立接口：\n    PIN脚定义：\n    TXD：发送数据信号，位宽为1；\n    RXD：接收数据信号，位宽为1；\n    SYNC：收发数据同步信号，每10个时钟周期置1次高电平，指示同步。\n    CLK_REF：所有端口共用的一个参考时钟，频率为125MHz\n4\\. GMII(Gigabit MII)\n    千兆媒体独立接口：\n    PIN脚定义(共26脚，包括MIIM)：\n    TXD[0:7]:TX data\n    TXER:TX error\n    TXEN:TX enable\n    TXCLK:TX clk\n    RXD[0:7]:RX data\n    RXER:RX error\n    RXEN:RX enable\n    RXCLK:RX clk\n    CRS：Carrier Sense\n    COL：Collision Detectd\n5\\. RGMII(Reduced GMII)\n    简化千兆媒体独立接口：\n    PIN脚定义(共8脚):\n    TX_EN:TX enable\n    RX_ER:RX error\n    RX_EN:RX enable\n    RXCLK:125MHz，在上升沿和下降沿都采样\n    TXCLK:125MHz，在上升沿和下降沿都采样\n    RXD[0:3]:RX data\n    TXD[0:3]:TX data\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/6/30 10:36:37 [原文链接](http://blog.csdn.net/weiniluo/article/details/51788068)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：169 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51788068#comments)\n        &lt;/div&gt;\n</code></pre>","excerpt":"","more":"<h3 id=\"1-OSI七层模型和TCP-IP四层模型\"><a href=\"#1-OSI七层模型和TCP-IP四层模型\" class=\"headerlink\" title=\"1.OSI七层模型和TCP/IP四层模型\"></a>1.OSI七层模型和TCP/IP四层模型</h3><h4 id=\"1-1-OSI七层模型和TCP-IP四层模型对应表\"><a href=\"#1-1-OSI七层模型和TCP-IP四层模型对应表\" class=\"headerlink\" title=\"1.1 OSI七层模型和TCP/IP四层模型对应表\"></a>1.1 OSI七层模型和TCP/IP四层模型对应表</h4><p><tr><br>  <th align=\"center\">OSI七层网络模型</th><br>  <th align=\"center\">TCP/IP四层模型</th><br>  <th align=\"center\">对应网络协议</th><br></tr><br></thead></p>\n<p><tbody><tr><br>  <td align=\"center\">应用层</td><br>  <td align=\"center\"></td><br>  <td align=\"center\">TFTP, FTP, NFS, WAIS</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">表示层</td><br>  <td align=\"center\">应用层</td><br>  <td align=\"center\">Telnet, Rlogin, SNMP, Gopher</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">会话层</td><br>  <td align=\"center\"></td><br>  <td align=\"center\">SMTP, DNS</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">传输层</td><br>  <td align=\"center\">传输层</td><br>  <td align=\"center\">TCP,UDP</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">网络层</td><br>  <td align=\"center\">网际层</td><br>  <td align=\"center\">IP, ICMP, ARP, RARP, AKP, UUCP</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">数据链路层</td><br>  <td align=\"center\"></td><br>  <td align=\"center\">FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td><br></tr></p>\n<p><tr><br>  <td align=\"center\">物理层</td><br>  <td align=\"center\">网络接口层</td><br>  <td align=\"center\">IEEE 802.1A, IEEE 802.2到IEEE 802.11</td><br></tr><br></tbody></table></p>\n<h4 id=\"1-2-OSI七层模型各层的定义\"><a href=\"#1-2-OSI七层模型各层的定义\" class=\"headerlink\" title=\"1.2 OSI七层模型各层的定义\"></a>1.2 OSI七层模型各层的定义</h4><pre><code>1.应用层：\n    实现应用进程（如用户程序、终端操作员等）之间的信息交换；\n2.表示层：\n    为异种机通信提供一种公共语言；\n3.会话层(RPC)：\n    通过传输层建立数据传输的通路，发起会话或接受会话请求；\n4.传输层(TCP/UDP)：\n    定义了一些传输数据的协议和端口号（WWW端口80等）；\n5.网络层(IP)：\n    在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择；\n6.数据链路层(MAC)：\n    如何格式化数据以进行传输，以及如何控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输；\n7.物理层(PHY)：\n    主要定义物理设备标准。`&lt;/pre&gt;\n\n### 2.网络接口结构\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`      DMA\nCPU&amp;lt;=======&amp;gt;MAC&amp;lt;======&amp;gt;PHY\n网络驱动主要处理MAC层和PHY层的工作。\nMAC层和PHY层的通信由数据通信总线和控制总线组成。`&lt;/pre&gt;\n\n### 3.MAC层和PHY层的通信方式\n\n#### 3.1控制总线MIIM(MII management)\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`主要完成对PHY设备的寄存器信息配置。读写命令具有MAC设备发起，由两根线组成：\nMDC:MIIM data clock\nMDIO:MIIM data I/O`&lt;/pre&gt;\n\n#### 3.2数据总线\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`数据总线有很多类型，有MII,RMII,GMII,RGMII,SMII,SSMII,SSSMII,TBI,RTBI,XGMII,XAUI等，以下主要分析常用的总线。\n1\\. MII(Media Independant Interface)\n    媒体独立接口：一种用于将不同类型的PHY与相同网络控制器(MAC)相连接的通用总线。\n    PIN脚定义(共18脚，包括MIIM)：\n    TXD[0:3]:TX data\n    TXER:TX error\n    TXEN:TX enable\n    TXCLK:TX clk\n    RXD[0:3]:RX data\n    RXER:RX error\n    RXEN:RX enable\n    RXCLK:RX clk\n    CRS：Carrier Sense\n    COL：Collision Detectd\n2\\. RMII(Reduced Media Independant Interface)\n    简化媒体独立接口：\n    PIN脚定义(共8脚):\n    REF_CLK:是由外部时钟源提供的50MHz参考时钟\n    CRS_DV:此信号是由MII接口中的RX_DV和CRS两个信号合并而成\n    TX_EN:TX enable\n    RX_ER:RX error\n    RXD[0:1]:RX data\n    TXD[0:1]:TX data\n3\\. SMII(Serial MII)\n    串行媒体独立接口：\n    PIN脚定义：\n    TXD：发送数据信号，位宽为1；\n    RXD：接收数据信号，位宽为1；\n    SYNC：收发数据同步信号，每10个时钟周期置1次高电平，指示同步。\n    CLK_REF：所有端口共用的一个参考时钟，频率为125MHz\n4\\. GMII(Gigabit MII)\n    千兆媒体独立接口：\n    PIN脚定义(共26脚，包括MIIM)：\n    TXD[0:7]:TX data\n    TXER:TX error\n    TXEN:TX enable\n    TXCLK:TX clk\n    RXD[0:7]:RX data\n    RXER:RX error\n    RXEN:RX enable\n    RXCLK:RX clk\n    CRS：Carrier Sense\n    COL：Collision Detectd\n5\\. RGMII(Reduced GMII)\n    简化千兆媒体独立接口：\n    PIN脚定义(共8脚):\n    TX_EN:TX enable\n    RX_ER:RX error\n    RX_EN:RX enable\n    RXCLK:125MHz，在上升沿和下降沿都采样\n    TXCLK:125MHz，在上升沿和下降沿都采样\n    RXD[0:3]:RX data\n    TXD[0:3]:TX data\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/6/30 10:36:37 [原文链接](http://blog.csdn.net/weiniluo/article/details/51788068)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：169 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51788068#comments)\n        &lt;/div&gt;\n</code></pre>"},{"title":"[原]驱动中ioctl的使用","date":"2016-09-22T22:01:37.000Z","_content":"\n### 1 ioctl调用\n\n    用户空间使用：\n    int ioctl(int fd,unsigned long cmd,...);\n    内核空间声明：\n    int (*ioctl)(struct inode *inode,struct file *filp,unsigned int cmd,unsigned long arg);`</pre>\n\n    ### 2 ioctl命令\n\n    <pre class=\"prettyprint\">`内核约定了定义ioctl命令的相应方法，详细介绍见Documentation/ioctl/ioctl-number.txt和include/asm-generic/ioctl.h\n    定义ioctl命令的方法使用了4个位字段：type,number,direction,size\n    type:幻数字段（8bit）,根据ioctl-number.txt，选择一个号码在整个驱动中使用\n    number:序号字段（8bit），表示第几个命令号\n    direction:传输方向字段（2bit），表示数据传输方向\n    size:数据大小字段（14bit），表示数据传输的大小\n    命令构造方法：_IOC(direction,type,number,size)\n    常用构造命令的宏：\n    #define _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)\n    #define _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))\n    #define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))\n    #define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size))\n    构造命令宏的使用：\n    #define CMD1 _IO(type,1)\n    #define CMD2R _IOR(type,2,int)\n    #define CMD3W _IOW(type,3,int)\n    `</pre>\n\n    ### 3 预定义命令\n\n    <pre class=\"prettyprint\">`预定义命令有三类：\n    1.可用于任何文件的命令；\n    2.只用于普通文件的命令；\n    3.特定于文件系统类型的命令；\n    用于任何文件的常用预定义命令：\n    1.FIOCLEX:设置执行时关闭标志\n    2.FIONCLEX:清除执行时关闭标志\n    2.FIOASYNC:设置或复位文件异步通知\n    2.FIOQSIZE:返回文件或目录大小\n    2.FIONBIO:文件IO非阻塞型IO`</pre>\n\n    ### 4 ioctl参数使用\n\n    <pre class=\"prettyprint\">`这里主要讨论ioctl的最后一个参数，该参数常常是指向用户空间的指针，但使用用户空间的指针必须保证合法，否则可能导致内核崩溃或其他安全问题。（copy_from_user和copy_to_user内部已经实现了相关的安全验证，所以不用关心这个问题）\n    因此，我们需要使用access_ok函数验证地址是否安全：\n    int access_ok(int type,const void *addr,unsigned long size);\n    type:VERIFY_READ/VERIFY_WRITE\n    size:参数大小`</pre>\n\n    ### 5 ioctl返回值\n\n    <pre class=\"prettyprint\">`这里只讨论ioctl命令不匹配时的返回值，通常的做法是返回-EINVAL,但根据POSIX标准，应该返回-ENOTTY.\n\n            <div>\n                作者：WEINILUO 发表于2016/9/22 18:01:37 [原文链接](http://blog.csdn.net/weiniluo/article/details/52625486)\n            </div>\n            <div>\n            阅读：132 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52625486#comments)\n            </div>\n","source":"_posts/原-驱动中ioctl的使用.md","raw":"---\ntitle: '[原]驱动中ioctl的使用'\ntags: []\ndate: 2016-09-22 18:01:37\n---\n\n### 1 ioctl调用\n\n    用户空间使用：\n    int ioctl(int fd,unsigned long cmd,...);\n    内核空间声明：\n    int (*ioctl)(struct inode *inode,struct file *filp,unsigned int cmd,unsigned long arg);`</pre>\n\n    ### 2 ioctl命令\n\n    <pre class=\"prettyprint\">`内核约定了定义ioctl命令的相应方法，详细介绍见Documentation/ioctl/ioctl-number.txt和include/asm-generic/ioctl.h\n    定义ioctl命令的方法使用了4个位字段：type,number,direction,size\n    type:幻数字段（8bit）,根据ioctl-number.txt，选择一个号码在整个驱动中使用\n    number:序号字段（8bit），表示第几个命令号\n    direction:传输方向字段（2bit），表示数据传输方向\n    size:数据大小字段（14bit），表示数据传输的大小\n    命令构造方法：_IOC(direction,type,number,size)\n    常用构造命令的宏：\n    #define _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)\n    #define _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))\n    #define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))\n    #define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size))\n    构造命令宏的使用：\n    #define CMD1 _IO(type,1)\n    #define CMD2R _IOR(type,2,int)\n    #define CMD3W _IOW(type,3,int)\n    `</pre>\n\n    ### 3 预定义命令\n\n    <pre class=\"prettyprint\">`预定义命令有三类：\n    1.可用于任何文件的命令；\n    2.只用于普通文件的命令；\n    3.特定于文件系统类型的命令；\n    用于任何文件的常用预定义命令：\n    1.FIOCLEX:设置执行时关闭标志\n    2.FIONCLEX:清除执行时关闭标志\n    2.FIOASYNC:设置或复位文件异步通知\n    2.FIOQSIZE:返回文件或目录大小\n    2.FIONBIO:文件IO非阻塞型IO`</pre>\n\n    ### 4 ioctl参数使用\n\n    <pre class=\"prettyprint\">`这里主要讨论ioctl的最后一个参数，该参数常常是指向用户空间的指针，但使用用户空间的指针必须保证合法，否则可能导致内核崩溃或其他安全问题。（copy_from_user和copy_to_user内部已经实现了相关的安全验证，所以不用关心这个问题）\n    因此，我们需要使用access_ok函数验证地址是否安全：\n    int access_ok(int type,const void *addr,unsigned long size);\n    type:VERIFY_READ/VERIFY_WRITE\n    size:参数大小`</pre>\n\n    ### 5 ioctl返回值\n\n    <pre class=\"prettyprint\">`这里只讨论ioctl命令不匹配时的返回值，通常的做法是返回-EINVAL,但根据POSIX标准，应该返回-ENOTTY.\n\n            <div>\n                作者：WEINILUO 发表于2016/9/22 18:01:37 [原文链接](http://blog.csdn.net/weiniluo/article/details/52625486)\n            </div>\n            <div>\n            阅读：132 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52625486#comments)\n            </div>\n","slug":"原-驱动中ioctl的使用","published":1,"updated":"2016-10-20T09:59:44.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnode000gvzs6jcr07f09","content":"<h3 id=\"1-ioctl调用\"><a href=\"#1-ioctl调用\" class=\"headerlink\" title=\"1 ioctl调用\"></a>1 ioctl调用</h3><pre><code>用户空间使用：\nint ioctl(int fd,unsigned long cmd,...);\n内核空间声明：\nint (*ioctl)(struct inode *inode,struct file *filp,unsigned int cmd,unsigned long arg);`&lt;/pre&gt;\n\n### 2 ioctl命令\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`内核约定了定义ioctl命令的相应方法，详细介绍见Documentation/ioctl/ioctl-number.txt和include/asm-generic/ioctl.h\n定义ioctl命令的方法使用了4个位字段：type,number,direction,size\ntype:幻数字段（8bit）,根据ioctl-number.txt，选择一个号码在整个驱动中使用\nnumber:序号字段（8bit），表示第几个命令号\ndirection:传输方向字段（2bit），表示数据传输方向\nsize:数据大小字段（14bit），表示数据传输的大小\n命令构造方法：_IOC(direction,type,number,size)\n常用构造命令的宏：\n#define _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)\n#define _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))\n#define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))\n#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size))\n构造命令宏的使用：\n#define CMD1 _IO(type,1)\n#define CMD2R _IOR(type,2,int)\n#define CMD3W _IOW(type,3,int)\n`&lt;/pre&gt;\n\n### 3 预定义命令\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`预定义命令有三类：\n1.可用于任何文件的命令；\n2.只用于普通文件的命令；\n3.特定于文件系统类型的命令；\n用于任何文件的常用预定义命令：\n1.FIOCLEX:设置执行时关闭标志\n2.FIONCLEX:清除执行时关闭标志\n2.FIOASYNC:设置或复位文件异步通知\n2.FIOQSIZE:返回文件或目录大小\n2.FIONBIO:文件IO非阻塞型IO`&lt;/pre&gt;\n\n### 4 ioctl参数使用\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`这里主要讨论ioctl的最后一个参数，该参数常常是指向用户空间的指针，但使用用户空间的指针必须保证合法，否则可能导致内核崩溃或其他安全问题。（copy_from_user和copy_to_user内部已经实现了相关的安全验证，所以不用关心这个问题）\n因此，我们需要使用access_ok函数验证地址是否安全：\nint access_ok(int type,const void *addr,unsigned long size);\ntype:VERIFY_READ/VERIFY_WRITE\nsize:参数大小`&lt;/pre&gt;\n\n### 5 ioctl返回值\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`这里只讨论ioctl命令不匹配时的返回值，通常的做法是返回-EINVAL,但根据POSIX标准，应该返回-ENOTTY.\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/9/22 18:01:37 [原文链接](http://blog.csdn.net/weiniluo/article/details/52625486)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：132 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52625486#comments)\n        &lt;/div&gt;\n</code></pre>","excerpt":"","more":"<h3 id=\"1-ioctl调用\"><a href=\"#1-ioctl调用\" class=\"headerlink\" title=\"1 ioctl调用\"></a>1 ioctl调用</h3><pre><code>用户空间使用：\nint ioctl(int fd,unsigned long cmd,...);\n内核空间声明：\nint (*ioctl)(struct inode *inode,struct file *filp,unsigned int cmd,unsigned long arg);`&lt;/pre&gt;\n\n### 2 ioctl命令\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`内核约定了定义ioctl命令的相应方法，详细介绍见Documentation/ioctl/ioctl-number.txt和include/asm-generic/ioctl.h\n定义ioctl命令的方法使用了4个位字段：type,number,direction,size\ntype:幻数字段（8bit）,根据ioctl-number.txt，选择一个号码在整个驱动中使用\nnumber:序号字段（8bit），表示第几个命令号\ndirection:传输方向字段（2bit），表示数据传输方向\nsize:数据大小字段（14bit），表示数据传输的大小\n命令构造方法：_IOC(direction,type,number,size)\n常用构造命令的宏：\n#define _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)\n#define _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))\n#define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))\n#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size))\n构造命令宏的使用：\n#define CMD1 _IO(type,1)\n#define CMD2R _IOR(type,2,int)\n#define CMD3W _IOW(type,3,int)\n`&lt;/pre&gt;\n\n### 3 预定义命令\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`预定义命令有三类：\n1.可用于任何文件的命令；\n2.只用于普通文件的命令；\n3.特定于文件系统类型的命令；\n用于任何文件的常用预定义命令：\n1.FIOCLEX:设置执行时关闭标志\n2.FIONCLEX:清除执行时关闭标志\n2.FIOASYNC:设置或复位文件异步通知\n2.FIOQSIZE:返回文件或目录大小\n2.FIONBIO:文件IO非阻塞型IO`&lt;/pre&gt;\n\n### 4 ioctl参数使用\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`这里主要讨论ioctl的最后一个参数，该参数常常是指向用户空间的指针，但使用用户空间的指针必须保证合法，否则可能导致内核崩溃或其他安全问题。（copy_from_user和copy_to_user内部已经实现了相关的安全验证，所以不用关心这个问题）\n因此，我们需要使用access_ok函数验证地址是否安全：\nint access_ok(int type,const void *addr,unsigned long size);\ntype:VERIFY_READ/VERIFY_WRITE\nsize:参数大小`&lt;/pre&gt;\n\n### 5 ioctl返回值\n\n&lt;pre class=&quot;prettyprint&quot;&gt;`这里只讨论ioctl命令不匹配时的返回值，通常的做法是返回-EINVAL,但根据POSIX标准，应该返回-ENOTTY.\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/9/22 18:01:37 [原文链接](http://blog.csdn.net/weiniluo/article/details/52625486)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：132 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52625486#comments)\n        &lt;/div&gt;\n</code></pre>"},{"title":"[转]MIPI 小结","date":"2016-04-25T20:03:25.000Z","_content":"\n# 1.MIPI联盟\n\nMIPI (Mobile Industry Processor Interface) 是2003年由ARM, Nokia, ST ,TI等公司成立的一个联盟，目的是把手机内部的接口如摄像头、显示屏接口、射频/基带接口等标准化。MIPI联盟下面有不同的WorkGroup，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI、显示接口DSI、射频接口DigRF、麦克风 /喇叭接口SLIMbus等。\n\n# 2.MIPI camera WorkGroup\n\n## 2.1 CSI\n\n    摄像头串行接口\n    `</pre>\n\n    # 3.MIPI display WorkGroup\n\n    ## 3.1 DCS\n\n    <pre>`显示接口命令集\n    `</pre>\n\n    ## 3.2 DBI\n\n    <pre>`MCU并行接口,lcd的ic包含GRAM的情况下，使用该接口\n    `</pre>\n\n    ## 3.3 DPI\n\n    <pre>`RGB并行接口，lcd的ic没有GRAM的情况下，使用该接口\n    `</pre>\n\n    ## 3.4 DSI\n\n    ### 3.4.1 DSI分层结构\n\n    <pre>`DSI分四层，对应DCS,DSI,D-PHY规范。\n    `</pre>\n\n    ### 3.4.2 command和video模式\n\n    <pre>`command模式类似MCU接口的串行模式，适用于有GRAM的LCD。\n    video模式类似RGB接口的串行模式，适用于无GRAM的LCD。\n    `</pre>\n\n    ### 3.4.3 D-PHY介绍\n\n    <pre>`1.传输模式\n    LP(LOW POWER)低功耗模式，用于控制。\n    HS(HIGH SPEED)高速模式，用于图像数据传输。\n    2.操作模式\n    Escape mode\n    High-Speed(Burst) mode\n    Control mode    \n    `</pre>\n\n    ### 3.4.4DSI介绍\n\n    <pre>`1.传输模式\n    高速信号传输模式\n    低功耗信号传输模式，只使用lane0\n    2.操作模式\n    &lt;1&gt;command mode：\n    &lt;2&gt;video mosde(需使用高速传输模式)：\n        Non-Burst 同步脉冲模式\n        Non-Burst 同步事件模式\n        Burst模式\n\n            <div>\n                作者：WEINILUO 发表于2016/4/25 16:03:25 [原文链接](http://blog.csdn.net/weiniluo/article/details/51242526)\n            </div>\n            <div>\n            阅读：113 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51242526#comments)\n            </div>\n","source":"_posts/转-MIPI-小结.md","raw":"---\ntitle: '[转]MIPI 小结'\ntags: []\ndate: 2016-04-25 16:03:25\n---\n\n# 1.MIPI联盟\n\nMIPI (Mobile Industry Processor Interface) 是2003年由ARM, Nokia, ST ,TI等公司成立的一个联盟，目的是把手机内部的接口如摄像头、显示屏接口、射频/基带接口等标准化。MIPI联盟下面有不同的WorkGroup，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI、显示接口DSI、射频接口DigRF、麦克风 /喇叭接口SLIMbus等。\n\n# 2.MIPI camera WorkGroup\n\n## 2.1 CSI\n\n    摄像头串行接口\n    `</pre>\n\n    # 3.MIPI display WorkGroup\n\n    ## 3.1 DCS\n\n    <pre>`显示接口命令集\n    `</pre>\n\n    ## 3.2 DBI\n\n    <pre>`MCU并行接口,lcd的ic包含GRAM的情况下，使用该接口\n    `</pre>\n\n    ## 3.3 DPI\n\n    <pre>`RGB并行接口，lcd的ic没有GRAM的情况下，使用该接口\n    `</pre>\n\n    ## 3.4 DSI\n\n    ### 3.4.1 DSI分层结构\n\n    <pre>`DSI分四层，对应DCS,DSI,D-PHY规范。\n    `</pre>\n\n    ### 3.4.2 command和video模式\n\n    <pre>`command模式类似MCU接口的串行模式，适用于有GRAM的LCD。\n    video模式类似RGB接口的串行模式，适用于无GRAM的LCD。\n    `</pre>\n\n    ### 3.4.3 D-PHY介绍\n\n    <pre>`1.传输模式\n    LP(LOW POWER)低功耗模式，用于控制。\n    HS(HIGH SPEED)高速模式，用于图像数据传输。\n    2.操作模式\n    Escape mode\n    High-Speed(Burst) mode\n    Control mode    \n    `</pre>\n\n    ### 3.4.4DSI介绍\n\n    <pre>`1.传输模式\n    高速信号传输模式\n    低功耗信号传输模式，只使用lane0\n    2.操作模式\n    &lt;1&gt;command mode：\n    &lt;2&gt;video mosde(需使用高速传输模式)：\n        Non-Burst 同步脉冲模式\n        Non-Burst 同步事件模式\n        Burst模式\n\n            <div>\n                作者：WEINILUO 发表于2016/4/25 16:03:25 [原文链接](http://blog.csdn.net/weiniluo/article/details/51242526)\n            </div>\n            <div>\n            阅读：113 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51242526#comments)\n            </div>\n","slug":"转-MIPI-小结","published":1,"updated":"2016-10-20T10:00:03.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnodp000hvzs6hl6tzta3","content":"<h1 id=\"1-MIPI联盟\"><a href=\"#1-MIPI联盟\" class=\"headerlink\" title=\"1.MIPI联盟\"></a>1.MIPI联盟</h1><p>MIPI (Mobile Industry Processor Interface) 是2003年由ARM, Nokia, ST ,TI等公司成立的一个联盟，目的是把手机内部的接口如摄像头、显示屏接口、射频/基带接口等标准化。MIPI联盟下面有不同的WorkGroup，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI、显示接口DSI、射频接口DigRF、麦克风 /喇叭接口SLIMbus等。</p>\n<h1 id=\"2-MIPI-camera-WorkGroup\"><a href=\"#2-MIPI-camera-WorkGroup\" class=\"headerlink\" title=\"2.MIPI camera WorkGroup\"></a>2.MIPI camera WorkGroup</h1><h2 id=\"2-1-CSI\"><a href=\"#2-1-CSI\" class=\"headerlink\" title=\"2.1 CSI\"></a>2.1 CSI</h2><pre><code>摄像头串行接口\n`&lt;/pre&gt;\n\n# 3.MIPI display WorkGroup\n\n## 3.1 DCS\n\n&lt;pre&gt;`显示接口命令集\n`&lt;/pre&gt;\n\n## 3.2 DBI\n\n&lt;pre&gt;`MCU并行接口,lcd的ic包含GRAM的情况下，使用该接口\n`&lt;/pre&gt;\n\n## 3.3 DPI\n\n&lt;pre&gt;`RGB并行接口，lcd的ic没有GRAM的情况下，使用该接口\n`&lt;/pre&gt;\n\n## 3.4 DSI\n\n### 3.4.1 DSI分层结构\n\n&lt;pre&gt;`DSI分四层，对应DCS,DSI,D-PHY规范。\n`&lt;/pre&gt;\n\n### 3.4.2 command和video模式\n\n&lt;pre&gt;`command模式类似MCU接口的串行模式，适用于有GRAM的LCD。\nvideo模式类似RGB接口的串行模式，适用于无GRAM的LCD。\n`&lt;/pre&gt;\n\n### 3.4.3 D-PHY介绍\n\n&lt;pre&gt;`1.传输模式\nLP(LOW POWER)低功耗模式，用于控制。\nHS(HIGH SPEED)高速模式，用于图像数据传输。\n2.操作模式\nEscape mode\nHigh-Speed(Burst) mode\nControl mode    \n`&lt;/pre&gt;\n\n### 3.4.4DSI介绍\n\n&lt;pre&gt;`1.传输模式\n高速信号传输模式\n低功耗信号传输模式，只使用lane0\n2.操作模式\n&amp;lt;1&amp;gt;command mode：\n&amp;lt;2&amp;gt;video mosde(需使用高速传输模式)：\n    Non-Burst 同步脉冲模式\n    Non-Burst 同步事件模式\n    Burst模式\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/4/25 16:03:25 [原文链接](http://blog.csdn.net/weiniluo/article/details/51242526)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：113 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51242526#comments)\n        &lt;/div&gt;\n</code></pre>","excerpt":"","more":"<h1 id=\"1-MIPI联盟\"><a href=\"#1-MIPI联盟\" class=\"headerlink\" title=\"1.MIPI联盟\"></a>1.MIPI联盟</h1><p>MIPI (Mobile Industry Processor Interface) 是2003年由ARM, Nokia, ST ,TI等公司成立的一个联盟，目的是把手机内部的接口如摄像头、显示屏接口、射频/基带接口等标准化。MIPI联盟下面有不同的WorkGroup，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI、显示接口DSI、射频接口DigRF、麦克风 /喇叭接口SLIMbus等。</p>\n<h1 id=\"2-MIPI-camera-WorkGroup\"><a href=\"#2-MIPI-camera-WorkGroup\" class=\"headerlink\" title=\"2.MIPI camera WorkGroup\"></a>2.MIPI camera WorkGroup</h1><h2 id=\"2-1-CSI\"><a href=\"#2-1-CSI\" class=\"headerlink\" title=\"2.1 CSI\"></a>2.1 CSI</h2><pre><code>摄像头串行接口\n`&lt;/pre&gt;\n\n# 3.MIPI display WorkGroup\n\n## 3.1 DCS\n\n&lt;pre&gt;`显示接口命令集\n`&lt;/pre&gt;\n\n## 3.2 DBI\n\n&lt;pre&gt;`MCU并行接口,lcd的ic包含GRAM的情况下，使用该接口\n`&lt;/pre&gt;\n\n## 3.3 DPI\n\n&lt;pre&gt;`RGB并行接口，lcd的ic没有GRAM的情况下，使用该接口\n`&lt;/pre&gt;\n\n## 3.4 DSI\n\n### 3.4.1 DSI分层结构\n\n&lt;pre&gt;`DSI分四层，对应DCS,DSI,D-PHY规范。\n`&lt;/pre&gt;\n\n### 3.4.2 command和video模式\n\n&lt;pre&gt;`command模式类似MCU接口的串行模式，适用于有GRAM的LCD。\nvideo模式类似RGB接口的串行模式，适用于无GRAM的LCD。\n`&lt;/pre&gt;\n\n### 3.4.3 D-PHY介绍\n\n&lt;pre&gt;`1.传输模式\nLP(LOW POWER)低功耗模式，用于控制。\nHS(HIGH SPEED)高速模式，用于图像数据传输。\n2.操作模式\nEscape mode\nHigh-Speed(Burst) mode\nControl mode    \n`&lt;/pre&gt;\n\n### 3.4.4DSI介绍\n\n&lt;pre&gt;`1.传输模式\n高速信号传输模式\n低功耗信号传输模式，只使用lane0\n2.操作模式\n&amp;lt;1&amp;gt;command mode：\n&amp;lt;2&amp;gt;video mosde(需使用高速传输模式)：\n    Non-Burst 同步脉冲模式\n    Non-Burst 同步事件模式\n    Burst模式\n\n        &lt;div&gt;\n            作者：WEINILUO 发表于2016/4/25 16:03:25 [原文链接](http://blog.csdn.net/weiniluo/article/details/51242526)\n        &lt;/div&gt;\n        &lt;div&gt;\n        阅读：113 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51242526#comments)\n        &lt;/div&gt;\n</code></pre>"},{"title":"[转]__attribute__机制","date":"2016-09-12T14:41:13.000Z","_content":"\n内核中常会用到**attribute**，今天仔细了解一下这个**attribute**机制。\n\n### 1.概要\n\n**attribute**可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。它的书写特征是：**attribute**前后都有两个下划线，后面attribute-list是相应的**attribute**参数，语法格式如下： \n\n**attribute** ((attribute-list)) \n\n另外，它必须放于声明的尾部“；”之前。\n\n### 2.函数属性\n\n函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。**attribute**机制也很容易同非GNU应用程序做到兼容之功效。 \n\n    GNU CC需要使用 –Wall编译器来击活该功能，这是控制警告信息的一个很好的方式。下面介绍几个常见的属性参数。 \n\n    **attribute** format。该**attribute**属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。format的语法格式为： \n\nformat (archetype, string-index, first-to-check) \n\nformat属性告诉编译器，按照printf, scanf, strftime或strfmon的参数表格式规则对该函数的参数进行检查。“archetype”指定是哪种风格；“string-index”指定传入函数的第几个参数是格式化字符串；“first-to-check”指定从函数的第几个参数开始按上述规则进行检查。 \n\n具体使用格式如下： \n\n**attribute**((format(printf,m,n))) \n\n**attribute**((format(scanf,m,n))) \n\n其中参数m与n的含义为： \n\nm：第几个参数为格式化字符串（format string）； \n\nn：参数集合中的第一个，即参数“…”里的第一个参数在函数参数总数排在第几，注意，有时函数参数里还有“隐身”的呢，后面会提到； \n\n    在使用上，**attribute**((format(printf,m,n)))是常用的，而另一种却很少见到。下面举例说明，其中myprint为自己定义的一个带有可变参数的函数，其功能类似于printf： \n\n//m=1；n=2 \n\nextern void myprint(const char *format,…) **attribute**((format(printf,1,2))); \n\n//m=2；n=3 \n\nextern void myprint(int l，const char *format,…) **attribute**((format(printf,2,3))); \n\n需要特别注意的是，如果myprint是一个函数的成员函数，那么m和n的值可有点“悬乎”了，例如： \n\n//m=3；n=4 \n\nextern void myprint(int l，const char *format,…) **attribute**((format(printf,3,4))); \n\n    其原因是，类成员函数的第一个参数实际上一个“隐身”的“this”指针。（有点C++基础的都知道点this指针，不知道你在这里还知道吗？） \n\n    这里给出测试用例：attribute.c，代码如下： \n\n[cpp] view plain copy \n\nextern void myprint(const char *format,…) **attribute**((format(printf,1,2))); \n\n    void test() \n\n    { \n\n        myprint(“i=%d\\n”,6); \n\n        myprint(“i=%s\\n”,6); \n\n        myprint(“i=%s\\n”,”abc”); \n\n        myprint(“%s,%d,%d\\n”,1,2); \n\n    } \n\n    gcc编译后会提示format argument is not a pointer的警告。若去掉**attribute**((format(printf,1,2)))，则会正常编译。需要注意的是，编译器只能识别类似printf的标准输出库函数。 \n\n    还有一个**attribute** noreturn，该属性通知编译器函数从不返回值，当遇到类似函数需要返回值而却不可能运行到返回值处就已经退出来的情况，该属性可以避免出现错误信息。C库函数中的abort()和exit()的声明格式就采用了这种格式，如下所示：  \n\nextern void exit(int)   **attribute**((noreturn)); \n\nextern void abort(void) **attribute**((noreturn)); \n\n为了方便理解，大家可以参考如下的例子： \n\n[cpp] view plain copy \n\n//name: noreturn.c  ；测试**attribute**((noreturn)) \n\n    extern void myexit(); \n\n    int test(int n) \n\n    { \n\n        if ( n &gt; 0 ) \n\n        { \n\n            myexit(); \n\n            /* 程序不可能到达这里*/ \n\n        } \n\n        else \n\n            return 0; \n\n    } \n\n编译后的输出结果如下： \n\n$gcc –Wall –c noreturn.c \n\nnoreturn.c: In function `test’: \n\nnoreturn.c:12: warning: control reaches end of non-void function \n\n    很显然，这是因为一个被定义为有返回值的函数却没有返回值。加上**attribute**((noreturn))则可以解决此问题的出现。 \n\n    后面还有__attribute__const、-finstrument-functions、no_instrument_function等的属性描述，就不多转了，感兴趣的可以看原文。\n\n### 3.变量属性(Variable Attribute)\n\n    关键字__attribute__也可以对变量或结构体成员进行属性设置。这里给出几个常用的参数的解释，更多的参数可参考原文给出的连接。\n    在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。\n    `</pre>\n\n    aligned (alignment) \n\n    该属性规定变量或结构体成员的最小的对齐格式，以字节为单位。例如： \n\n    int x **attribute** ((aligned (16))) = 0; \n\n        编译器将以16字节（注意是字节byte不是位bit）对齐的方式分配一个变量。也可以对结构体成员变量设置该属性，例如，创建一个双字对齐的int对，可以这么写： \n\n    struct foo { int x[2] **attribute** ((aligned (8))); }; \n\n        如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如： \n\n    short array[3] **attribute** ((aligned)); \n\n        选择针对目标机器最大的对齐方式，可以提高拷贝操作的效率。aligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。 \n\n        需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。 \n\n        使用该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。 \n\n        下面的例子中，x成员变量使用了该属性，则其值将紧放置在a的后面：  \n\n           struct test \n\n              { \n\n                char a; \n\n                int x[2] **attribute** ((packed)); \n\n              }; \n\n        其它可选的属性值还可以是：cleanup，common，nocommon，deprecated，mode，section，shared，tls_model，transparent_union，unused，vector_size，weak，dllimport，dlexport等。\n\n    ### 4.类型属性（Type Attribute）\n\n    <pre>`关键字__attribute__也可以对结构体（struct）或共用体（union）进行属性设置。大致有六个参数值可以被设定，即：aligned, packed, transparent_union, unused, deprecated 和 may_alias。\n    在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。\n\naligned (alignment) \n\n该属性设定一个指定大小的对齐格式（以字节为单位），例如：  \n\nstruct S { short f[3]; } **attribute** ((aligned (8))); \n\ntypedef int more_aligned_int **attribute** ((aligned (8))); \n\n    该声明将强制编译器确保（尽它所能）变量类型为struct S或者more-aligned-int的变量在分配空间时采用8字节对齐方式。 \n\n    如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如： \n\nstruct S { short f[3]; } **attribute** ((aligned)); \n\n这里，如果sizeof（short）的大小为2（byte），那么，S的大小就为6。取一个2的次方值，使得该值大于等于6，则该值为8，所以编译器将设置S类型的对齐方式为8字节。 \n\naligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。 \n\n需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。 \n\n    使用该属性对struct或者union类型进行定义，设定其类型的每一个变量的内存约束。当用在enum类型定义时，暗示了应该使用最小完整的类型（it indicates that the smallest integral type should be used）。 \n\n    下面的例子中，my-packed-struct类型的变量数组中的值将会紧紧的靠在一起，但内部的成员变量s不会被“pack”，如果希望内部的成员变量也被packed的话，my-unpacked-struct也需要使用packed进行相应的约束。  \n\nstruct my_unpacked_struct \n\n{ \n\n      char c; \n\n      int i; \n\n};\n\nstruct my_packed_struct \n\n{ \n\n     char c; \n\n     int  i; \n\n     struct my_unpacked_struct s; \n\n}**attribute** ((**packed**));\n\n            <div>\n                作者：WEINILUO 发表于2016/9/12 10:41:13 [原文链接](http://blog.csdn.net/weiniluo/article/details/52510949)\n            </div>\n            <div>\n            阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52510949#comments)\n            </div>\n","source":"_posts/转-attribute-机制.md","raw":"---\ntitle: '[转]__attribute__机制'\ntags: []\ndate: 2016-09-12 10:41:13\n---\n\n内核中常会用到**attribute**，今天仔细了解一下这个**attribute**机制。\n\n### 1.概要\n\n**attribute**可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。它的书写特征是：**attribute**前后都有两个下划线，后面attribute-list是相应的**attribute**参数，语法格式如下： \n\n**attribute** ((attribute-list)) \n\n另外，它必须放于声明的尾部“；”之前。\n\n### 2.函数属性\n\n函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。**attribute**机制也很容易同非GNU应用程序做到兼容之功效。 \n\n    GNU CC需要使用 –Wall编译器来击活该功能，这是控制警告信息的一个很好的方式。下面介绍几个常见的属性参数。 \n\n    **attribute** format。该**attribute**属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。format的语法格式为： \n\nformat (archetype, string-index, first-to-check) \n\nformat属性告诉编译器，按照printf, scanf, strftime或strfmon的参数表格式规则对该函数的参数进行检查。“archetype”指定是哪种风格；“string-index”指定传入函数的第几个参数是格式化字符串；“first-to-check”指定从函数的第几个参数开始按上述规则进行检查。 \n\n具体使用格式如下： \n\n**attribute**((format(printf,m,n))) \n\n**attribute**((format(scanf,m,n))) \n\n其中参数m与n的含义为： \n\nm：第几个参数为格式化字符串（format string）； \n\nn：参数集合中的第一个，即参数“…”里的第一个参数在函数参数总数排在第几，注意，有时函数参数里还有“隐身”的呢，后面会提到； \n\n    在使用上，**attribute**((format(printf,m,n)))是常用的，而另一种却很少见到。下面举例说明，其中myprint为自己定义的一个带有可变参数的函数，其功能类似于printf： \n\n//m=1；n=2 \n\nextern void myprint(const char *format,…) **attribute**((format(printf,1,2))); \n\n//m=2；n=3 \n\nextern void myprint(int l，const char *format,…) **attribute**((format(printf,2,3))); \n\n需要特别注意的是，如果myprint是一个函数的成员函数，那么m和n的值可有点“悬乎”了，例如： \n\n//m=3；n=4 \n\nextern void myprint(int l，const char *format,…) **attribute**((format(printf,3,4))); \n\n    其原因是，类成员函数的第一个参数实际上一个“隐身”的“this”指针。（有点C++基础的都知道点this指针，不知道你在这里还知道吗？） \n\n    这里给出测试用例：attribute.c，代码如下： \n\n[cpp] view plain copy \n\nextern void myprint(const char *format,…) **attribute**((format(printf,1,2))); \n\n    void test() \n\n    { \n\n        myprint(“i=%d\\n”,6); \n\n        myprint(“i=%s\\n”,6); \n\n        myprint(“i=%s\\n”,”abc”); \n\n        myprint(“%s,%d,%d\\n”,1,2); \n\n    } \n\n    gcc编译后会提示format argument is not a pointer的警告。若去掉**attribute**((format(printf,1,2)))，则会正常编译。需要注意的是，编译器只能识别类似printf的标准输出库函数。 \n\n    还有一个**attribute** noreturn，该属性通知编译器函数从不返回值，当遇到类似函数需要返回值而却不可能运行到返回值处就已经退出来的情况，该属性可以避免出现错误信息。C库函数中的abort()和exit()的声明格式就采用了这种格式，如下所示：  \n\nextern void exit(int)   **attribute**((noreturn)); \n\nextern void abort(void) **attribute**((noreturn)); \n\n为了方便理解，大家可以参考如下的例子： \n\n[cpp] view plain copy \n\n//name: noreturn.c  ；测试**attribute**((noreturn)) \n\n    extern void myexit(); \n\n    int test(int n) \n\n    { \n\n        if ( n &gt; 0 ) \n\n        { \n\n            myexit(); \n\n            /* 程序不可能到达这里*/ \n\n        } \n\n        else \n\n            return 0; \n\n    } \n\n编译后的输出结果如下： \n\n$gcc –Wall –c noreturn.c \n\nnoreturn.c: In function `test’: \n\nnoreturn.c:12: warning: control reaches end of non-void function \n\n    很显然，这是因为一个被定义为有返回值的函数却没有返回值。加上**attribute**((noreturn))则可以解决此问题的出现。 \n\n    后面还有__attribute__const、-finstrument-functions、no_instrument_function等的属性描述，就不多转了，感兴趣的可以看原文。\n\n### 3.变量属性(Variable Attribute)\n\n    关键字__attribute__也可以对变量或结构体成员进行属性设置。这里给出几个常用的参数的解释，更多的参数可参考原文给出的连接。\n    在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。\n    `</pre>\n\n    aligned (alignment) \n\n    该属性规定变量或结构体成员的最小的对齐格式，以字节为单位。例如： \n\n    int x **attribute** ((aligned (16))) = 0; \n\n        编译器将以16字节（注意是字节byte不是位bit）对齐的方式分配一个变量。也可以对结构体成员变量设置该属性，例如，创建一个双字对齐的int对，可以这么写： \n\n    struct foo { int x[2] **attribute** ((aligned (8))); }; \n\n        如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如： \n\n    short array[3] **attribute** ((aligned)); \n\n        选择针对目标机器最大的对齐方式，可以提高拷贝操作的效率。aligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。 \n\n        需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。 \n\n        使用该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。 \n\n        下面的例子中，x成员变量使用了该属性，则其值将紧放置在a的后面：  \n\n           struct test \n\n              { \n\n                char a; \n\n                int x[2] **attribute** ((packed)); \n\n              }; \n\n        其它可选的属性值还可以是：cleanup，common，nocommon，deprecated，mode，section，shared，tls_model，transparent_union，unused，vector_size，weak，dllimport，dlexport等。\n\n    ### 4.类型属性（Type Attribute）\n\n    <pre>`关键字__attribute__也可以对结构体（struct）或共用体（union）进行属性设置。大致有六个参数值可以被设定，即：aligned, packed, transparent_union, unused, deprecated 和 may_alias。\n    在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。\n\naligned (alignment) \n\n该属性设定一个指定大小的对齐格式（以字节为单位），例如：  \n\nstruct S { short f[3]; } **attribute** ((aligned (8))); \n\ntypedef int more_aligned_int **attribute** ((aligned (8))); \n\n    该声明将强制编译器确保（尽它所能）变量类型为struct S或者more-aligned-int的变量在分配空间时采用8字节对齐方式。 \n\n    如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如： \n\nstruct S { short f[3]; } **attribute** ((aligned)); \n\n这里，如果sizeof（short）的大小为2（byte），那么，S的大小就为6。取一个2的次方值，使得该值大于等于6，则该值为8，所以编译器将设置S类型的对齐方式为8字节。 \n\naligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。 \n\n需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。 \n\n    使用该属性对struct或者union类型进行定义，设定其类型的每一个变量的内存约束。当用在enum类型定义时，暗示了应该使用最小完整的类型（it indicates that the smallest integral type should be used）。 \n\n    下面的例子中，my-packed-struct类型的变量数组中的值将会紧紧的靠在一起，但内部的成员变量s不会被“pack”，如果希望内部的成员变量也被packed的话，my-unpacked-struct也需要使用packed进行相应的约束。  \n\nstruct my_unpacked_struct \n\n{ \n\n      char c; \n\n      int i; \n\n};\n\nstruct my_packed_struct \n\n{ \n\n     char c; \n\n     int  i; \n\n     struct my_unpacked_struct s; \n\n}**attribute** ((**packed**));\n\n            <div>\n                作者：WEINILUO 发表于2016/9/12 10:41:13 [原文链接](http://blog.csdn.net/weiniluo/article/details/52510949)\n            </div>\n            <div>\n            阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52510949#comments)\n            </div>\n","slug":"转-attribute-机制","published":1,"updated":"2016-10-20T09:58:25.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnodr000ivzs6lf32lfqb","content":"<p>内核中常会用到<strong>attribute</strong>，今天仔细了解一下这个<strong>attribute</strong>机制。</p>\n<h3 id=\"1-概要\"><a href=\"#1-概要\" class=\"headerlink\" title=\"1.概要\"></a>1.概要</h3><p><strong>attribute</strong>可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。它的书写特征是：<strong>attribute</strong>前后都有两个下划线，后面attribute-list是相应的<strong>attribute</strong>参数，语法格式如下： </p>\n<p><strong>attribute</strong> ((attribute-list)) </p>\n<p>另外，它必须放于声明的尾部“；”之前。</p>\n<h3 id=\"2-函数属性\"><a href=\"#2-函数属性\" class=\"headerlink\" title=\"2.函数属性\"></a>2.函数属性</h3><p>函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。<strong>attribute</strong>机制也很容易同非GNU应用程序做到兼容之功效。 </p>\n<pre><code>GNU CC需要使用 –Wall编译器来击活该功能，这是控制警告信息的一个很好的方式。下面介绍几个常见的属性参数。 \n\n**attribute** format。该**attribute**属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。format的语法格式为： \n</code></pre><p>format (archetype, string-index, first-to-check) </p>\n<p>format属性告诉编译器，按照printf, scanf, strftime或strfmon的参数表格式规则对该函数的参数进行检查。“archetype”指定是哪种风格；“string-index”指定传入函数的第几个参数是格式化字符串；“first-to-check”指定从函数的第几个参数开始按上述规则进行检查。 </p>\n<p>具体使用格式如下： </p>\n<p><strong>attribute</strong>((format(printf,m,n))) </p>\n<p><strong>attribute</strong>((format(scanf,m,n))) </p>\n<p>其中参数m与n的含义为： </p>\n<p>m：第几个参数为格式化字符串（format string）； </p>\n<p>n：参数集合中的第一个，即参数“…”里的第一个参数在函数参数总数排在第几，注意，有时函数参数里还有“隐身”的呢，后面会提到； </p>\n<pre><code>在使用上，**attribute**((format(printf,m,n)))是常用的，而另一种却很少见到。下面举例说明，其中myprint为自己定义的一个带有可变参数的函数，其功能类似于printf： \n</code></pre><p>//m=1；n=2 </p>\n<p>extern void myprint(const char <em>format,…) <em>*attribute</em></em>((format(printf,1,2))); </p>\n<p>//m=2；n=3 </p>\n<p>extern void myprint(int l，const char <em>format,…) <em>*attribute</em></em>((format(printf,2,3))); </p>\n<p>需要特别注意的是，如果myprint是一个函数的成员函数，那么m和n的值可有点“悬乎”了，例如： </p>\n<p>//m=3；n=4 </p>\n<p>extern void myprint(int l，const char <em>format,…) <em>*attribute</em></em>((format(printf,3,4))); </p>\n<pre><code>其原因是，类成员函数的第一个参数实际上一个“隐身”的“this”指针。（有点C++基础的都知道点this指针，不知道你在这里还知道吗？） \n\n这里给出测试用例：attribute.c，代码如下： \n</code></pre><p>[cpp] view plain copy </p>\n<p>extern void myprint(const char <em>format,…) <em>*attribute</em></em>((format(printf,1,2))); </p>\n<pre><code>void test() \n\n{ \n\n    myprint(“i=%d\\n”,6); \n\n    myprint(“i=%s\\n”,6); \n\n    myprint(“i=%s\\n”,”abc”); \n\n    myprint(“%s,%d,%d\\n”,1,2); \n\n} \n\ngcc编译后会提示format argument is not a pointer的警告。若去掉**attribute**((format(printf,1,2)))，则会正常编译。需要注意的是，编译器只能识别类似printf的标准输出库函数。 \n\n还有一个**attribute** noreturn，该属性通知编译器函数从不返回值，当遇到类似函数需要返回值而却不可能运行到返回值处就已经退出来的情况，该属性可以避免出现错误信息。C库函数中的abort()和exit()的声明格式就采用了这种格式，如下所示：  \n</code></pre><p>extern void exit(int)   <strong>attribute</strong>((noreturn)); </p>\n<p>extern void abort(void) <strong>attribute</strong>((noreturn)); </p>\n<p>为了方便理解，大家可以参考如下的例子： </p>\n<p>[cpp] view plain copy </p>\n<p>//name: noreturn.c  ；测试<strong>attribute</strong>((noreturn)) </p>\n<pre><code>extern void myexit(); \n\nint test(int n) \n\n{ \n\n    if ( n &amp;gt; 0 ) \n\n    { \n\n        myexit(); \n\n        /* 程序不可能到达这里*/ \n\n    } \n\n    else \n\n        return 0; \n\n} \n</code></pre><p>编译后的输出结果如下： </p>\n<p>$gcc –Wall –c noreturn.c </p>\n<p>noreturn.c: In function `test’: </p>\n<p>noreturn.c:12: warning: control reaches end of non-void function </p>\n<pre><code>很显然，这是因为一个被定义为有返回值的函数却没有返回值。加上**attribute**((noreturn))则可以解决此问题的出现。 \n\n后面还有__attribute__const、-finstrument-functions、no_instrument_function等的属性描述，就不多转了，感兴趣的可以看原文。\n</code></pre><h3 id=\"3-变量属性-Variable-Attribute\"><a href=\"#3-变量属性-Variable-Attribute\" class=\"headerlink\" title=\"3.变量属性(Variable Attribute)\"></a>3.变量属性(Variable Attribute)</h3><pre><code>关键字__attribute__也可以对变量或结构体成员进行属性设置。这里给出几个常用的参数的解释，更多的参数可参考原文给出的连接。\n在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。\n`&lt;/pre&gt;\n\naligned (alignment) \n\n该属性规定变量或结构体成员的最小的对齐格式，以字节为单位。例如： \n\nint x **attribute** ((aligned (16))) = 0; \n\n    编译器将以16字节（注意是字节byte不是位bit）对齐的方式分配一个变量。也可以对结构体成员变量设置该属性，例如，创建一个双字对齐的int对，可以这么写： \n\nstruct foo { int x[2] **attribute** ((aligned (8))); }; \n\n    如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如： \n\nshort array[3] **attribute** ((aligned)); \n\n    选择针对目标机器最大的对齐方式，可以提高拷贝操作的效率。aligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。 \n\n    需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。 \n\n    使用该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。 \n\n    下面的例子中，x成员变量使用了该属性，则其值将紧放置在a的后面：  \n\n       struct test \n\n          { \n\n            char a; \n\n            int x[2] **attribute** ((packed)); \n\n          }; \n\n    其它可选的属性值还可以是：cleanup，common，nocommon，deprecated，mode，section，shared，tls_model，transparent_union，unused，vector_size，weak，dllimport，dlexport等。\n\n### 4.类型属性（Type Attribute）\n\n&lt;pre&gt;`关键字__attribute__也可以对结构体（struct）或共用体（union）进行属性设置。大致有六个参数值可以被设定，即：aligned, packed, transparent_union, unused, deprecated 和 may_alias。\n在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。\n</code></pre><p>aligned (alignment) </p>\n<p>该属性设定一个指定大小的对齐格式（以字节为单位），例如：  </p>\n<p>struct S { short f[3]; } <strong>attribute</strong> ((aligned (8))); </p>\n<p>typedef int more_aligned_int <strong>attribute</strong> ((aligned (8))); </p>\n<pre><code>该声明将强制编译器确保（尽它所能）变量类型为struct S或者more-aligned-int的变量在分配空间时采用8字节对齐方式。 \n\n如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如： \n</code></pre><p>struct S { short f[3]; } <strong>attribute</strong> ((aligned)); </p>\n<p>这里，如果sizeof（short）的大小为2（byte），那么，S的大小就为6。取一个2的次方值，使得该值大于等于6，则该值为8，所以编译器将设置S类型的对齐方式为8字节。 </p>\n<p>aligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。 </p>\n<p>需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。 </p>\n<pre><code>使用该属性对struct或者union类型进行定义，设定其类型的每一个变量的内存约束。当用在enum类型定义时，暗示了应该使用最小完整的类型（it indicates that the smallest integral type should be used）。 \n\n下面的例子中，my-packed-struct类型的变量数组中的值将会紧紧的靠在一起，但内部的成员变量s不会被“pack”，如果希望内部的成员变量也被packed的话，my-unpacked-struct也需要使用packed进行相应的约束。  \n</code></pre><p>struct my_unpacked_struct </p>\n<p>{ </p>\n<pre><code>char c; \n\nint i; \n</code></pre><p>};</p>\n<p>struct my_packed_struct </p>\n<p>{ </p>\n<pre><code>char c; \n\nint  i; \n\nstruct my_unpacked_struct s; \n</code></pre><p>}<strong>attribute</strong> ((<strong>packed</strong>));</p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/9/12 10:41:13 [原文链接](http://blog.csdn.net/weiniluo/article/details/52510949)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52510949#comments)\n&lt;/div&gt;\n</code></pre>","excerpt":"","more":"<p>内核中常会用到<strong>attribute</strong>，今天仔细了解一下这个<strong>attribute</strong>机制。</p>\n<h3 id=\"1-概要\"><a href=\"#1-概要\" class=\"headerlink\" title=\"1.概要\"></a>1.概要</h3><p><strong>attribute</strong>可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。它的书写特征是：<strong>attribute</strong>前后都有两个下划线，后面attribute-list是相应的<strong>attribute</strong>参数，语法格式如下： </p>\n<p><strong>attribute</strong> ((attribute-list)) </p>\n<p>另外，它必须放于声明的尾部“；”之前。</p>\n<h3 id=\"2-函数属性\"><a href=\"#2-函数属性\" class=\"headerlink\" title=\"2.函数属性\"></a>2.函数属性</h3><p>函数属性可以帮助开发者把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。<strong>attribute</strong>机制也很容易同非GNU应用程序做到兼容之功效。 </p>\n<pre><code>GNU CC需要使用 –Wall编译器来击活该功能，这是控制警告信息的一个很好的方式。下面介绍几个常见的属性参数。 \n\n**attribute** format。该**attribute**属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。format的语法格式为： \n</code></pre><p>format (archetype, string-index, first-to-check) </p>\n<p>format属性告诉编译器，按照printf, scanf, strftime或strfmon的参数表格式规则对该函数的参数进行检查。“archetype”指定是哪种风格；“string-index”指定传入函数的第几个参数是格式化字符串；“first-to-check”指定从函数的第几个参数开始按上述规则进行检查。 </p>\n<p>具体使用格式如下： </p>\n<p><strong>attribute</strong>((format(printf,m,n))) </p>\n<p><strong>attribute</strong>((format(scanf,m,n))) </p>\n<p>其中参数m与n的含义为： </p>\n<p>m：第几个参数为格式化字符串（format string）； </p>\n<p>n：参数集合中的第一个，即参数“…”里的第一个参数在函数参数总数排在第几，注意，有时函数参数里还有“隐身”的呢，后面会提到； </p>\n<pre><code>在使用上，**attribute**((format(printf,m,n)))是常用的，而另一种却很少见到。下面举例说明，其中myprint为自己定义的一个带有可变参数的函数，其功能类似于printf： \n</code></pre><p>//m=1；n=2 </p>\n<p>extern void myprint(const char <em>format,…) <em>*attribute</em></em>((format(printf,1,2))); </p>\n<p>//m=2；n=3 </p>\n<p>extern void myprint(int l，const char <em>format,…) <em>*attribute</em></em>((format(printf,2,3))); </p>\n<p>需要特别注意的是，如果myprint是一个函数的成员函数，那么m和n的值可有点“悬乎”了，例如： </p>\n<p>//m=3；n=4 </p>\n<p>extern void myprint(int l，const char <em>format,…) <em>*attribute</em></em>((format(printf,3,4))); </p>\n<pre><code>其原因是，类成员函数的第一个参数实际上一个“隐身”的“this”指针。（有点C++基础的都知道点this指针，不知道你在这里还知道吗？） \n\n这里给出测试用例：attribute.c，代码如下： \n</code></pre><p>[cpp] view plain copy </p>\n<p>extern void myprint(const char <em>format,…) <em>*attribute</em></em>((format(printf,1,2))); </p>\n<pre><code>void test() \n\n{ \n\n    myprint(“i=%d\\n”,6); \n\n    myprint(“i=%s\\n”,6); \n\n    myprint(“i=%s\\n”,”abc”); \n\n    myprint(“%s,%d,%d\\n”,1,2); \n\n} \n\ngcc编译后会提示format argument is not a pointer的警告。若去掉**attribute**((format(printf,1,2)))，则会正常编译。需要注意的是，编译器只能识别类似printf的标准输出库函数。 \n\n还有一个**attribute** noreturn，该属性通知编译器函数从不返回值，当遇到类似函数需要返回值而却不可能运行到返回值处就已经退出来的情况，该属性可以避免出现错误信息。C库函数中的abort()和exit()的声明格式就采用了这种格式，如下所示：  \n</code></pre><p>extern void exit(int)   <strong>attribute</strong>((noreturn)); </p>\n<p>extern void abort(void) <strong>attribute</strong>((noreturn)); </p>\n<p>为了方便理解，大家可以参考如下的例子： </p>\n<p>[cpp] view plain copy </p>\n<p>//name: noreturn.c  ；测试<strong>attribute</strong>((noreturn)) </p>\n<pre><code>extern void myexit(); \n\nint test(int n) \n\n{ \n\n    if ( n &amp;gt; 0 ) \n\n    { \n\n        myexit(); \n\n        /* 程序不可能到达这里*/ \n\n    } \n\n    else \n\n        return 0; \n\n} \n</code></pre><p>编译后的输出结果如下： </p>\n<p>$gcc –Wall –c noreturn.c </p>\n<p>noreturn.c: In function `test’: </p>\n<p>noreturn.c:12: warning: control reaches end of non-void function </p>\n<pre><code>很显然，这是因为一个被定义为有返回值的函数却没有返回值。加上**attribute**((noreturn))则可以解决此问题的出现。 \n\n后面还有__attribute__const、-finstrument-functions、no_instrument_function等的属性描述，就不多转了，感兴趣的可以看原文。\n</code></pre><h3 id=\"3-变量属性-Variable-Attribute\"><a href=\"#3-变量属性-Variable-Attribute\" class=\"headerlink\" title=\"3.变量属性(Variable Attribute)\"></a>3.变量属性(Variable Attribute)</h3><pre><code>关键字__attribute__也可以对变量或结构体成员进行属性设置。这里给出几个常用的参数的解释，更多的参数可参考原文给出的连接。\n在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。\n`&lt;/pre&gt;\n\naligned (alignment) \n\n该属性规定变量或结构体成员的最小的对齐格式，以字节为单位。例如： \n\nint x **attribute** ((aligned (16))) = 0; \n\n    编译器将以16字节（注意是字节byte不是位bit）对齐的方式分配一个变量。也可以对结构体成员变量设置该属性，例如，创建一个双字对齐的int对，可以这么写： \n\nstruct foo { int x[2] **attribute** ((aligned (8))); }; \n\n    如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如： \n\nshort array[3] **attribute** ((aligned)); \n\n    选择针对目标机器最大的对齐方式，可以提高拷贝操作的效率。aligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。 \n\n    需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。 \n\n    使用该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。 \n\n    下面的例子中，x成员变量使用了该属性，则其值将紧放置在a的后面：  \n\n       struct test \n\n          { \n\n            char a; \n\n            int x[2] **attribute** ((packed)); \n\n          }; \n\n    其它可选的属性值还可以是：cleanup，common，nocommon，deprecated，mode，section，shared，tls_model，transparent_union，unused，vector_size，weak，dllimport，dlexport等。\n\n### 4.类型属性（Type Attribute）\n\n&lt;pre&gt;`关键字__attribute__也可以对结构体（struct）或共用体（union）进行属性设置。大致有六个参数值可以被设定，即：aligned, packed, transparent_union, unused, deprecated 和 may_alias。\n在使用__attribute__参数时，你也可以在参数的前后都加上“__”（两个下划线），例如，使用__aligned__而不是aligned，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。\n</code></pre><p>aligned (alignment) </p>\n<p>该属性设定一个指定大小的对齐格式（以字节为单位），例如：  </p>\n<p>struct S { short f[3]; } <strong>attribute</strong> ((aligned (8))); </p>\n<p>typedef int more_aligned_int <strong>attribute</strong> ((aligned (8))); </p>\n<pre><code>该声明将强制编译器确保（尽它所能）变量类型为struct S或者more-aligned-int的变量在分配空间时采用8字节对齐方式。 \n\n如上所述，你可以手动指定对齐的格式，同样，你也可以使用默认的对齐方式。如果aligned后面不紧跟一个指定的数字值，那么编译器将依据你的目标机器情况使用最大最有益的对齐方式。例如： \n</code></pre><p>struct S { short f[3]; } <strong>attribute</strong> ((aligned)); </p>\n<p>这里，如果sizeof（short）的大小为2（byte），那么，S的大小就为6。取一个2的次方值，使得该值大于等于6，则该值为8，所以编译器将设置S类型的对齐方式为8字节。 </p>\n<p>aligned属性使被设置的对象占用更多的空间，相反的，使用packed可以减小对象占用的空间。 </p>\n<p>需要注意的是，attribute属性的效力与你的连接器也有关，如果你的连接器最大只支持16字节对齐，那么你此时定义32字节对齐也是无济于事的。 </p>\n<pre><code>使用该属性对struct或者union类型进行定义，设定其类型的每一个变量的内存约束。当用在enum类型定义时，暗示了应该使用最小完整的类型（it indicates that the smallest integral type should be used）。 \n\n下面的例子中，my-packed-struct类型的变量数组中的值将会紧紧的靠在一起，但内部的成员变量s不会被“pack”，如果希望内部的成员变量也被packed的话，my-unpacked-struct也需要使用packed进行相应的约束。  \n</code></pre><p>struct my_unpacked_struct </p>\n<p>{ </p>\n<pre><code>char c; \n\nint i; \n</code></pre><p>};</p>\n<p>struct my_packed_struct </p>\n<p>{ </p>\n<pre><code>char c; \n\nint  i; \n\nstruct my_unpacked_struct s; \n</code></pre><p>}<strong>attribute</strong> ((<strong>packed</strong>));</p>\n<pre><code>&lt;div&gt;\n    作者：WEINILUO 发表于2016/9/12 10:41:13 [原文链接](http://blog.csdn.net/weiniluo/article/details/52510949)\n&lt;/div&gt;\n&lt;div&gt;\n阅读：108 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/52510949#comments)\n&lt;/div&gt;\n</code></pre>"},{"title":"[转]搬瓦工网速优化net-speeder","date":"2016-07-08T15:04:53.000Z","_content":"\n### 下载并解压源文件：\n\n    :~# wget https://github.com/snooda/net-speeder/archive/master.zip\n    :~# unzip master.zip`\n\n    ### 安装编译环境：\n\n    apt-get install libnet1-dev\n    :~# apt-get install libpcap0.8-dev `\n\n    ### 编译：\n\n    `Linux Cooked interface使用编译（venetX，OpenVZ）：\n    :~# sh build.sh -DCOOKED\n\n    普通网卡使用编译（Xen，KVM，物理机）：\n    :~# sh build.sh`\n\n    ### 使用：\n\n    `需要root权限启动\n    #参数：./net_speeder 网卡名 加速规则（bpf规则）\n    #ovz用法(加速所有ip协议数据)： \n    :~# ./net_speeder venet0 \"ip\"`\n\n    ### 添加到开机启动项：\n\n    `:~# cp ./net_speeder /usr/bin\n    :~# echo -e 'nohup /usr/bin/net_speeder venet0 \"ip\" &gt;/dev/null 2&gt;&amp;1 &amp;\\nexit 0' &gt;&gt; /etc/rc.local\n\n### 参考文章：\n\n[https://github.com/snooda/net-speeder](https://github.com/snooda/net-speeder) \n\n[http://www.jianshu.com/p/f136b30ca3ba](http://www.jianshu.com/p/f136b30ca3ba)\n\n            \n                作者：WEINILUO 发表于2016/7/8 11:04:53 [原文链接](http://blog.csdn.net/weiniluo/article/details/51859247)\n            \n            \n           阅读：165 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51859247#comments)\n            \n","source":"_posts/转-搬瓦工网速优化net-speeder.md","raw":"---\ntitle: '[转]搬瓦工网速优化net-speeder'\ntags: []\ndate: 2016-07-08 11:04:53\n---\n\n### 下载并解压源文件：\n\n    :~# wget https://github.com/snooda/net-speeder/archive/master.zip\n    :~# unzip master.zip`\n\n    ### 安装编译环境：\n\n    apt-get install libnet1-dev\n    :~# apt-get install libpcap0.8-dev `\n\n    ### 编译：\n\n    `Linux Cooked interface使用编译（venetX，OpenVZ）：\n    :~# sh build.sh -DCOOKED\n\n    普通网卡使用编译（Xen，KVM，物理机）：\n    :~# sh build.sh`\n\n    ### 使用：\n\n    `需要root权限启动\n    #参数：./net_speeder 网卡名 加速规则（bpf规则）\n    #ovz用法(加速所有ip协议数据)： \n    :~# ./net_speeder venet0 \"ip\"`\n\n    ### 添加到开机启动项：\n\n    `:~# cp ./net_speeder /usr/bin\n    :~# echo -e 'nohup /usr/bin/net_speeder venet0 \"ip\" &gt;/dev/null 2&gt;&amp;1 &amp;\\nexit 0' &gt;&gt; /etc/rc.local\n\n### 参考文章：\n\n[https://github.com/snooda/net-speeder](https://github.com/snooda/net-speeder) \n\n[http://www.jianshu.com/p/f136b30ca3ba](http://www.jianshu.com/p/f136b30ca3ba)\n\n            \n                作者：WEINILUO 发表于2016/7/8 11:04:53 [原文链接](http://blog.csdn.net/weiniluo/article/details/51859247)\n            \n            \n           阅读：165 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51859247#comments)\n            \n","slug":"转-搬瓦工网速优化net-speeder","published":1,"updated":"2016-10-20T10:12:11.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciujdnodt000jvzs6aes2vwx1","content":"<h3 id=\"下载并解压源文件：\"><a href=\"#下载并解压源文件：\" class=\"headerlink\" title=\"下载并解压源文件：\"></a>下载并解压源文件：</h3><pre><code>:~# wget https://github.com/snooda/net-speeder/archive/master.zip\n:~# unzip master.zip`\n\n### 安装编译环境：\n\napt-get install libnet1-dev\n:~# apt-get install libpcap0.8-dev `\n\n### 编译：\n\n`Linux Cooked interface使用编译（venetX，OpenVZ）：\n:~# sh build.sh -DCOOKED\n\n普通网卡使用编译（Xen，KVM，物理机）：\n:~# sh build.sh`\n\n### 使用：\n\n`需要root权限启动\n#参数：./net_speeder 网卡名 加速规则（bpf规则）\n#ovz用法(加速所有ip协议数据)： \n:~# ./net_speeder venet0 &quot;ip&quot;`\n\n### 添加到开机启动项：\n\n`:~# cp ./net_speeder /usr/bin\n:~# echo -e &apos;nohup /usr/bin/net_speeder venet0 &quot;ip&quot; &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;\\nexit 0&apos; &amp;gt;&amp;gt; /etc/rc.local\n</code></pre><h3 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h3><p><a href=\"https://github.com/snooda/net-speeder\" target=\"_blank\" rel=\"external\">https://github.com/snooda/net-speeder</a> </p>\n<p><a href=\"http://www.jianshu.com/p/f136b30ca3ba\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/f136b30ca3ba</a></p>\n<pre><code>     作者：WEINILUO 发表于2016/7/8 11:04:53 [原文链接](http://blog.csdn.net/weiniluo/article/details/51859247)\n\n\n阅读：165 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51859247#comments)\n</code></pre>","excerpt":"","more":"<h3 id=\"下载并解压源文件：\"><a href=\"#下载并解压源文件：\" class=\"headerlink\" title=\"下载并解压源文件：\"></a>下载并解压源文件：</h3><pre><code>:~# wget https://github.com/snooda/net-speeder/archive/master.zip\n:~# unzip master.zip`\n\n### 安装编译环境：\n\napt-get install libnet1-dev\n:~# apt-get install libpcap0.8-dev `\n\n### 编译：\n\n`Linux Cooked interface使用编译（venetX，OpenVZ）：\n:~# sh build.sh -DCOOKED\n\n普通网卡使用编译（Xen，KVM，物理机）：\n:~# sh build.sh`\n\n### 使用：\n\n`需要root权限启动\n#参数：./net_speeder 网卡名 加速规则（bpf规则）\n#ovz用法(加速所有ip协议数据)： \n:~# ./net_speeder venet0 &quot;ip&quot;`\n\n### 添加到开机启动项：\n\n`:~# cp ./net_speeder /usr/bin\n:~# echo -e &apos;nohup /usr/bin/net_speeder venet0 &quot;ip&quot; &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;\\nexit 0&apos; &amp;gt;&amp;gt; /etc/rc.local\n</code></pre><h3 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h3><p><a href=\"https://github.com/snooda/net-speeder\">https://github.com/snooda/net-speeder</a> </p>\n<p><a href=\"http://www.jianshu.com/p/f136b30ca3ba\">http://www.jianshu.com/p/f136b30ca3ba</a></p>\n<pre><code>     作者：WEINILUO 发表于2016/7/8 11:04:53 [原文链接](http://blog.csdn.net/weiniluo/article/details/51859247)\n\n\n阅读：165 评论：0 [查看评论](http://blog.csdn.net/weiniluo/article/details/51859247#comments)\n</code></pre>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}